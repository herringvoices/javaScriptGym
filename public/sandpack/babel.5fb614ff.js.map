{"mappings":"C,A,S,C,C,C,C,C,C,C,C,C,E,I,E,A,a,O,W,W,A,a,O,K,K,A,a,O,O,O,A,a,O,O,O,C,E,E,A,Y,O,C,C,E,E,C,C,E,C,E,E,K,E,C,E,E,A,a,O,Q,A,Y,O,O,O,E,O,O,C,I,C,Q,S,E,C,C,C,E,G,C,C,C,E,C,C,G,C,C,C,E,C,C,I,E,A,Y,O,C,C,E,E,C,C,E,C,G,C,G,E,O,E,E,C,G,G,E,O,E,E,C,G,G,G,A,U,O,E,O,E,G,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,O,C,S,C,E,I,E,C,C,E,C,E,C,E,C,O,A,M,E,E,C,E,E,K,C,C,E,I,E,C,C,E,C,I,E,M,C,G,C,C,E,C,E,C,I,C,E,O,C,E,E,E,O,C,I,C,C,O,C,C,E,C,O,C,S,E,C,E,I,E,E,O,C,G,M,A,C,I,E,C,E,E,E,C,C,E,e,C,C,E,E,M,C,S,C,E,I,C,E,C,E,I,C,M,C,E,I,C,O,C,C,C,E,E,O,C,E,E,K,C,E,E,M,C,E,E,Q,C,S,C,C,C,E,C,C,E,C,C,S,C,C,C,E,E,O,C,C,E,C,E,A,E,O,c,C,E,O,C,I,W,O,C,C,E,A,C,G,C,C,E,C,E,I,I,E,E,E,E,M,C,I,E,C,C,E,C,E,C,M,C,S,C,C,C,C,C,E,O,c,C,E,a,C,M,C,C,G,E,a,C,K,E,E,O,CE+Qe,SACb4C,CAAW,CACXC,CAAuB,CACvBvB,CAA8C,EAG9C,OAAOwB,AADK,IAAIC,EAAUH,EAAKC,EAAMvB,GAC1B0B,QAAQ,EACrB,EAtRA,IAAAC,EAAAnC,EAAA,oBACAoC,EAAApC,EAAA,mBAmBA,OAAMiC,UAAkBqV,EAAAA,OAAO,CAC7BjV,YACEP,CAAW,CACXC,EAAyB,CAAC,CAAC,CAC3BvB,CAA6C,CAC7C,CAGA,KAAK,CAFU8B,AA2BnB,SACE9B,CAA6C,CAC7CuB,CAAsB,EACd,IAAAQ,EACR,IAAMC,EAAiB,CACrBC,uBAAwBV,EAAKU,sBAAsB,CACnDC,sBAAuBX,EAAKW,qBAAqB,CACjDC,mBAAoBZ,EAAKY,kBAAkB,CAC3CC,YAAab,EAAKa,WAAW,CAC7BC,qBAAsBd,EAAKc,oBAAoB,CAC/CC,SAAUf,AAAiB,MA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","sources":["<anon>","node_modules/@babel/generator/lib/index.js","node_modules/@babel/generator/src/index.ts","node_modules/@babel/generator/lib/source-map.js","node_modules/@babel/generator/src/source-map.ts","node_modules/@jridgewell/gen-mapping/dist/gen-mapping.mjs","node_modules/@jridgewell/gen-mapping/src/sourcemap-segment.ts","node_modules/@jridgewell/gen-mapping/src/gen-mapping.ts","node_modules/@jridgewell/set-array/dist/set-array.mjs","node_modules/@jridgewell/set-array/src/set-array.ts","node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs","node_modules/@jridgewell/sourcemap-codec/src/sourcemap-codec.ts","node_modules/@jridgewell/trace-mapping/dist/trace-mapping.mjs","node_modules/@jridgewell/trace-mapping/src/resolve.ts","node_modules/@jridgewell/trace-mapping/src/strip-filename.ts","node_modules/@jridgewell/trace-mapping/src/sourcemap-segment.ts","node_modules/@jridgewell/trace-mapping/src/sort.ts","node_modules/@jridgewell/trace-mapping/src/binary-search.ts","node_modules/@jridgewell/trace-mapping/src/by-source.ts","node_modules/@jridgewell/trace-mapping/src/any-map.ts","node_modules/@jridgewell/trace-mapping/src/trace-mapping.ts","node_modules/@jridgewell/resolve-uri/dist/resolve-uri.mjs","node_modules/@jridgewell/resolve-uri/src/resolve-uri.ts","node_modules/@babel/generator/lib/printer.js","node_modules/@babel/generator/src/printer.ts","node_modules/@babel/generator/lib/buffer.js","node_modules/@babel/generator/src/buffer.ts","node_modules/@babel/generator/lib/node/index.js","node_modules/@babel/generator/src/node/index.ts","node_modules/@babel/generator/lib/node/whitespace.js","node_modules/@babel/generator/src/node/whitespace.ts","node_modules/@babel/generator/lib/node/parentheses.js","node_modules/@babel/generator/src/node/parentheses.ts","node_modules/@babel/generator/lib/generators/index.js","node_modules/@babel/generator/src/generators/index.ts","node_modules/@babel/generator/lib/generators/template-literals.js","node_modules/@babel/generator/src/generators/template-literals.ts","node_modules/@babel/generator/lib/generators/expressions.js","node_modules/@babel/generator/src/generators/expressions.ts","node_modules/@babel/generator/lib/generators/statements.js","node_modules/@babel/generator/src/generators/statements.ts","node_modules/@babel/generator/lib/generators/classes.js","node_modules/@babel/generator/src/generators/classes.ts","node_modules/@babel/generator/lib/generators/methods.js","node_modules/@babel/generator/src/generators/methods.ts","node_modules/@babel/generator/lib/generators/modules.js","node_modules/@babel/generator/src/generators/modules.ts","node_modules/@babel/generator/lib/generators/types.js","node_modules/@babel/generator/src/generators/types.ts","node_modules/jsesc/jsesc.js","node_modules/@babel/generator/lib/generators/flow.js","node_modules/@babel/generator/src/generators/flow.ts","node_modules/@babel/generator/lib/generators/base.js","node_modules/@babel/generator/src/generators/base.ts","node_modules/@babel/generator/lib/generators/jsx.js","node_modules/@babel/generator/src/generators/jsx.ts","node_modules/@babel/generator/lib/generators/typescript.js","node_modules/@babel/generator/src/generators/typescript.ts","node_modules/@babel/helper-module-imports/lib/index.js","node_modules/@babel/helper-module-imports/src/index.ts","node_modules/@babel/helper-module-imports/lib/import-injector.js","node_modules/@babel/helper-module-imports/src/import-injector.ts","node_modules/@babel/helper-module-imports/lib/import-builder.js","node_modules/@babel/helper-module-imports/src/import-builder.ts","node_modules/@babel/helper-module-imports/lib/is-module.js","node_modules/@babel/helper-module-imports/src/is-module.ts"],"sourcesContent":["// modules are defined as an array\n// [ module function, map of requires ]\n//\n// map of requires is short require name -> numeric require\n//\n// anything defined in a previous bundle is accessed via the\n// orig method which is the require for previous bundles\n\n(function (modules, entry, mainEntry, parcelRequireName, globalName) {\n  /* eslint-disable no-undef */\n  var globalObject =\n    typeof globalThis !== 'undefined'\n      ? globalThis\n      : typeof self !== 'undefined'\n      ? self\n      : typeof window !== 'undefined'\n      ? window\n      : typeof global !== 'undefined'\n      ? global\n      : {};\n  /* eslint-enable no-undef */\n\n  // Save the require from previous bundle to this closure if any\n  var previousRequire =\n    typeof globalObject[parcelRequireName] === 'function' &&\n    globalObject[parcelRequireName];\n\n  var cache = previousRequire.cache || {};\n  // Do not use `require` to prevent Webpack from trying to bundle this call\n  var nodeRequire =\n    typeof module !== 'undefined' &&\n    typeof module.require === 'function' &&\n    module.require.bind(module);\n\n  function newRequire(name, jumped) {\n    if (!cache[name]) {\n      if (!modules[name]) {\n        // if we cannot find the module within our internal map or\n        // cache jump to the current global require ie. the last bundle\n        // that was added to the page.\n        var currentRequire =\n          typeof globalObject[parcelRequireName] === 'function' &&\n          globalObject[parcelRequireName];\n        if (!jumped && currentRequire) {\n          return currentRequire(name, true);\n        }\n\n        // If there are other bundles on this page the require from the\n        // previous one is saved to 'previousRequire'. Repeat this as\n        // many times as there are bundles until the module is found or\n        // we exhaust the require chain.\n        if (previousRequire) {\n          return previousRequire(name, true);\n        }\n\n        // Try the node require function if it exists.\n        if (nodeRequire && typeof name === 'string') {\n          return nodeRequire(name);\n        }\n\n        var err = new Error(\"Cannot find module '\" + name + \"'\");\n        err.code = 'MODULE_NOT_FOUND';\n        throw err;\n      }\n\n      localRequire.resolve = resolve;\n      localRequire.cache = {};\n\n      var module = (cache[name] = new newRequire.Module(name));\n\n      modules[name][0].call(\n        module.exports,\n        localRequire,\n        module,\n        module.exports,\n        this\n      );\n    }\n\n    return cache[name].exports;\n\n    function localRequire(x) {\n      var res = localRequire.resolve(x);\n      return res === false ? {} : newRequire(res);\n    }\n\n    function resolve(x) {\n      var id = modules[name][1][x];\n      return id != null ? id : x;\n    }\n  }\n\n  function Module(moduleName) {\n    this.id = moduleName;\n    this.bundle = newRequire;\n    this.exports = {};\n  }\n\n  newRequire.isParcelRequire = true;\n  newRequire.Module = Module;\n  newRequire.modules = modules;\n  newRequire.cache = cache;\n  newRequire.parent = previousRequire;\n  newRequire.register = function (id, exports) {\n    modules[id] = [\n      function (require, module) {\n        module.exports = exports;\n      },\n      {},\n    ];\n  };\n\n  Object.defineProperty(newRequire, 'root', {\n    get: function () {\n      return globalObject[parcelRequireName];\n    },\n  });\n\n  globalObject[parcelRequireName] = newRequire;\n\n  for (var i = 0; i < entry.length; i++) {\n    newRequire(entry[i]);\n  }\n\n  if (mainEntry) {\n    // Expose entry point to Node, AMD or browser globals\n    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js\n    var mainExports = newRequire(mainEntry);\n\n    // CommonJS\n    if (typeof exports === 'object' && typeof module !== 'undefined') {\n      module.exports = mainExports;\n\n      // RequireJS\n    } else if (typeof define === 'function' && define.amd) {\n      define(function () {\n        return mainExports;\n      });\n\n      // <script>\n    } else if (globalName) {\n      this[globalName] = mainExports;\n    }\n  }\n})({\"kqljx\":[function(require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.CodeGenerator = void 0;\nexports.default = generate;\nvar _sourceMap = require(\"76c34986c6383956\");\nvar _printer = require(\"c9220772c25eee84\");\nclass Generator extends _printer.default {\n    constructor(ast, opts = {}, code){\n        const format = normalizeOptions(code, opts);\n        const map = opts.sourceMaps ? new _sourceMap.default(opts, code) : null;\n        super(format, map);\n        this.ast = void 0;\n        this.ast = ast;\n    }\n    generate() {\n        return super.generate(this.ast);\n    }\n}\nfunction normalizeOptions(code, opts) {\n    var _opts$recordAndTupleS;\n    const format = {\n        auxiliaryCommentBefore: opts.auxiliaryCommentBefore,\n        auxiliaryCommentAfter: opts.auxiliaryCommentAfter,\n        shouldPrintComment: opts.shouldPrintComment,\n        retainLines: opts.retainLines,\n        retainFunctionParens: opts.retainFunctionParens,\n        comments: opts.comments == null || opts.comments,\n        compact: opts.compact,\n        minified: opts.minified,\n        concise: opts.concise,\n        indent: {\n            adjustMultilineComment: true,\n            style: \"  \"\n        },\n        jsescOption: Object.assign({\n            quotes: \"double\",\n            wrap: true,\n            minimal: false\n        }, opts.jsescOption),\n        recordAndTupleSyntaxType: (_opts$recordAndTupleS = opts.recordAndTupleSyntaxType) != null ? _opts$recordAndTupleS : \"hash\",\n        topicToken: opts.topicToken,\n        importAttributesKeyword: opts.importAttributesKeyword\n    };\n    format.decoratorsBeforeExport = opts.decoratorsBeforeExport;\n    format.jsescOption.json = opts.jsonCompatibleStrings;\n    if (format.minified) {\n        format.compact = true;\n        format.shouldPrintComment = format.shouldPrintComment || (()=>format.comments);\n    } else format.shouldPrintComment = format.shouldPrintComment || ((value)=>format.comments || value.includes(\"@license\") || value.includes(\"@preserve\"));\n    if (format.compact === \"auto\") {\n        format.compact = typeof code === \"string\" && code.length > 500000;\n        if (format.compact) console.error(\"[BABEL] Note: The code generator has deoptimised the styling of \" + `${opts.filename} as it exceeds the max of ${\"500KB\"}.`);\n    }\n    if (format.compact) format.indent.adjustMultilineComment = false;\n    const { auxiliaryCommentBefore, auxiliaryCommentAfter, shouldPrintComment } = format;\n    if (auxiliaryCommentBefore && !shouldPrintComment(auxiliaryCommentBefore)) format.auxiliaryCommentBefore = undefined;\n    if (auxiliaryCommentAfter && !shouldPrintComment(auxiliaryCommentAfter)) format.auxiliaryCommentAfter = undefined;\n    return format;\n}\nclass CodeGenerator {\n    constructor(ast, opts, code){\n        this._generator = void 0;\n        this._generator = new Generator(ast, opts, code);\n    }\n    generate() {\n        return this._generator.generate();\n    }\n}\nexports.CodeGenerator = CodeGenerator;\nfunction generate(ast, opts, code) {\n    const gen = new Generator(ast, opts, code);\n    return gen.generate();\n}\n\n},{\"76c34986c6383956\":\"hxSEk\",\"c9220772c25eee84\":\"coQM7\"}],\"hxSEk\":[function(require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = void 0;\nvar _genMapping = require(\"38b7a5f46a79a829\");\nvar _traceMapping = require(\"b0385a48ea9008f7\");\nclass SourceMap {\n    constructor(opts, code){\n        var _opts$sourceFileName;\n        this._map = void 0;\n        this._rawMappings = void 0;\n        this._sourceFileName = void 0;\n        this._lastGenLine = 0;\n        this._lastSourceLine = 0;\n        this._lastSourceColumn = 0;\n        this._inputMap = void 0;\n        const map = this._map = new _genMapping.GenMapping({\n            sourceRoot: opts.sourceRoot\n        });\n        this._sourceFileName = (_opts$sourceFileName = opts.sourceFileName) == null ? void 0 : _opts$sourceFileName.replace(/\\\\/g, \"/\");\n        this._rawMappings = undefined;\n        if (opts.inputSourceMap) {\n            this._inputMap = new _traceMapping.TraceMap(opts.inputSourceMap);\n            const resolvedSources = this._inputMap.resolvedSources;\n            if (resolvedSources.length) for(let i = 0; i < resolvedSources.length; i++){\n                var _this$_inputMap$sourc;\n                (0, _genMapping.setSourceContent)(map, resolvedSources[i], (_this$_inputMap$sourc = this._inputMap.sourcesContent) == null ? void 0 : _this$_inputMap$sourc[i]);\n            }\n        }\n        if (typeof code === \"string\" && !opts.inputSourceMap) (0, _genMapping.setSourceContent)(map, this._sourceFileName, code);\n        else if (typeof code === \"object\") for (const sourceFileName of Object.keys(code))(0, _genMapping.setSourceContent)(map, sourceFileName.replace(/\\\\/g, \"/\"), code[sourceFileName]);\n    }\n    get() {\n        return (0, _genMapping.toEncodedMap)(this._map);\n    }\n    getDecoded() {\n        return (0, _genMapping.toDecodedMap)(this._map);\n    }\n    getRawMappings() {\n        return this._rawMappings || (this._rawMappings = (0, _genMapping.allMappings)(this._map));\n    }\n    mark(generated, line, column, identifierName, identifierNamePos, filename) {\n        var _originalMapping;\n        this._rawMappings = undefined;\n        let originalMapping;\n        if (line != null) {\n            if (this._inputMap) {\n                originalMapping = (0, _traceMapping.originalPositionFor)(this._inputMap, {\n                    line,\n                    column\n                });\n                if (!originalMapping.name && identifierNamePos) {\n                    const originalIdentifierMapping = (0, _traceMapping.originalPositionFor)(this._inputMap, identifierNamePos);\n                    if (originalIdentifierMapping.name) identifierName = originalIdentifierMapping.name;\n                }\n            } else originalMapping = {\n                source: (filename == null ? void 0 : filename.replace(/\\\\/g, \"/\")) || this._sourceFileName,\n                line: line,\n                column: column\n            };\n        }\n        (0, _genMapping.maybeAddMapping)(this._map, {\n            name: identifierName,\n            generated,\n            source: (_originalMapping = originalMapping) == null ? void 0 : _originalMapping.source,\n            original: originalMapping\n        });\n    }\n}\nexports.default = SourceMap;\n\n},{\"38b7a5f46a79a829\":\"gLPQ1\",\"b0385a48ea9008f7\":\"3amw1\"}],\"gLPQ1\":[function(require,module,exports) {\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"GenMapping\", ()=>GenMapping);\nparcelHelpers.export(exports, \"addMapping\", ()=>addMapping);\nparcelHelpers.export(exports, \"addSegment\", ()=>addSegment);\nparcelHelpers.export(exports, \"allMappings\", ()=>allMappings);\nparcelHelpers.export(exports, \"fromMap\", ()=>fromMap);\nparcelHelpers.export(exports, \"maybeAddMapping\", ()=>maybeAddMapping);\nparcelHelpers.export(exports, \"maybeAddSegment\", ()=>maybeAddSegment);\nparcelHelpers.export(exports, \"setSourceContent\", ()=>setSourceContent);\nparcelHelpers.export(exports, \"toDecodedMap\", ()=>toDecodedMap);\nparcelHelpers.export(exports, \"toEncodedMap\", ()=>toEncodedMap);\nvar _setArray = require(\"@jridgewell/set-array\");\nvar _sourcemapCodec = require(\"@jridgewell/sourcemap-codec\");\nvar _traceMapping = require(\"@jridgewell/trace-mapping\");\nconst COLUMN = 0;\nconst SOURCES_INDEX = 1;\nconst SOURCE_LINE = 2;\nconst SOURCE_COLUMN = 3;\nconst NAMES_INDEX = 4;\nconst NO_NAME = -1;\n/**\n * A low-level API to associate a generated position with an original source position. Line and\n * column here are 0-based, unlike `addMapping`.\n */ let addSegment;\n/**\n * A high-level API to associate a generated position with an original source position. Line is\n * 1-based, but column is 0-based, due to legacy behavior in `source-map` library.\n */ let addMapping;\n/**\n * Same as `addSegment`, but will only add the segment if it generates useful information in the\n * resulting map. This only works correctly if segments are added **in order**, meaning you should\n * not add a segment with a lower generated line/column than one that came before.\n */ let maybeAddSegment;\n/**\n * Same as `addMapping`, but will only add the mapping if it generates useful information in the\n * resulting map. This only works correctly if mappings are added **in order**, meaning you should\n * not add a mapping with a lower generated line/column than one that came before.\n */ let maybeAddMapping;\n/**\n * Adds/removes the content of the source file to the source map.\n */ let setSourceContent;\n/**\n * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */ let toDecodedMap;\n/**\n * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */ let toEncodedMap;\n/**\n * Constructs a new GenMapping, using the already present mappings of the input.\n */ let fromMap;\n/**\n * Returns an array of high-level mapping objects for every recorded segment, which could then be\n * passed to the `source-map` library.\n */ let allMappings;\n// This split declaration is only so that terser can elminiate the static initialization block.\nlet addSegmentInternal;\n/**\n * Provides the state to generate a sourcemap.\n */ class GenMapping {\n    constructor({ file, sourceRoot } = {}){\n        this._names = new (0, _setArray.SetArray)();\n        this._sources = new (0, _setArray.SetArray)();\n        this._sourcesContent = [];\n        this._mappings = [];\n        this.file = file;\n        this.sourceRoot = sourceRoot;\n    }\n}\n(()=>{\n    addSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name, content)=>{\n        return addSegmentInternal(false, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);\n    };\n    maybeAddSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name, content)=>{\n        return addSegmentInternal(true, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);\n    };\n    addMapping = (map, mapping)=>{\n        return addMappingInternal(false, map, mapping);\n    };\n    maybeAddMapping = (map, mapping)=>{\n        return addMappingInternal(true, map, mapping);\n    };\n    setSourceContent = (map, source, content)=>{\n        const { _sources: sources, _sourcesContent: sourcesContent } = map;\n        sourcesContent[(0, _setArray.put)(sources, source)] = content;\n    };\n    toDecodedMap = (map)=>{\n        const { file, sourceRoot, _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names } = map;\n        removeEmptyFinalLines(mappings);\n        return {\n            version: 3,\n            file: file || undefined,\n            names: names.array,\n            sourceRoot: sourceRoot || undefined,\n            sources: sources.array,\n            sourcesContent,\n            mappings\n        };\n    };\n    toEncodedMap = (map)=>{\n        const decoded = toDecodedMap(map);\n        return Object.assign(Object.assign({}, decoded), {\n            mappings: (0, _sourcemapCodec.encode)(decoded.mappings)\n        });\n    };\n    allMappings = (map)=>{\n        const out = [];\n        const { _mappings: mappings, _sources: sources, _names: names } = map;\n        for(let i = 0; i < mappings.length; i++){\n            const line = mappings[i];\n            for(let j = 0; j < line.length; j++){\n                const seg = line[j];\n                const generated = {\n                    line: i + 1,\n                    column: seg[COLUMN]\n                };\n                let source = undefined;\n                let original = undefined;\n                let name = undefined;\n                if (seg.length !== 1) {\n                    source = sources.array[seg[SOURCES_INDEX]];\n                    original = {\n                        line: seg[SOURCE_LINE] + 1,\n                        column: seg[SOURCE_COLUMN]\n                    };\n                    if (seg.length === 5) name = names.array[seg[NAMES_INDEX]];\n                }\n                out.push({\n                    generated,\n                    source,\n                    original,\n                    name\n                });\n            }\n        }\n        return out;\n    };\n    fromMap = (input)=>{\n        const map = new (0, _traceMapping.TraceMap)(input);\n        const gen = new GenMapping({\n            file: map.file,\n            sourceRoot: map.sourceRoot\n        });\n        putAll(gen._names, map.names);\n        putAll(gen._sources, map.sources);\n        gen._sourcesContent = map.sourcesContent || map.sources.map(()=>null);\n        gen._mappings = (0, _traceMapping.decodedMappings)(map);\n        return gen;\n    };\n    // Internal helpers\n    addSegmentInternal = (skipable, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content)=>{\n        const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names } = map;\n        const line = getLine(mappings, genLine);\n        const index = getColumnIndex(line, genColumn);\n        if (!source) {\n            if (skipable && skipSourceless(line, index)) return;\n            return insert(line, index, [\n                genColumn\n            ]);\n        }\n        const sourcesIndex = (0, _setArray.put)(sources, source);\n        const namesIndex = name ? (0, _setArray.put)(names, name) : NO_NAME;\n        if (sourcesIndex === sourcesContent.length) sourcesContent[sourcesIndex] = content !== null && content !== void 0 ? content : null;\n        if (skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) return;\n        return insert(line, index, name ? [\n            genColumn,\n            sourcesIndex,\n            sourceLine,\n            sourceColumn,\n            namesIndex\n        ] : [\n            genColumn,\n            sourcesIndex,\n            sourceLine,\n            sourceColumn\n        ]);\n    };\n})();\nfunction getLine(mappings, index) {\n    for(let i = mappings.length; i <= index; i++)mappings[i] = [];\n    return mappings[index];\n}\nfunction getColumnIndex(line, genColumn) {\n    let index = line.length;\n    for(let i = index - 1; i >= 0; index = i--){\n        const current = line[i];\n        if (genColumn >= current[COLUMN]) break;\n    }\n    return index;\n}\nfunction insert(array, index, value) {\n    for(let i = array.length; i > index; i--)array[i] = array[i - 1];\n    array[index] = value;\n}\nfunction removeEmptyFinalLines(mappings) {\n    const { length } = mappings;\n    let len = length;\n    for(let i = len - 1; i >= 0; len = i, i--){\n        if (mappings[i].length > 0) break;\n    }\n    if (len < length) mappings.length = len;\n}\nfunction putAll(strarr, array) {\n    for(let i = 0; i < array.length; i++)(0, _setArray.put)(strarr, array[i]);\n}\nfunction skipSourceless(line, index) {\n    // The start of a line is already sourceless, so adding a sourceless segment to the beginning\n    // doesn't generate any useful information.\n    if (index === 0) return true;\n    const prev = line[index - 1];\n    // If the previous segment is also sourceless, then adding another sourceless segment doesn't\n    // genrate any new information. Else, this segment will end the source/named segment and point to\n    // a sourceless position, which is useful.\n    return prev.length === 1;\n}\nfunction skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex) {\n    // A source/named segment at the start of a line gives position at that genColumn\n    if (index === 0) return false;\n    const prev = line[index - 1];\n    // If the previous segment is sourceless, then we're transitioning to a source.\n    if (prev.length === 1) return false;\n    // If the previous segment maps to the exact same source position, then this segment doesn't\n    // provide any new position information.\n    return sourcesIndex === prev[SOURCES_INDEX] && sourceLine === prev[SOURCE_LINE] && sourceColumn === prev[SOURCE_COLUMN] && namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME);\n}\nfunction addMappingInternal(skipable, map, mapping) {\n    const { generated, source, original, name, content } = mapping;\n    if (!source) return addSegmentInternal(skipable, map, generated.line - 1, generated.column, null, null, null, null, null);\n    const s = source;\n    return addSegmentInternal(skipable, map, generated.line - 1, generated.column, s, original.line - 1, original.column, name, content);\n}\n\n},{\"@jridgewell/set-array\":\"44OGB\",\"@jridgewell/sourcemap-codec\":\"5WRup\",\"@jridgewell/trace-mapping\":\"3amw1\",\"@parcel/transformer-js/src/esmodule-helpers.js\":\"arbnz\"}],\"44OGB\":[function(require,module,exports) {\n/**\n * Gets the index associated with `key` in the backing array, if it is already present.\n */ var parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"SetArray\", ()=>SetArray);\nparcelHelpers.export(exports, \"get\", ()=>get);\nparcelHelpers.export(exports, \"pop\", ()=>pop);\nparcelHelpers.export(exports, \"put\", ()=>put);\nlet get;\n/**\n * Puts `key` into the backing array, if it is not already present. Returns\n * the index of the `key` in the backing array.\n */ let put;\n/**\n * Pops the last added item out of the SetArray.\n */ let pop;\n/**\n * SetArray acts like a `Set` (allowing only one occurrence of a string `key`), but provides the\n * index of the `key` in the backing array.\n *\n * This is designed to allow synchronizing a second array with the contents of the backing array,\n * like how in a sourcemap `sourcesContent[i]` is the source content associated with `source[i]`,\n * and there are never duplicates.\n */ class SetArray {\n    constructor(){\n        this._indexes = {\n            __proto__: null\n        };\n        this.array = [];\n    }\n}\n(()=>{\n    get = (strarr, key)=>strarr._indexes[key];\n    put = (strarr, key)=>{\n        // The key may or may not be present. If it is present, it's a number.\n        const index = get(strarr, key);\n        if (index !== undefined) return index;\n        const { array, _indexes: indexes } = strarr;\n        return indexes[key] = array.push(key) - 1;\n    };\n    pop = (strarr)=>{\n        const { array, _indexes: indexes } = strarr;\n        if (array.length === 0) return;\n        const last = array.pop();\n        indexes[last] = undefined;\n    };\n})();\n\n},{\"@parcel/transformer-js/src/esmodule-helpers.js\":\"arbnz\"}],\"5WRup\":[function(require,module,exports) {\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"decode\", ()=>decode);\nparcelHelpers.export(exports, \"encode\", ()=>encode);\nvar Buffer = require(\"1a93b437c27d5a3f\").Buffer;\nconst comma = \",\".charCodeAt(0);\nconst semicolon = \";\".charCodeAt(0);\nconst chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nconst intToChar = new Uint8Array(64); // 64 possible chars.\nconst charToInt = new Uint8Array(128); // z is 122 in ASCII\nfor(let i = 0; i < chars.length; i++){\n    const c = chars.charCodeAt(i);\n    intToChar[i] = c;\n    charToInt[c] = i;\n}\n// Provide a fallback for older environments.\nconst td = typeof TextDecoder !== \"undefined\" ? /* #__PURE__ */ new TextDecoder() : typeof Buffer !== \"undefined\" ? {\n    decode (buf) {\n        const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);\n        return out.toString();\n    }\n} : {\n    decode (buf) {\n        let out = \"\";\n        for(let i = 0; i < buf.length; i++)out += String.fromCharCode(buf[i]);\n        return out;\n    }\n};\nfunction decode(mappings) {\n    const state = new Int32Array(5);\n    const decoded = [];\n    let index = 0;\n    do {\n        const semi = indexOf(mappings, index);\n        const line = [];\n        let sorted = true;\n        let lastCol = 0;\n        state[0] = 0;\n        for(let i = index; i < semi; i++){\n            let seg;\n            i = decodeInteger(mappings, i, state, 0); // genColumn\n            const col = state[0];\n            if (col < lastCol) sorted = false;\n            lastCol = col;\n            if (hasMoreVlq(mappings, i, semi)) {\n                i = decodeInteger(mappings, i, state, 1); // sourcesIndex\n                i = decodeInteger(mappings, i, state, 2); // sourceLine\n                i = decodeInteger(mappings, i, state, 3); // sourceColumn\n                if (hasMoreVlq(mappings, i, semi)) {\n                    i = decodeInteger(mappings, i, state, 4); // namesIndex\n                    seg = [\n                        col,\n                        state[1],\n                        state[2],\n                        state[3],\n                        state[4]\n                    ];\n                } else seg = [\n                    col,\n                    state[1],\n                    state[2],\n                    state[3]\n                ];\n            } else seg = [\n                col\n            ];\n            line.push(seg);\n        }\n        if (!sorted) sort(line);\n        decoded.push(line);\n        index = semi + 1;\n    }while (index <= mappings.length);\n    return decoded;\n}\nfunction indexOf(mappings, index) {\n    const idx = mappings.indexOf(\";\", index);\n    return idx === -1 ? mappings.length : idx;\n}\nfunction decodeInteger(mappings, pos, state, j) {\n    let value = 0;\n    let shift = 0;\n    let integer = 0;\n    do {\n        const c = mappings.charCodeAt(pos++);\n        integer = charToInt[c];\n        value |= (integer & 31) << shift;\n        shift += 5;\n    }while (integer & 32);\n    const shouldNegate = value & 1;\n    value >>>= 1;\n    if (shouldNegate) value = -2147483648 | -value;\n    state[j] += value;\n    return pos;\n}\nfunction hasMoreVlq(mappings, i, length) {\n    if (i >= length) return false;\n    return mappings.charCodeAt(i) !== comma;\n}\nfunction sort(line) {\n    line.sort(sortComparator);\n}\nfunction sortComparator(a, b) {\n    return a[0] - b[0];\n}\nfunction encode(decoded) {\n    const state = new Int32Array(5);\n    const bufLength = 16384;\n    const subLength = bufLength - 36;\n    const buf = new Uint8Array(bufLength);\n    const sub = buf.subarray(0, subLength);\n    let pos = 0;\n    let out = \"\";\n    for(let i = 0; i < decoded.length; i++){\n        const line = decoded[i];\n        if (i > 0) {\n            if (pos === bufLength) {\n                out += td.decode(buf);\n                pos = 0;\n            }\n            buf[pos++] = semicolon;\n        }\n        if (line.length === 0) continue;\n        state[0] = 0;\n        for(let j = 0; j < line.length; j++){\n            const segment = line[j];\n            // We can push up to 5 ints, each int can take at most 7 chars, and we\n            // may push a comma.\n            if (pos > subLength) {\n                out += td.decode(sub);\n                buf.copyWithin(0, subLength, pos);\n                pos -= subLength;\n            }\n            if (j > 0) buf[pos++] = comma;\n            pos = encodeInteger(buf, pos, state, segment, 0); // genColumn\n            if (segment.length === 1) continue;\n            pos = encodeInteger(buf, pos, state, segment, 1); // sourcesIndex\n            pos = encodeInteger(buf, pos, state, segment, 2); // sourceLine\n            pos = encodeInteger(buf, pos, state, segment, 3); // sourceColumn\n            if (segment.length === 4) continue;\n            pos = encodeInteger(buf, pos, state, segment, 4); // namesIndex\n        }\n    }\n    return out + td.decode(buf.subarray(0, pos));\n}\nfunction encodeInteger(buf, pos, state, segment, j) {\n    const next = segment[j];\n    let num = next - state[j];\n    state[j] = next;\n    num = num < 0 ? -num << 1 | 1 : num << 1;\n    do {\n        let clamped = num & 31;\n        num >>>= 5;\n        if (num > 0) clamped |= 32;\n        buf[pos++] = intToChar[clamped];\n    }while (num > 0);\n    return pos;\n}\n\n},{\"1a93b437c27d5a3f\":\"hNvPC\",\"@parcel/transformer-js/src/esmodule-helpers.js\":\"arbnz\"}],\"3amw1\":[function(require,module,exports) {\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"AnyMap\", ()=>AnyMap);\nparcelHelpers.export(exports, \"GREATEST_LOWER_BOUND\", ()=>GREATEST_LOWER_BOUND);\nparcelHelpers.export(exports, \"LEAST_UPPER_BOUND\", ()=>LEAST_UPPER_BOUND);\nparcelHelpers.export(exports, \"TraceMap\", ()=>TraceMap);\nparcelHelpers.export(exports, \"allGeneratedPositionsFor\", ()=>allGeneratedPositionsFor);\nparcelHelpers.export(exports, \"decodedMap\", ()=>decodedMap);\nparcelHelpers.export(exports, \"decodedMappings\", ()=>decodedMappings);\nparcelHelpers.export(exports, \"eachMapping\", ()=>eachMapping);\nparcelHelpers.export(exports, \"encodedMap\", ()=>encodedMap);\nparcelHelpers.export(exports, \"encodedMappings\", ()=>encodedMappings);\nparcelHelpers.export(exports, \"generatedPositionFor\", ()=>generatedPositionFor);\nparcelHelpers.export(exports, \"originalPositionFor\", ()=>originalPositionFor);\nparcelHelpers.export(exports, \"presortedDecodedMap\", ()=>presortedDecodedMap);\nparcelHelpers.export(exports, \"sourceContentFor\", ()=>sourceContentFor);\nparcelHelpers.export(exports, \"traceSegment\", ()=>traceSegment);\nvar _sourcemapCodec = require(\"@jridgewell/sourcemap-codec\");\nvar _resolveUri = require(\"@jridgewell/resolve-uri\");\nvar _resolveUriDefault = parcelHelpers.interopDefault(_resolveUri);\nfunction resolve(input, base) {\n    // The base is always treated as a directory, if it's not empty.\n    // https://github.com/mozilla/source-map/blob/8cb3ee57/lib/util.js#L327\n    // https://github.com/chromium/chromium/blob/da4adbb3/third_party/blink/renderer/devtools/front_end/sdk/SourceMap.js#L400-L401\n    if (base && !base.endsWith(\"/\")) base += \"/\";\n    return (0, _resolveUriDefault.default)(input, base);\n}\n/**\n * Removes everything after the last \"/\", but leaves the slash.\n */ function stripFilename(path) {\n    if (!path) return \"\";\n    const index = path.lastIndexOf(\"/\");\n    return path.slice(0, index + 1);\n}\nconst COLUMN = 0;\nconst SOURCES_INDEX = 1;\nconst SOURCE_LINE = 2;\nconst SOURCE_COLUMN = 3;\nconst NAMES_INDEX = 4;\nconst REV_GENERATED_LINE = 1;\nconst REV_GENERATED_COLUMN = 2;\nfunction maybeSort(mappings, owned) {\n    const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);\n    if (unsortedIndex === mappings.length) return mappings;\n    // If we own the array (meaning we parsed it from JSON), then we're free to directly mutate it. If\n    // not, we do not want to modify the consumer's input array.\n    if (!owned) mappings = mappings.slice();\n    for(let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1))mappings[i] = sortSegments(mappings[i], owned);\n    return mappings;\n}\nfunction nextUnsortedSegmentLine(mappings, start) {\n    for(let i = start; i < mappings.length; i++){\n        if (!isSorted(mappings[i])) return i;\n    }\n    return mappings.length;\n}\nfunction isSorted(line) {\n    for(let j = 1; j < line.length; j++){\n        if (line[j][COLUMN] < line[j - 1][COLUMN]) return false;\n    }\n    return true;\n}\nfunction sortSegments(line, owned) {\n    if (!owned) line = line.slice();\n    return line.sort(sortComparator);\n}\nfunction sortComparator(a, b) {\n    return a[COLUMN] - b[COLUMN];\n}\nlet found = false;\n/**\n * A binary search implementation that returns the index if a match is found.\n * If no match is found, then the left-index (the index associated with the item that comes just\n * before the desired index) is returned. To maintain proper sort order, a splice would happen at\n * the next index:\n *\n * ```js\n * const array = [1, 3];\n * const needle = 2;\n * const index = binarySearch(array, needle, (item, needle) => item - needle);\n *\n * assert.equal(index, 0);\n * array.splice(index + 1, 0, needle);\n * assert.deepEqual(array, [1, 2, 3]);\n * ```\n */ function binarySearch(haystack, needle, low, high) {\n    while(low <= high){\n        const mid = low + (high - low >> 1);\n        const cmp = haystack[mid][COLUMN] - needle;\n        if (cmp === 0) {\n            found = true;\n            return mid;\n        }\n        if (cmp < 0) low = mid + 1;\n        else high = mid - 1;\n    }\n    found = false;\n    return low - 1;\n}\nfunction upperBound(haystack, needle, index) {\n    for(let i = index + 1; i < haystack.length; index = i++){\n        if (haystack[i][COLUMN] !== needle) break;\n    }\n    return index;\n}\nfunction lowerBound(haystack, needle, index) {\n    for(let i = index - 1; i >= 0; index = i--){\n        if (haystack[i][COLUMN] !== needle) break;\n    }\n    return index;\n}\nfunction memoizedState() {\n    return {\n        lastKey: -1,\n        lastNeedle: -1,\n        lastIndex: -1\n    };\n}\n/**\n * This overly complicated beast is just to record the last tested line/column and the resulting\n * index, allowing us to skip a few tests if mappings are monotonically increasing.\n */ function memoizedBinarySearch(haystack, needle, state, key) {\n    const { lastKey, lastNeedle, lastIndex } = state;\n    let low = 0;\n    let high = haystack.length - 1;\n    if (key === lastKey) {\n        if (needle === lastNeedle) {\n            found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;\n            return lastIndex;\n        }\n        if (needle >= lastNeedle) // lastIndex may be -1 if the previous needle was not found.\n        low = lastIndex === -1 ? 0 : lastIndex;\n        else high = lastIndex;\n    }\n    state.lastKey = key;\n    state.lastNeedle = needle;\n    return state.lastIndex = binarySearch(haystack, needle, low, high);\n}\n// Rebuilds the original source files, with mappings that are ordered by source line/column instead\n// of generated line/column.\nfunction buildBySources(decoded, memos) {\n    const sources = memos.map(buildNullArray);\n    for(let i = 0; i < decoded.length; i++){\n        const line = decoded[i];\n        for(let j = 0; j < line.length; j++){\n            const seg = line[j];\n            if (seg.length === 1) continue;\n            const sourceIndex = seg[SOURCES_INDEX];\n            const sourceLine = seg[SOURCE_LINE];\n            const sourceColumn = seg[SOURCE_COLUMN];\n            const originalSource = sources[sourceIndex];\n            const originalLine = originalSource[sourceLine] || (originalSource[sourceLine] = []);\n            const memo = memos[sourceIndex];\n            // The binary search either found a match, or it found the left-index just before where the\n            // segment should go. Either way, we want to insert after that. And there may be multiple\n            // generated segments associated with an original location, so there may need to move several\n            // indexes before we find where we need to insert.\n            const index = upperBound(originalLine, sourceColumn, memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine));\n            insert(originalLine, memo.lastIndex = index + 1, [\n                sourceColumn,\n                i,\n                seg[COLUMN]\n            ]);\n        }\n    }\n    return sources;\n}\nfunction insert(array, index, value) {\n    for(let i = array.length; i > index; i--)array[i] = array[i - 1];\n    array[index] = value;\n}\n// Null arrays allow us to use ordered index keys without actually allocating contiguous memory like\n// a real array. We use a null-prototype object to avoid prototype pollution and deoptimizations.\n// Numeric properties on objects are magically sorted in ascending order by the engine regardless of\n// the insertion order. So, by setting any numeric keys, even out of order, we'll get ascending\n// order when iterating with for-in.\nfunction buildNullArray() {\n    return {\n        __proto__: null\n    };\n}\nconst AnyMap = function(map, mapUrl) {\n    const parsed = typeof map === \"string\" ? JSON.parse(map) : map;\n    if (!(\"sections\" in parsed)) return new TraceMap(parsed, mapUrl);\n    const mappings = [];\n    const sources = [];\n    const sourcesContent = [];\n    const names = [];\n    recurse(parsed, mapUrl, mappings, sources, sourcesContent, names, 0, 0, Infinity, Infinity);\n    const joined = {\n        version: 3,\n        file: parsed.file,\n        names,\n        sources,\n        sourcesContent,\n        mappings\n    };\n    return presortedDecodedMap(joined);\n};\nfunction recurse(input, mapUrl, mappings, sources, sourcesContent, names, lineOffset, columnOffset, stopLine, stopColumn) {\n    const { sections } = input;\n    for(let i = 0; i < sections.length; i++){\n        const { map, offset } = sections[i];\n        let sl = stopLine;\n        let sc = stopColumn;\n        if (i + 1 < sections.length) {\n            const nextOffset = sections[i + 1].offset;\n            sl = Math.min(stopLine, lineOffset + nextOffset.line);\n            if (sl === stopLine) sc = Math.min(stopColumn, columnOffset + nextOffset.column);\n            else if (sl < stopLine) sc = columnOffset + nextOffset.column;\n        }\n        addSection(map, mapUrl, mappings, sources, sourcesContent, names, lineOffset + offset.line, columnOffset + offset.column, sl, sc);\n    }\n}\nfunction addSection(input, mapUrl, mappings, sources, sourcesContent, names, lineOffset, columnOffset, stopLine, stopColumn) {\n    if (\"sections\" in input) return recurse(...arguments);\n    const map = new TraceMap(input, mapUrl);\n    const sourcesOffset = sources.length;\n    const namesOffset = names.length;\n    const decoded = decodedMappings(map);\n    const { resolvedSources, sourcesContent: contents } = map;\n    append(sources, resolvedSources);\n    append(names, map.names);\n    if (contents) append(sourcesContent, contents);\n    else for(let i = 0; i < resolvedSources.length; i++)sourcesContent.push(null);\n    for(let i = 0; i < decoded.length; i++){\n        const lineI = lineOffset + i;\n        // We can only add so many lines before we step into the range that the next section's map\n        // controls. When we get to the last line, then we'll start checking the segments to see if\n        // they've crossed into the column range. But it may not have any columns that overstep, so we\n        // still need to check that we don't overstep lines, too.\n        if (lineI > stopLine) return;\n        // The out line may already exist in mappings (if we're continuing the line started by a\n        // previous section). Or, we may have jumped ahead several lines to start this section.\n        const out = getLine(mappings, lineI);\n        // On the 0th loop, the section's column offset shifts us forward. On all other lines (since the\n        // map can be multiple lines), it doesn't.\n        const cOffset = i === 0 ? columnOffset : 0;\n        const line = decoded[i];\n        for(let j = 0; j < line.length; j++){\n            const seg = line[j];\n            const column = cOffset + seg[COLUMN];\n            // If this segment steps into the column range that the next section's map controls, we need\n            // to stop early.\n            if (lineI === stopLine && column >= stopColumn) return;\n            if (seg.length === 1) {\n                out.push([\n                    column\n                ]);\n                continue;\n            }\n            const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];\n            const sourceLine = seg[SOURCE_LINE];\n            const sourceColumn = seg[SOURCE_COLUMN];\n            out.push(seg.length === 4 ? [\n                column,\n                sourcesIndex,\n                sourceLine,\n                sourceColumn\n            ] : [\n                column,\n                sourcesIndex,\n                sourceLine,\n                sourceColumn,\n                namesOffset + seg[NAMES_INDEX]\n            ]);\n        }\n    }\n}\nfunction append(arr, other) {\n    for(let i = 0; i < other.length; i++)arr.push(other[i]);\n}\nfunction getLine(arr, index) {\n    for(let i = arr.length; i <= index; i++)arr[i] = [];\n    return arr[index];\n}\nconst LINE_GTR_ZERO = \"`line` must be greater than 0 (lines start at line 1)\";\nconst COL_GTR_EQ_ZERO = \"`column` must be greater than or equal to 0 (columns start at column 0)\";\nconst LEAST_UPPER_BOUND = -1;\nconst GREATEST_LOWER_BOUND = 1;\n/**\n * Returns the encoded (VLQ string) form of the SourceMap's mappings field.\n */ let encodedMappings;\n/**\n * Returns the decoded (array of lines of segments) form of the SourceMap's mappings field.\n */ let decodedMappings;\n/**\n * A low-level API to find the segment associated with a generated line/column (think, from a\n * stack trace). Line and column here are 0-based, unlike `originalPositionFor`.\n */ let traceSegment;\n/**\n * A higher-level API to find the source/line/column associated with a generated line/column\n * (think, from a stack trace). Line is 1-based, but column is 0-based, due to legacy behavior in\n * `source-map` library.\n */ let originalPositionFor;\n/**\n * Finds the generated line/column position of the provided source/line/column source position.\n */ let generatedPositionFor;\n/**\n * Finds all generated line/column positions of the provided source/line/column source position.\n */ let allGeneratedPositionsFor;\n/**\n * Iterates each mapping in generated position order.\n */ let eachMapping;\n/**\n * Retrieves the source content for a particular source, if its found. Returns null if not.\n */ let sourceContentFor;\n/**\n * A helper that skips sorting of the input map's mappings array, which can be expensive for larger\n * maps.\n */ let presortedDecodedMap;\n/**\n * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */ let decodedMap;\n/**\n * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */ let encodedMap;\nclass TraceMap {\n    constructor(map, mapUrl){\n        const isString = typeof map === \"string\";\n        if (!isString && map._decodedMemo) return map;\n        const parsed = isString ? JSON.parse(map) : map;\n        const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;\n        this.version = version;\n        this.file = file;\n        this.names = names || [];\n        this.sourceRoot = sourceRoot;\n        this.sources = sources;\n        this.sourcesContent = sourcesContent;\n        const from = resolve(sourceRoot || \"\", stripFilename(mapUrl));\n        this.resolvedSources = sources.map((s)=>resolve(s || \"\", from));\n        const { mappings } = parsed;\n        if (typeof mappings === \"string\") {\n            this._encoded = mappings;\n            this._decoded = undefined;\n        } else {\n            this._encoded = undefined;\n            this._decoded = maybeSort(mappings, isString);\n        }\n        this._decodedMemo = memoizedState();\n        this._bySources = undefined;\n        this._bySourceMemos = undefined;\n    }\n}\n(()=>{\n    encodedMappings = (map)=>{\n        var _a;\n        return (_a = map._encoded) !== null && _a !== void 0 ? _a : map._encoded = (0, _sourcemapCodec.encode)(map._decoded);\n    };\n    decodedMappings = (map)=>{\n        return map._decoded || (map._decoded = (0, _sourcemapCodec.decode)(map._encoded));\n    };\n    traceSegment = (map, line, column)=>{\n        const decoded = decodedMappings(map);\n        // It's common for parent source maps to have pointers to lines that have no\n        // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n        if (line >= decoded.length) return null;\n        const segments = decoded[line];\n        const index = traceSegmentInternal(segments, map._decodedMemo, line, column, GREATEST_LOWER_BOUND);\n        return index === -1 ? null : segments[index];\n    };\n    originalPositionFor = (map, { line, column, bias })=>{\n        line--;\n        if (line < 0) throw new Error(LINE_GTR_ZERO);\n        if (column < 0) throw new Error(COL_GTR_EQ_ZERO);\n        const decoded = decodedMappings(map);\n        // It's common for parent source maps to have pointers to lines that have no\n        // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n        if (line >= decoded.length) return OMapping(null, null, null, null);\n        const segments = decoded[line];\n        const index = traceSegmentInternal(segments, map._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);\n        if (index === -1) return OMapping(null, null, null, null);\n        const segment = segments[index];\n        if (segment.length === 1) return OMapping(null, null, null, null);\n        const { names, resolvedSources } = map;\n        return OMapping(resolvedSources[segment[SOURCES_INDEX]], segment[SOURCE_LINE] + 1, segment[SOURCE_COLUMN], segment.length === 5 ? names[segment[NAMES_INDEX]] : null);\n    };\n    allGeneratedPositionsFor = (map, { source, line, column, bias })=>{\n        // SourceMapConsumer uses LEAST_UPPER_BOUND for some reason, so we follow suit.\n        return generatedPosition(map, source, line, column, bias || LEAST_UPPER_BOUND, true);\n    };\n    generatedPositionFor = (map, { source, line, column, bias })=>{\n        return generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, false);\n    };\n    eachMapping = (map, cb)=>{\n        const decoded = decodedMappings(map);\n        const { names, resolvedSources } = map;\n        for(let i = 0; i < decoded.length; i++){\n            const line = decoded[i];\n            for(let j = 0; j < line.length; j++){\n                const seg = line[j];\n                const generatedLine = i + 1;\n                const generatedColumn = seg[0];\n                let source = null;\n                let originalLine = null;\n                let originalColumn = null;\n                let name = null;\n                if (seg.length !== 1) {\n                    source = resolvedSources[seg[1]];\n                    originalLine = seg[2] + 1;\n                    originalColumn = seg[3];\n                }\n                if (seg.length === 5) name = names[seg[4]];\n                cb({\n                    generatedLine,\n                    generatedColumn,\n                    source,\n                    originalLine,\n                    originalColumn,\n                    name\n                });\n            }\n        }\n    };\n    sourceContentFor = (map, source)=>{\n        const { sources, resolvedSources, sourcesContent } = map;\n        if (sourcesContent == null) return null;\n        let index = sources.indexOf(source);\n        if (index === -1) index = resolvedSources.indexOf(source);\n        return index === -1 ? null : sourcesContent[index];\n    };\n    presortedDecodedMap = (map, mapUrl)=>{\n        const tracer = new TraceMap(clone(map, []), mapUrl);\n        tracer._decoded = map.mappings;\n        return tracer;\n    };\n    decodedMap = (map)=>{\n        return clone(map, decodedMappings(map));\n    };\n    encodedMap = (map)=>{\n        return clone(map, encodedMappings(map));\n    };\n    function generatedPosition(map, source, line, column, bias, all) {\n        line--;\n        if (line < 0) throw new Error(LINE_GTR_ZERO);\n        if (column < 0) throw new Error(COL_GTR_EQ_ZERO);\n        const { sources, resolvedSources } = map;\n        let sourceIndex = sources.indexOf(source);\n        if (sourceIndex === -1) sourceIndex = resolvedSources.indexOf(source);\n        if (sourceIndex === -1) return all ? [] : GMapping(null, null);\n        const generated = map._bySources || (map._bySources = buildBySources(decodedMappings(map), map._bySourceMemos = sources.map(memoizedState)));\n        const segments = generated[sourceIndex][line];\n        if (segments == null) return all ? [] : GMapping(null, null);\n        const memo = map._bySourceMemos[sourceIndex];\n        if (all) return sliceGeneratedPositions(segments, memo, line, column, bias);\n        const index = traceSegmentInternal(segments, memo, line, column, bias);\n        if (index === -1) return GMapping(null, null);\n        const segment = segments[index];\n        return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);\n    }\n})();\nfunction clone(map, mappings) {\n    return {\n        version: map.version,\n        file: map.file,\n        names: map.names,\n        sourceRoot: map.sourceRoot,\n        sources: map.sources,\n        sourcesContent: map.sourcesContent,\n        mappings\n    };\n}\nfunction OMapping(source, line, column, name) {\n    return {\n        source,\n        line,\n        column,\n        name\n    };\n}\nfunction GMapping(line, column) {\n    return {\n        line,\n        column\n    };\n}\nfunction traceSegmentInternal(segments, memo, line, column, bias) {\n    let index = memoizedBinarySearch(segments, column, memo, line);\n    if (found) index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);\n    else if (bias === LEAST_UPPER_BOUND) index++;\n    if (index === -1 || index === segments.length) return -1;\n    return index;\n}\nfunction sliceGeneratedPositions(segments, memo, line, column, bias) {\n    let min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);\n    // We ignored the bias when tracing the segment so that we're guarnateed to find the first (in\n    // insertion order) segment that matched. Even if we did respect the bias when tracing, we would\n    // still need to call `lowerBound()` to find the first segment, which is slower than just looking\n    // for the GREATEST_LOWER_BOUND to begin with. The only difference that matters for us is when the\n    // binary search didn't match, in which case GREATEST_LOWER_BOUND just needs to increment to\n    // match LEAST_UPPER_BOUND.\n    if (!found && bias === LEAST_UPPER_BOUND) min++;\n    if (min === -1 || min === segments.length) return [];\n    // We may have found the segment that started at an earlier column. If this is the case, then we\n    // need to slice all generated segments that match _that_ column, because all such segments span\n    // to our desired column.\n    const matchedColumn = found ? column : segments[min][COLUMN];\n    // The binary search is not guaranteed to find the lower bound when a match wasn't found.\n    if (!found) min = lowerBound(segments, matchedColumn, min);\n    const max = upperBound(segments, matchedColumn, min);\n    const result = [];\n    for(; min <= max; min++){\n        const segment = segments[min];\n        result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));\n    }\n    return result;\n}\n\n},{\"@jridgewell/sourcemap-codec\":\"5WRup\",\"@jridgewell/resolve-uri\":\"hr7dK\",\"@parcel/transformer-js/src/esmodule-helpers.js\":\"arbnz\"}],\"hr7dK\":[function(require,module,exports) {\n// Matches the scheme of a URL, eg \"http://\"\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"default\", ()=>resolve);\nconst schemeRegex = /^[\\w+.-]+:\\/\\//;\n/**\n * Matches the parts of a URL:\n * 1. Scheme, including \":\", guaranteed.\n * 2. User/password, including \"@\", optional.\n * 3. Host, guaranteed.\n * 4. Port, including \":\", optional.\n * 5. Path, including \"/\", optional.\n * 6. Query, including \"?\", optional.\n * 7. Hash, including \"#\", optional.\n */ const urlRegex = /^([\\w+.-]+:)\\/\\/([^@/#?]*@)?([^:/#?]*)(:\\d+)?(\\/[^#?]*)?(\\?[^#]*)?(#.*)?/;\n/**\n * File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start\n * with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).\n *\n * 1. Host, optional.\n * 2. Path, which may include \"/\", guaranteed.\n * 3. Query, including \"?\", optional.\n * 4. Hash, including \"#\", optional.\n */ const fileRegex = /^file:(?:\\/\\/((?![a-z]:)[^/#?]*)?)?(\\/?[^#?]*)(\\?[^#]*)?(#.*)?/i;\nvar UrlType;\n(function(UrlType) {\n    UrlType[UrlType[\"Empty\"] = 1] = \"Empty\";\n    UrlType[UrlType[\"Hash\"] = 2] = \"Hash\";\n    UrlType[UrlType[\"Query\"] = 3] = \"Query\";\n    UrlType[UrlType[\"RelativePath\"] = 4] = \"RelativePath\";\n    UrlType[UrlType[\"AbsolutePath\"] = 5] = \"AbsolutePath\";\n    UrlType[UrlType[\"SchemeRelative\"] = 6] = \"SchemeRelative\";\n    UrlType[UrlType[\"Absolute\"] = 7] = \"Absolute\";\n})(UrlType || (UrlType = {}));\nfunction isAbsoluteUrl(input) {\n    return schemeRegex.test(input);\n}\nfunction isSchemeRelativeUrl(input) {\n    return input.startsWith(\"//\");\n}\nfunction isAbsolutePath(input) {\n    return input.startsWith(\"/\");\n}\nfunction isFileUrl(input) {\n    return input.startsWith(\"file:\");\n}\nfunction isRelative(input) {\n    return /^[.?#]/.test(input);\n}\nfunction parseAbsoluteUrl(input) {\n    const match = urlRegex.exec(input);\n    return makeUrl(match[1], match[2] || \"\", match[3], match[4] || \"\", match[5] || \"/\", match[6] || \"\", match[7] || \"\");\n}\nfunction parseFileUrl(input) {\n    const match = fileRegex.exec(input);\n    const path = match[2];\n    return makeUrl(\"file:\", \"\", match[1] || \"\", \"\", isAbsolutePath(path) ? path : \"/\" + path, match[3] || \"\", match[4] || \"\");\n}\nfunction makeUrl(scheme, user, host, port, path, query, hash) {\n    return {\n        scheme,\n        user,\n        host,\n        port,\n        path,\n        query,\n        hash,\n        type: UrlType.Absolute\n    };\n}\nfunction parseUrl(input) {\n    if (isSchemeRelativeUrl(input)) {\n        const url = parseAbsoluteUrl(\"http:\" + input);\n        url.scheme = \"\";\n        url.type = UrlType.SchemeRelative;\n        return url;\n    }\n    if (isAbsolutePath(input)) {\n        const url = parseAbsoluteUrl(\"http://foo.com\" + input);\n        url.scheme = \"\";\n        url.host = \"\";\n        url.type = UrlType.AbsolutePath;\n        return url;\n    }\n    if (isFileUrl(input)) return parseFileUrl(input);\n    if (isAbsoluteUrl(input)) return parseAbsoluteUrl(input);\n    const url = parseAbsoluteUrl(\"http://foo.com/\" + input);\n    url.scheme = \"\";\n    url.host = \"\";\n    url.type = input ? input.startsWith(\"?\") ? UrlType.Query : input.startsWith(\"#\") ? UrlType.Hash : UrlType.RelativePath : UrlType.Empty;\n    return url;\n}\nfunction stripPathFilename(path) {\n    // If a path ends with a parent directory \"..\", then it's a relative path with excess parent\n    // paths. It's not a file, so we can't strip it.\n    if (path.endsWith(\"/..\")) return path;\n    const index = path.lastIndexOf(\"/\");\n    return path.slice(0, index + 1);\n}\nfunction mergePaths(url, base) {\n    normalizePath(base, base.type);\n    // If the path is just a \"/\", then it was an empty path to begin with (remember, we're a relative\n    // path).\n    if (url.path === \"/\") url.path = base.path;\n    else // Resolution happens relative to the base path's directory, not the file.\n    url.path = stripPathFilename(base.path) + url.path;\n}\n/**\n * The path can have empty directories \"//\", unneeded parents \"foo/..\", or current directory\n * \"foo/.\". We need to normalize to a standard representation.\n */ function normalizePath(url, type) {\n    const rel = type <= UrlType.RelativePath;\n    const pieces = url.path.split(\"/\");\n    // We need to preserve the first piece always, so that we output a leading slash. The item at\n    // pieces[0] is an empty string.\n    let pointer = 1;\n    // Positive is the number of real directories we've output, used for popping a parent directory.\n    // Eg, \"foo/bar/..\" will have a positive 2, and we can decrement to be left with just \"foo\".\n    let positive = 0;\n    // We need to keep a trailing slash if we encounter an empty directory (eg, splitting \"foo/\" will\n    // generate `[\"foo\", \"\"]` pieces). And, if we pop a parent directory. But once we encounter a\n    // real directory, we won't need to append, unless the other conditions happen again.\n    let addTrailingSlash = false;\n    for(let i = 1; i < pieces.length; i++){\n        const piece = pieces[i];\n        // An empty directory, could be a trailing slash, or just a double \"//\" in the path.\n        if (!piece) {\n            addTrailingSlash = true;\n            continue;\n        }\n        // If we encounter a real directory, then we don't need to append anymore.\n        addTrailingSlash = false;\n        // A current directory, which we can always drop.\n        if (piece === \".\") continue;\n        // A parent directory, we need to see if there are any real directories we can pop. Else, we\n        // have an excess of parents, and we'll need to keep the \"..\".\n        if (piece === \"..\") {\n            if (positive) {\n                addTrailingSlash = true;\n                positive--;\n                pointer--;\n            } else if (rel) // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute\n            // URL, protocol relative URL, or an absolute path, we don't need to keep excess.\n            pieces[pointer++] = piece;\n            continue;\n        }\n        // We've encountered a real directory. Move it to the next insertion pointer, which accounts for\n        // any popped or dropped directories.\n        pieces[pointer++] = piece;\n        positive++;\n    }\n    let path = \"\";\n    for(let i = 1; i < pointer; i++)path += \"/\" + pieces[i];\n    if (!path || addTrailingSlash && !path.endsWith(\"/..\")) path += \"/\";\n    url.path = path;\n}\n/**\n * Attempts to resolve `input` URL/path relative to `base`.\n */ function resolve(input, base) {\n    if (!input && !base) return \"\";\n    const url = parseUrl(input);\n    let inputType = url.type;\n    if (base && inputType !== UrlType.Absolute) {\n        const baseUrl = parseUrl(base);\n        const baseType = baseUrl.type;\n        switch(inputType){\n            case UrlType.Empty:\n                url.hash = baseUrl.hash;\n            // fall through\n            case UrlType.Hash:\n                url.query = baseUrl.query;\n            // fall through\n            case UrlType.Query:\n            case UrlType.RelativePath:\n                mergePaths(url, baseUrl);\n            // fall through\n            case UrlType.AbsolutePath:\n                // The host, user, and port are joined, you can't copy one without the others.\n                url.user = baseUrl.user;\n                url.host = baseUrl.host;\n                url.port = baseUrl.port;\n            // fall through\n            case UrlType.SchemeRelative:\n                // The input doesn't have a schema at least, so we need to copy at least that over.\n                url.scheme = baseUrl.scheme;\n        }\n        if (baseType > inputType) inputType = baseType;\n    }\n    normalizePath(url, inputType);\n    const queryHash = url.query + url.hash;\n    switch(inputType){\n        // This is impossible, because of the empty checks at the start of the function.\n        // case UrlType.Empty:\n        case UrlType.Hash:\n        case UrlType.Query:\n            return queryHash;\n        case UrlType.RelativePath:\n            {\n                // The first char is always a \"/\", and we need it to be relative.\n                const path = url.path.slice(1);\n                if (!path) return queryHash || \".\";\n                if (isRelative(base || input) && !isRelative(path)) // If base started with a leading \".\", or there is no base and input started with a \".\",\n                // then we need to ensure that the relative path starts with a \".\". We don't know if\n                // relative starts with a \"..\", though, so check before prepending.\n                return \"./\" + path + queryHash;\n                return path + queryHash;\n            }\n        case UrlType.AbsolutePath:\n            return url.path + queryHash;\n        default:\n            return url.scheme + \"//\" + url.user + url.host + url.port + url.path + queryHash;\n    }\n}\n\n},{\"@parcel/transformer-js/src/esmodule-helpers.js\":\"arbnz\"}],\"coQM7\":[function(require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = void 0;\nvar _buffer = require(\"337634c7552486ed\");\nvar n = require(\"9288ed051d3803b6\");\nvar _t = require(\"75c72ac449569c8d\");\nvar generatorFunctions = require(\"c773429d19542250\");\nconst { isFunction, isStatement, isClassBody, isTSInterfaceBody, isTSEnumDeclaration } = _t;\nconst SCIENTIFIC_NOTATION = /e/i;\nconst ZERO_DECIMAL_INTEGER = /\\.0+$/;\nconst NON_DECIMAL_LITERAL = /^0[box]/;\nconst PURE_ANNOTATION_RE = /^\\s*[@#]__PURE__\\s*$/;\nconst HAS_NEWLINE = /[\\n\\r\\u2028\\u2029]/;\nconst HAS_BlOCK_COMMENT_END = /\\*\\//;\nconst { needsParens } = n;\nclass Printer {\n    constructor(format, map){\n        this.inForStatementInitCounter = 0;\n        this._printStack = [];\n        this._indent = 0;\n        this._indentChar = 0;\n        this._indentRepeat = 0;\n        this._insideAux = false;\n        this._parenPushNewlineState = null;\n        this._noLineTerminator = false;\n        this._printAuxAfterOnNextUserNode = false;\n        this._printedComments = new Set();\n        this._endsWithInteger = false;\n        this._endsWithWord = false;\n        this._lastCommentLine = 0;\n        this._endsWithInnerRaw = false;\n        this._indentInnerComments = true;\n        this.format = format;\n        this._buf = new _buffer.default(map);\n        this._indentChar = format.indent.style.charCodeAt(0);\n        this._indentRepeat = format.indent.style.length;\n        this._inputMap = map == null ? void 0 : map._inputMap;\n    }\n    generate(ast) {\n        this.print(ast);\n        this._maybeAddAuxComment();\n        return this._buf.get();\n    }\n    indent() {\n        if (this.format.compact || this.format.concise) return;\n        this._indent++;\n    }\n    dedent() {\n        if (this.format.compact || this.format.concise) return;\n        this._indent--;\n    }\n    semicolon(force = false) {\n        this._maybeAddAuxComment();\n        if (force) this._appendChar(59);\n        else this._queue(59);\n        this._noLineTerminator = false;\n    }\n    rightBrace(node) {\n        if (this.format.minified) this._buf.removeLastSemicolon();\n        this.sourceWithOffset(\"end\", node.loc, -1);\n        this.tokenChar(125);\n    }\n    rightParens(node) {\n        this.sourceWithOffset(\"end\", node.loc, -1);\n        this.tokenChar(41);\n    }\n    space(force = false) {\n        if (this.format.compact) return;\n        if (force) this._space();\n        else if (this._buf.hasContent()) {\n            const lastCp = this.getLastChar();\n            if (lastCp !== 32 && lastCp !== 10) this._space();\n        }\n    }\n    word(str, noLineTerminatorAfter = false) {\n        this._maybePrintInnerComments();\n        if (this._endsWithWord || str.charCodeAt(0) === 47 && this.endsWith(47)) this._space();\n        this._maybeAddAuxComment();\n        this._append(str, false);\n        this._endsWithWord = true;\n        this._noLineTerminator = noLineTerminatorAfter;\n    }\n    number(str) {\n        this.word(str);\n        this._endsWithInteger = Number.isInteger(+str) && !NON_DECIMAL_LITERAL.test(str) && !SCIENTIFIC_NOTATION.test(str) && !ZERO_DECIMAL_INTEGER.test(str) && str.charCodeAt(str.length - 1) !== 46;\n    }\n    token(str, maybeNewline = false) {\n        this._maybePrintInnerComments();\n        const lastChar = this.getLastChar();\n        const strFirst = str.charCodeAt(0);\n        if (lastChar === 33 && (str === \"--\" || strFirst === 61) || strFirst === 43 && lastChar === 43 || strFirst === 45 && lastChar === 45 || strFirst === 46 && this._endsWithInteger) this._space();\n        this._maybeAddAuxComment();\n        this._append(str, maybeNewline);\n        this._noLineTerminator = false;\n    }\n    tokenChar(char) {\n        this._maybePrintInnerComments();\n        const lastChar = this.getLastChar();\n        if (char === 43 && lastChar === 43 || char === 45 && lastChar === 45 || char === 46 && this._endsWithInteger) this._space();\n        this._maybeAddAuxComment();\n        this._appendChar(char);\n        this._noLineTerminator = false;\n    }\n    newline(i = 1, force) {\n        if (i <= 0) return;\n        if (!force) {\n            if (this.format.retainLines || this.format.compact) return;\n            if (this.format.concise) {\n                this.space();\n                return;\n            }\n        }\n        if (i > 2) i = 2;\n        i -= this._buf.getNewlineCount();\n        for(let j = 0; j < i; j++)this._newline();\n        return;\n    }\n    endsWith(char) {\n        return this.getLastChar() === char;\n    }\n    getLastChar() {\n        return this._buf.getLastChar();\n    }\n    endsWithCharAndNewline() {\n        return this._buf.endsWithCharAndNewline();\n    }\n    removeTrailingNewline() {\n        this._buf.removeTrailingNewline();\n    }\n    exactSource(loc, cb) {\n        if (!loc) {\n            cb();\n            return;\n        }\n        this._catchUp(\"start\", loc);\n        this._buf.exactSource(loc, cb);\n    }\n    source(prop, loc) {\n        if (!loc) return;\n        this._catchUp(prop, loc);\n        this._buf.source(prop, loc);\n    }\n    sourceWithOffset(prop, loc, columnOffset) {\n        if (!loc) return;\n        this._catchUp(prop, loc);\n        this._buf.sourceWithOffset(prop, loc, columnOffset);\n    }\n    withSource(prop, loc, cb) {\n        if (!loc) {\n            cb();\n            return;\n        }\n        this._catchUp(prop, loc);\n        this._buf.withSource(prop, loc, cb);\n    }\n    sourceIdentifierName(identifierName, pos) {\n        if (!this._buf._canMarkIdName) return;\n        const sourcePosition = this._buf._sourcePosition;\n        sourcePosition.identifierNamePos = pos;\n        sourcePosition.identifierName = identifierName;\n    }\n    _space() {\n        this._queue(32);\n    }\n    _newline() {\n        this._queue(10);\n    }\n    _append(str, maybeNewline) {\n        this._maybeAddParen(str);\n        this._maybeIndent(str.charCodeAt(0));\n        this._buf.append(str, maybeNewline);\n        this._endsWithWord = false;\n        this._endsWithInteger = false;\n    }\n    _appendChar(char) {\n        this._maybeAddParenChar(char);\n        this._maybeIndent(char);\n        this._buf.appendChar(char);\n        this._endsWithWord = false;\n        this._endsWithInteger = false;\n    }\n    _queue(char) {\n        this._maybeAddParenChar(char);\n        this._maybeIndent(char);\n        this._buf.queue(char);\n        this._endsWithWord = false;\n        this._endsWithInteger = false;\n    }\n    _maybeIndent(firstChar) {\n        if (this._indent && firstChar !== 10 && this.endsWith(10)) this._buf.queueIndentation(this._indentChar, this._getIndent());\n    }\n    _shouldIndent(firstChar) {\n        if (this._indent && firstChar !== 10 && this.endsWith(10)) return true;\n    }\n    _maybeAddParenChar(char) {\n        const parenPushNewlineState = this._parenPushNewlineState;\n        if (!parenPushNewlineState) return;\n        if (char === 32) return;\n        if (char !== 10) {\n            this._parenPushNewlineState = null;\n            return;\n        }\n        this.tokenChar(40);\n        this.indent();\n        parenPushNewlineState.printed = true;\n    }\n    _maybeAddParen(str) {\n        const parenPushNewlineState = this._parenPushNewlineState;\n        if (!parenPushNewlineState) return;\n        const len = str.length;\n        let i;\n        for(i = 0; i < len && str.charCodeAt(i) === 32; i++)continue;\n        if (i === len) return;\n        const cha = str.charCodeAt(i);\n        if (cha !== 10) {\n            if (cha !== 47 || i + 1 === len) {\n                this._parenPushNewlineState = null;\n                return;\n            }\n            const chaPost = str.charCodeAt(i + 1);\n            if (chaPost === 42) {\n                if (PURE_ANNOTATION_RE.test(str.slice(i + 2, len - 2))) return;\n            } else if (chaPost !== 47) {\n                this._parenPushNewlineState = null;\n                return;\n            }\n        }\n        this.tokenChar(40);\n        this.indent();\n        parenPushNewlineState.printed = true;\n    }\n    catchUp(line) {\n        if (!this.format.retainLines) return;\n        const count = line - this._buf.getCurrentLine();\n        for(let i = 0; i < count; i++)this._newline();\n    }\n    _catchUp(prop, loc) {\n        var _loc$prop;\n        if (!this.format.retainLines) return;\n        const line = loc == null || (_loc$prop = loc[prop]) == null ? void 0 : _loc$prop.line;\n        if (line != null) {\n            const count = line - this._buf.getCurrentLine();\n            for(let i = 0; i < count; i++)this._newline();\n        }\n    }\n    _getIndent() {\n        return this._indentRepeat * this._indent;\n    }\n    printTerminatorless(node, parent, isLabel) {\n        if (isLabel) {\n            this._noLineTerminator = true;\n            this.print(node, parent);\n        } else {\n            const terminatorState = {\n                printed: false\n            };\n            this._parenPushNewlineState = terminatorState;\n            this.print(node, parent);\n            if (terminatorState.printed) {\n                this.dedent();\n                this.newline();\n                this.tokenChar(41);\n            }\n        }\n    }\n    print(node, parent, noLineTerminatorAfter, trailingCommentsLineOffset, forceParens) {\n        var _node$extra;\n        if (!node) return;\n        this._endsWithInnerRaw = false;\n        const nodeType = node.type;\n        const format = this.format;\n        const oldConcise = format.concise;\n        if (node._compact) format.concise = true;\n        const printMethod = this[nodeType];\n        if (printMethod === undefined) throw new ReferenceError(`unknown node of type ${JSON.stringify(nodeType)} with constructor ${JSON.stringify(node.constructor.name)}`);\n        this._printStack.push(node);\n        const oldInAux = this._insideAux;\n        this._insideAux = node.loc == undefined;\n        this._maybeAddAuxComment(this._insideAux && !oldInAux);\n        const shouldPrintParens = forceParens || format.retainFunctionParens && nodeType === \"FunctionExpression\" && ((_node$extra = node.extra) == null ? void 0 : _node$extra.parenthesized) || needsParens(node, parent, this._printStack);\n        if (shouldPrintParens) {\n            this.tokenChar(40);\n            this._endsWithInnerRaw = false;\n        }\n        this._lastCommentLine = 0;\n        this._printLeadingComments(node, parent);\n        const loc = nodeType === \"Program\" || nodeType === \"File\" ? null : node.loc;\n        this.exactSource(loc, printMethod.bind(this, node, parent));\n        if (shouldPrintParens) {\n            this._printTrailingComments(node, parent);\n            this.tokenChar(41);\n            this._noLineTerminator = noLineTerminatorAfter;\n        } else if (noLineTerminatorAfter && !this._noLineTerminator) {\n            this._noLineTerminator = true;\n            this._printTrailingComments(node, parent);\n        } else this._printTrailingComments(node, parent, trailingCommentsLineOffset);\n        this._printStack.pop();\n        format.concise = oldConcise;\n        this._insideAux = oldInAux;\n        this._endsWithInnerRaw = false;\n    }\n    _maybeAddAuxComment(enteredPositionlessNode) {\n        if (enteredPositionlessNode) this._printAuxBeforeComment();\n        if (!this._insideAux) this._printAuxAfterComment();\n    }\n    _printAuxBeforeComment() {\n        if (this._printAuxAfterOnNextUserNode) return;\n        this._printAuxAfterOnNextUserNode = true;\n        const comment = this.format.auxiliaryCommentBefore;\n        if (comment) this._printComment({\n            type: \"CommentBlock\",\n            value: comment\n        }, 0);\n    }\n    _printAuxAfterComment() {\n        if (!this._printAuxAfterOnNextUserNode) return;\n        this._printAuxAfterOnNextUserNode = false;\n        const comment = this.format.auxiliaryCommentAfter;\n        if (comment) this._printComment({\n            type: \"CommentBlock\",\n            value: comment\n        }, 0);\n    }\n    getPossibleRaw(node) {\n        const extra = node.extra;\n        if ((extra == null ? void 0 : extra.raw) != null && extra.rawValue != null && node.value === extra.rawValue) return extra.raw;\n    }\n    printJoin(nodes, parent, opts = {}) {\n        if (!(nodes != null && nodes.length)) return;\n        let { indent } = opts;\n        if (indent == null && this.format.retainLines) {\n            var _nodes$0$loc;\n            const startLine = (_nodes$0$loc = nodes[0].loc) == null ? void 0 : _nodes$0$loc.start.line;\n            if (startLine != null && startLine !== this._buf.getCurrentLine()) indent = true;\n        }\n        if (indent) this.indent();\n        const newlineOpts = {\n            addNewlines: opts.addNewlines,\n            nextNodeStartLine: 0\n        };\n        const separator = opts.separator ? opts.separator.bind(this) : null;\n        const len = nodes.length;\n        for(let i = 0; i < len; i++){\n            const node = nodes[i];\n            if (!node) continue;\n            if (opts.statement) this._printNewline(i === 0, newlineOpts);\n            this.print(node, parent, undefined, opts.trailingCommentsLineOffset || 0);\n            opts.iterator == null || opts.iterator(node, i);\n            if (i < len - 1) separator == null || separator();\n            if (opts.statement) {\n                if (i + 1 === len) this.newline(1);\n                else {\n                    var _nextNode$loc;\n                    const nextNode = nodes[i + 1];\n                    newlineOpts.nextNodeStartLine = ((_nextNode$loc = nextNode.loc) == null ? void 0 : _nextNode$loc.start.line) || 0;\n                    this._printNewline(true, newlineOpts);\n                }\n            }\n        }\n        if (indent) this.dedent();\n    }\n    printAndIndentOnComments(node, parent) {\n        const indent = node.leadingComments && node.leadingComments.length > 0;\n        if (indent) this.indent();\n        this.print(node, parent);\n        if (indent) this.dedent();\n    }\n    printBlock(parent) {\n        const node = parent.body;\n        if (node.type !== \"EmptyStatement\") this.space();\n        this.print(node, parent);\n    }\n    _printTrailingComments(node, parent, lineOffset) {\n        const { innerComments, trailingComments } = node;\n        if (innerComments != null && innerComments.length) this._printComments(2, innerComments, node, parent, lineOffset);\n        if (trailingComments != null && trailingComments.length) this._printComments(2, trailingComments, node, parent, lineOffset);\n    }\n    _printLeadingComments(node, parent) {\n        const comments = node.leadingComments;\n        if (!(comments != null && comments.length)) return;\n        this._printComments(0, comments, node, parent);\n    }\n    _maybePrintInnerComments() {\n        if (this._endsWithInnerRaw) this.printInnerComments();\n        this._endsWithInnerRaw = true;\n        this._indentInnerComments = true;\n    }\n    printInnerComments() {\n        const node = this._printStack[this._printStack.length - 1];\n        const comments = node.innerComments;\n        if (!(comments != null && comments.length)) return;\n        const hasSpace = this.endsWith(32);\n        const indent = this._indentInnerComments;\n        const printedCommentsCount = this._printedComments.size;\n        if (indent) this.indent();\n        this._printComments(1, comments, node);\n        if (hasSpace && printedCommentsCount !== this._printedComments.size) this.space();\n        if (indent) this.dedent();\n    }\n    noIndentInnerCommentsHere() {\n        this._indentInnerComments = false;\n    }\n    printSequence(nodes, parent, opts = {}) {\n        var _opts$indent;\n        opts.statement = true;\n        (_opts$indent = opts.indent) != null ? _opts$indent : opts.indent = false;\n        this.printJoin(nodes, parent, opts);\n    }\n    printList(items, parent, opts = {}) {\n        if (opts.separator == null) opts.separator = commaSeparator;\n        this.printJoin(items, parent, opts);\n    }\n    _printNewline(newLine, opts) {\n        const format = this.format;\n        if (format.retainLines || format.compact) return;\n        if (format.concise) {\n            this.space();\n            return;\n        }\n        if (!newLine) return;\n        const startLine = opts.nextNodeStartLine;\n        const lastCommentLine = this._lastCommentLine;\n        if (startLine > 0 && lastCommentLine > 0) {\n            const offset = startLine - lastCommentLine;\n            if (offset >= 0) {\n                this.newline(offset || 1);\n                return;\n            }\n        }\n        if (this._buf.hasContent()) this.newline(1);\n    }\n    _shouldPrintComment(comment) {\n        if (comment.ignore) return 0;\n        if (this._printedComments.has(comment)) return 0;\n        if (this._noLineTerminator && (HAS_NEWLINE.test(comment.value) || HAS_BlOCK_COMMENT_END.test(comment.value))) return 2;\n        this._printedComments.add(comment);\n        if (!this.format.shouldPrintComment(comment.value)) return 0;\n        return 1;\n    }\n    _printComment(comment, skipNewLines) {\n        const noLineTerminator = this._noLineTerminator;\n        const isBlockComment = comment.type === \"CommentBlock\";\n        const printNewLines = isBlockComment && skipNewLines !== 1 && !this._noLineTerminator;\n        if (printNewLines && this._buf.hasContent() && skipNewLines !== 2) this.newline(1);\n        const lastCharCode = this.getLastChar();\n        if (lastCharCode !== 91 && lastCharCode !== 123) this.space();\n        let val;\n        if (isBlockComment) {\n            val = `/*${comment.value}*/`;\n            if (this.format.indent.adjustMultilineComment) {\n                var _comment$loc;\n                const offset = (_comment$loc = comment.loc) == null ? void 0 : _comment$loc.start.column;\n                if (offset) {\n                    const newlineRegex = new RegExp(\"\\\\n\\\\s{1,\" + offset + \"}\", \"g\");\n                    val = val.replace(newlineRegex, \"\\n\");\n                }\n                let indentSize = this.format.retainLines ? 0 : this._buf.getCurrentColumn();\n                if (this._shouldIndent(47) || this.format.retainLines) indentSize += this._getIndent();\n                val = val.replace(/\\n(?!$)/g, `\\n${\" \".repeat(indentSize)}`);\n            }\n        } else if (!noLineTerminator) val = `//${comment.value}`;\n        else val = `/*${comment.value}*/`;\n        if (this.endsWith(47)) this._space();\n        this.source(\"start\", comment.loc);\n        this._append(val, isBlockComment);\n        if (!isBlockComment && !noLineTerminator) this.newline(1, true);\n        if (printNewLines && skipNewLines !== 3) this.newline(1);\n    }\n    _printComments(type, comments, node, parent, lineOffset = 0) {\n        const nodeLoc = node.loc;\n        const len = comments.length;\n        let hasLoc = !!nodeLoc;\n        const nodeStartLine = hasLoc ? nodeLoc.start.line : 0;\n        const nodeEndLine = hasLoc ? nodeLoc.end.line : 0;\n        let lastLine = 0;\n        let leadingCommentNewline = 0;\n        const maybeNewline = this._noLineTerminator ? function() {} : this.newline.bind(this);\n        for(let i = 0; i < len; i++){\n            const comment = comments[i];\n            const shouldPrint = this._shouldPrintComment(comment);\n            if (shouldPrint === 2) {\n                hasLoc = false;\n                break;\n            }\n            if (hasLoc && comment.loc && shouldPrint === 1) {\n                const commentStartLine = comment.loc.start.line;\n                const commentEndLine = comment.loc.end.line;\n                if (type === 0) {\n                    let offset = 0;\n                    if (i === 0) {\n                        if (this._buf.hasContent() && (comment.type === \"CommentLine\" || commentStartLine != commentEndLine)) offset = leadingCommentNewline = 1;\n                    } else offset = commentStartLine - lastLine;\n                    lastLine = commentEndLine;\n                    maybeNewline(offset);\n                    this._printComment(comment, 1);\n                    if (i + 1 === len) {\n                        maybeNewline(Math.max(nodeStartLine - lastLine, leadingCommentNewline));\n                        lastLine = nodeStartLine;\n                    }\n                } else if (type === 1) {\n                    const offset = commentStartLine - (i === 0 ? nodeStartLine : lastLine);\n                    lastLine = commentEndLine;\n                    maybeNewline(offset);\n                    this._printComment(comment, 1);\n                    if (i + 1 === len) {\n                        maybeNewline(Math.min(1, nodeEndLine - lastLine));\n                        lastLine = nodeEndLine;\n                    }\n                } else {\n                    const offset = commentStartLine - (i === 0 ? nodeEndLine - lineOffset : lastLine);\n                    lastLine = commentEndLine;\n                    maybeNewline(offset);\n                    this._printComment(comment, 1);\n                }\n            } else {\n                hasLoc = false;\n                if (shouldPrint !== 1) continue;\n                if (len === 1) {\n                    const singleLine = comment.loc ? comment.loc.start.line === comment.loc.end.line : !HAS_NEWLINE.test(comment.value);\n                    const shouldSkipNewline = singleLine && !isStatement(node) && !isClassBody(parent) && !isTSInterfaceBody(parent) && !isTSEnumDeclaration(parent);\n                    if (type === 0) this._printComment(comment, shouldSkipNewline && node.type !== \"ObjectExpression\" || singleLine && isFunction(parent, {\n                        body: node\n                    }) ? 1 : 0);\n                    else if (shouldSkipNewline && type === 2) this._printComment(comment, 1);\n                    else this._printComment(comment, 0);\n                } else if (type === 1 && !(node.type === \"ObjectExpression\" && node.properties.length > 1) && node.type !== \"ClassBody\" && node.type !== \"TSInterfaceBody\") this._printComment(comment, i === 0 ? 2 : i === len - 1 ? 3 : 0);\n                else this._printComment(comment, 0);\n            }\n        }\n        if (type === 2 && hasLoc && lastLine) this._lastCommentLine = lastLine;\n    }\n}\nObject.assign(Printer.prototype, generatorFunctions);\nPrinter.prototype.Noop = function Noop() {};\nvar _default = Printer;\nexports.default = _default;\nfunction commaSeparator() {\n    this.tokenChar(44);\n    this.space();\n}\n\n},{\"337634c7552486ed\":\"Yukdd\",\"9288ed051d3803b6\":\"dLL5b\",\"75c72ac449569c8d\":\"d4Ce7\",\"c773429d19542250\":\"e93Bw\"}],\"Yukdd\":[function(require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = void 0;\nclass Buffer {\n    constructor(map){\n        this._map = null;\n        this._buf = \"\";\n        this._str = \"\";\n        this._appendCount = 0;\n        this._last = 0;\n        this._queue = [];\n        this._queueCursor = 0;\n        this._canMarkIdName = true;\n        this._position = {\n            line: 1,\n            column: 0\n        };\n        this._sourcePosition = {\n            identifierName: undefined,\n            identifierNamePos: undefined,\n            line: undefined,\n            column: undefined,\n            filename: undefined\n        };\n        this._map = map;\n        this._allocQueue();\n    }\n    _allocQueue() {\n        const queue = this._queue;\n        for(let i = 0; i < 16; i++)queue.push({\n            char: 0,\n            repeat: 1,\n            line: undefined,\n            column: undefined,\n            identifierName: undefined,\n            identifierNamePos: undefined,\n            filename: \"\"\n        });\n    }\n    _pushQueue(char, repeat, line, column, filename) {\n        const cursor = this._queueCursor;\n        if (cursor === this._queue.length) this._allocQueue();\n        const item = this._queue[cursor];\n        item.char = char;\n        item.repeat = repeat;\n        item.line = line;\n        item.column = column;\n        item.filename = filename;\n        this._queueCursor++;\n    }\n    _popQueue() {\n        if (this._queueCursor === 0) throw new Error(\"Cannot pop from empty queue\");\n        return this._queue[--this._queueCursor];\n    }\n    get() {\n        this._flush();\n        const map = this._map;\n        const result = {\n            code: (this._buf + this._str).trimRight(),\n            decodedMap: map == null ? void 0 : map.getDecoded(),\n            get __mergedMap () {\n                return this.map;\n            },\n            get map () {\n                const resultMap = map ? map.get() : null;\n                result.map = resultMap;\n                return resultMap;\n            },\n            set map (value){\n                Object.defineProperty(result, \"map\", {\n                    value,\n                    writable: true\n                });\n            },\n            get rawMappings () {\n                const mappings = map == null ? void 0 : map.getRawMappings();\n                result.rawMappings = mappings;\n                return mappings;\n            },\n            set rawMappings (value){\n                Object.defineProperty(result, \"rawMappings\", {\n                    value,\n                    writable: true\n                });\n            }\n        };\n        return result;\n    }\n    append(str, maybeNewline) {\n        this._flush();\n        this._append(str, this._sourcePosition, maybeNewline);\n    }\n    appendChar(char) {\n        this._flush();\n        this._appendChar(char, 1, this._sourcePosition);\n    }\n    queue(char) {\n        if (char === 10) while(this._queueCursor !== 0){\n            const char = this._queue[this._queueCursor - 1].char;\n            if (char !== 32 && char !== 9) break;\n            this._queueCursor--;\n        }\n        const sourcePosition = this._sourcePosition;\n        this._pushQueue(char, 1, sourcePosition.line, sourcePosition.column, sourcePosition.filename);\n    }\n    queueIndentation(char, repeat) {\n        this._pushQueue(char, repeat, undefined, undefined, undefined);\n    }\n    _flush() {\n        const queueCursor = this._queueCursor;\n        const queue = this._queue;\n        for(let i = 0; i < queueCursor; i++){\n            const item = queue[i];\n            this._appendChar(item.char, item.repeat, item);\n        }\n        this._queueCursor = 0;\n    }\n    _appendChar(char, repeat, sourcePos) {\n        this._last = char;\n        this._str += repeat > 1 ? String.fromCharCode(char).repeat(repeat) : String.fromCharCode(char);\n        if (char !== 10) {\n            this._mark(sourcePos.line, sourcePos.column, sourcePos.identifierName, sourcePos.identifierNamePos, sourcePos.filename);\n            this._position.column += repeat;\n        } else {\n            this._position.line++;\n            this._position.column = 0;\n        }\n        if (this._canMarkIdName) {\n            sourcePos.identifierName = undefined;\n            sourcePos.identifierNamePos = undefined;\n        }\n    }\n    _append(str, sourcePos, maybeNewline) {\n        const len = str.length;\n        const position = this._position;\n        this._last = str.charCodeAt(len - 1);\n        if (++this._appendCount > 4096) {\n            this._str;\n            this._buf += this._str;\n            this._str = str;\n            this._appendCount = 0;\n        } else this._str += str;\n        if (!maybeNewline && !this._map) {\n            position.column += len;\n            return;\n        }\n        const { column, identifierName, identifierNamePos, filename } = sourcePos;\n        let line = sourcePos.line;\n        if ((identifierName != null || identifierNamePos != null) && this._canMarkIdName) {\n            sourcePos.identifierName = undefined;\n            sourcePos.identifierNamePos = undefined;\n        }\n        let i = str.indexOf(\"\\n\");\n        let last = 0;\n        if (i !== 0) this._mark(line, column, identifierName, identifierNamePos, filename);\n        while(i !== -1){\n            position.line++;\n            position.column = 0;\n            last = i + 1;\n            if (last < len && line !== undefined) this._mark(++line, 0, null, null, filename);\n            i = str.indexOf(\"\\n\", last);\n        }\n        position.column += len - last;\n    }\n    _mark(line, column, identifierName, identifierNamePos, filename) {\n        var _this$_map;\n        (_this$_map = this._map) == null || _this$_map.mark(this._position, line, column, identifierName, identifierNamePos, filename);\n    }\n    removeTrailingNewline() {\n        const queueCursor = this._queueCursor;\n        if (queueCursor !== 0 && this._queue[queueCursor - 1].char === 10) this._queueCursor--;\n    }\n    removeLastSemicolon() {\n        const queueCursor = this._queueCursor;\n        if (queueCursor !== 0 && this._queue[queueCursor - 1].char === 59) this._queueCursor--;\n    }\n    getLastChar() {\n        const queueCursor = this._queueCursor;\n        return queueCursor !== 0 ? this._queue[queueCursor - 1].char : this._last;\n    }\n    getNewlineCount() {\n        const queueCursor = this._queueCursor;\n        let count = 0;\n        if (queueCursor === 0) return this._last === 10 ? 1 : 0;\n        for(let i = queueCursor - 1; i >= 0; i--){\n            if (this._queue[i].char !== 10) break;\n            count++;\n        }\n        return count === queueCursor && this._last === 10 ? count + 1 : count;\n    }\n    endsWithCharAndNewline() {\n        const queue = this._queue;\n        const queueCursor = this._queueCursor;\n        if (queueCursor !== 0) {\n            const lastCp = queue[queueCursor - 1].char;\n            if (lastCp !== 10) return;\n            if (queueCursor > 1) return queue[queueCursor - 2].char;\n            else return this._last;\n        }\n    }\n    hasContent() {\n        return this._queueCursor !== 0 || !!this._last;\n    }\n    exactSource(loc, cb) {\n        if (!this._map) {\n            cb();\n            return;\n        }\n        this.source(\"start\", loc);\n        const identifierName = loc.identifierName;\n        const sourcePos = this._sourcePosition;\n        if (identifierName) {\n            this._canMarkIdName = false;\n            sourcePos.identifierName = identifierName;\n        }\n        cb();\n        if (identifierName) {\n            this._canMarkIdName = true;\n            sourcePos.identifierName = undefined;\n            sourcePos.identifierNamePos = undefined;\n        }\n        this.source(\"end\", loc);\n    }\n    source(prop, loc) {\n        if (!this._map) return;\n        this._normalizePosition(prop, loc, 0);\n    }\n    sourceWithOffset(prop, loc, columnOffset) {\n        if (!this._map) return;\n        this._normalizePosition(prop, loc, columnOffset);\n    }\n    withSource(prop, loc, cb) {\n        if (this._map) this.source(prop, loc);\n        cb();\n    }\n    _normalizePosition(prop, loc, columnOffset) {\n        const pos = loc[prop];\n        const target = this._sourcePosition;\n        if (pos) {\n            target.line = pos.line;\n            target.column = Math.max(pos.column + columnOffset, 0);\n            target.filename = loc.filename;\n        }\n    }\n    getCurrentColumn() {\n        const queue = this._queue;\n        const queueCursor = this._queueCursor;\n        let lastIndex = -1;\n        let len = 0;\n        for(let i = 0; i < queueCursor; i++){\n            const item = queue[i];\n            if (item.char === 10) lastIndex = len;\n            len += item.repeat;\n        }\n        return lastIndex === -1 ? this._position.column + len : len - 1 - lastIndex;\n    }\n    getCurrentLine() {\n        let count = 0;\n        const queue = this._queue;\n        for(let i = 0; i < this._queueCursor; i++)if (queue[i].char === 10) count++;\n        return this._position.line + count;\n    }\n}\nexports.default = Buffer;\n\n},{}],\"dLL5b\":[function(require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.needsParens = needsParens;\nexports.needsWhitespace = needsWhitespace;\nexports.needsWhitespaceAfter = needsWhitespaceAfter;\nexports.needsWhitespaceBefore = needsWhitespaceBefore;\nvar whitespace = require(\"a50f8dd1db64f8f6\");\nvar parens = require(\"410d390b5a2cfe06\");\nvar _t = require(\"82639a18113d2e3d\");\nconst { FLIPPED_ALIAS_KEYS, isCallExpression, isExpressionStatement, isMemberExpression, isNewExpression } = _t;\nfunction expandAliases(obj) {\n    const newObj = {};\n    function add(type, func) {\n        const fn = newObj[type];\n        newObj[type] = fn ? function(node, parent, stack) {\n            const result = fn(node, parent, stack);\n            return result == null ? func(node, parent, stack) : result;\n        } : func;\n    }\n    for (const type of Object.keys(obj)){\n        const aliases = FLIPPED_ALIAS_KEYS[type];\n        if (aliases) for (const alias of aliases)add(alias, obj[type]);\n        else add(type, obj[type]);\n    }\n    return newObj;\n}\nconst expandedParens = expandAliases(parens);\nconst expandedWhitespaceNodes = expandAliases(whitespace.nodes);\nfunction find(obj, node, parent, printStack) {\n    const fn = obj[node.type];\n    return fn ? fn(node, parent, printStack) : null;\n}\nfunction isOrHasCallExpression(node) {\n    if (isCallExpression(node)) return true;\n    return isMemberExpression(node) && isOrHasCallExpression(node.object);\n}\nfunction needsWhitespace(node, parent, type) {\n    if (!node) return false;\n    if (isExpressionStatement(node)) node = node.expression;\n    const flag = find(expandedWhitespaceNodes, node, parent);\n    if (typeof flag === \"number\") return (flag & type) !== 0;\n    return false;\n}\nfunction needsWhitespaceBefore(node, parent) {\n    return needsWhitespace(node, parent, 1);\n}\nfunction needsWhitespaceAfter(node, parent) {\n    return needsWhitespace(node, parent, 2);\n}\nfunction needsParens(node, parent, printStack) {\n    if (!parent) return false;\n    if (isNewExpression(parent) && parent.callee === node) {\n        if (isOrHasCallExpression(node)) return true;\n    }\n    return find(expandedParens, node, parent, printStack);\n}\n\n},{\"a50f8dd1db64f8f6\":\"15qnn\",\"410d390b5a2cfe06\":\"1maVo\",\"82639a18113d2e3d\":\"d4Ce7\"}],\"15qnn\":[function(require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.nodes = void 0;\nvar _t = require(\"56c739ff08fbbdce\");\nconst { FLIPPED_ALIAS_KEYS, isArrayExpression, isAssignmentExpression, isBinary, isBlockStatement, isCallExpression, isFunction, isIdentifier, isLiteral, isMemberExpression, isObjectExpression, isOptionalCallExpression, isOptionalMemberExpression, isStringLiteral } = _t;\nfunction crawlInternal(node, state) {\n    if (!node) return state;\n    if (isMemberExpression(node) || isOptionalMemberExpression(node)) {\n        crawlInternal(node.object, state);\n        if (node.computed) crawlInternal(node.property, state);\n    } else if (isBinary(node) || isAssignmentExpression(node)) {\n        crawlInternal(node.left, state);\n        crawlInternal(node.right, state);\n    } else if (isCallExpression(node) || isOptionalCallExpression(node)) {\n        state.hasCall = true;\n        crawlInternal(node.callee, state);\n    } else if (isFunction(node)) state.hasFunction = true;\n    else if (isIdentifier(node)) state.hasHelper = state.hasHelper || node.callee && isHelper(node.callee);\n    return state;\n}\nfunction crawl(node) {\n    return crawlInternal(node, {\n        hasCall: false,\n        hasFunction: false,\n        hasHelper: false\n    });\n}\nfunction isHelper(node) {\n    if (!node) return false;\n    if (isMemberExpression(node)) return isHelper(node.object) || isHelper(node.property);\n    else if (isIdentifier(node)) return node.name === \"require\" || node.name.charCodeAt(0) === 95;\n    else if (isCallExpression(node)) return isHelper(node.callee);\n    else if (isBinary(node) || isAssignmentExpression(node)) return isIdentifier(node.left) && isHelper(node.left) || isHelper(node.right);\n    else return false;\n}\nfunction isType(node) {\n    return isLiteral(node) || isObjectExpression(node) || isArrayExpression(node) || isIdentifier(node) || isMemberExpression(node);\n}\nconst nodes = {\n    AssignmentExpression (node) {\n        const state = crawl(node.right);\n        if (state.hasCall && state.hasHelper || state.hasFunction) return state.hasFunction ? 3 : 2;\n    },\n    SwitchCase (node, parent) {\n        return (!!node.consequent.length || parent.cases[0] === node ? 1 : 0) | (!node.consequent.length && parent.cases[parent.cases.length - 1] === node ? 2 : 0);\n    },\n    LogicalExpression (node) {\n        if (isFunction(node.left) || isFunction(node.right)) return 2;\n    },\n    Literal (node) {\n        if (isStringLiteral(node) && node.value === \"use strict\") return 2;\n    },\n    CallExpression (node) {\n        if (isFunction(node.callee) || isHelper(node)) return 3;\n    },\n    OptionalCallExpression (node) {\n        if (isFunction(node.callee)) return 3;\n    },\n    VariableDeclaration (node) {\n        for(let i = 0; i < node.declarations.length; i++){\n            const declar = node.declarations[i];\n            let enabled = isHelper(declar.id) && !isType(declar.init);\n            if (!enabled && declar.init) {\n                const state = crawl(declar.init);\n                enabled = isHelper(declar.init) && state.hasCall || state.hasFunction;\n            }\n            if (enabled) return 3;\n        }\n    },\n    IfStatement (node) {\n        if (isBlockStatement(node.consequent)) return 3;\n    }\n};\nexports.nodes = nodes;\nnodes.ObjectProperty = nodes.ObjectTypeProperty = nodes.ObjectMethod = function(node, parent) {\n    if (parent.properties[0] === node) return 1;\n};\nnodes.ObjectTypeCallProperty = function(node, parent) {\n    var _parent$properties;\n    if (parent.callProperties[0] === node && !((_parent$properties = parent.properties) != null && _parent$properties.length)) return 1;\n};\nnodes.ObjectTypeIndexer = function(node, parent) {\n    var _parent$properties2, _parent$callPropertie;\n    if (parent.indexers[0] === node && !((_parent$properties2 = parent.properties) != null && _parent$properties2.length) && !((_parent$callPropertie = parent.callProperties) != null && _parent$callPropertie.length)) return 1;\n};\nnodes.ObjectTypeInternalSlot = function(node, parent) {\n    var _parent$properties3, _parent$callPropertie2, _parent$indexers;\n    if (parent.internalSlots[0] === node && !((_parent$properties3 = parent.properties) != null && _parent$properties3.length) && !((_parent$callPropertie2 = parent.callProperties) != null && _parent$callPropertie2.length) && !((_parent$indexers = parent.indexers) != null && _parent$indexers.length)) return 1;\n};\n[\n    [\n        \"Function\",\n        true\n    ],\n    [\n        \"Class\",\n        true\n    ],\n    [\n        \"Loop\",\n        true\n    ],\n    [\n        \"LabeledStatement\",\n        true\n    ],\n    [\n        \"SwitchStatement\",\n        true\n    ],\n    [\n        \"TryStatement\",\n        true\n    ]\n].forEach(function([type, amounts]) {\n    [\n        type\n    ].concat(FLIPPED_ALIAS_KEYS[type] || []).forEach(function(type) {\n        const ret = amounts ? 3 : 0;\n        nodes[type] = ()=>ret;\n    });\n});\n\n},{\"56c739ff08fbbdce\":\"d4Ce7\"}],\"1maVo\":[function(require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.ArrowFunctionExpression = ArrowFunctionExpression;\nexports.AssignmentExpression = AssignmentExpression;\nexports.Binary = Binary;\nexports.BinaryExpression = BinaryExpression;\nexports.ClassExpression = ClassExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.DoExpression = DoExpression;\nexports.FunctionExpression = FunctionExpression;\nexports.FunctionTypeAnnotation = FunctionTypeAnnotation;\nexports.Identifier = Identifier;\nexports.LogicalExpression = LogicalExpression;\nexports.NullableTypeAnnotation = NullableTypeAnnotation;\nexports.ObjectExpression = ObjectExpression;\nexports.OptionalIndexedAccessType = OptionalIndexedAccessType;\nexports.OptionalCallExpression = exports.OptionalMemberExpression = OptionalMemberExpression;\nexports.SequenceExpression = SequenceExpression;\nexports.TSTypeAssertion = exports.TSSatisfiesExpression = exports.TSAsExpression = TSAsExpression;\nexports.TSInferType = TSInferType;\nexports.TSInstantiationExpression = TSInstantiationExpression;\nexports.TSIntersectionType = exports.TSUnionType = TSUnionType;\nexports.UnaryLike = UnaryLike;\nexports.IntersectionTypeAnnotation = exports.UnionTypeAnnotation = UnionTypeAnnotation;\nexports.UpdateExpression = UpdateExpression;\nexports.AwaitExpression = exports.YieldExpression = YieldExpression;\nvar _t = require(\"29c9983899da93b0\");\nconst { isArrayTypeAnnotation, isArrowFunctionExpression, isAssignmentExpression, isAwaitExpression, isBinary, isBinaryExpression, isUpdateExpression, isCallExpression, isClass, isClassExpression, isConditional, isConditionalExpression, isExportDeclaration, isExportDefaultDeclaration, isExpressionStatement, isFor, isForInStatement, isForOfStatement, isForStatement, isFunctionExpression, isIfStatement, isIndexedAccessType, isIntersectionTypeAnnotation, isLogicalExpression, isMemberExpression, isNewExpression, isNullableTypeAnnotation, isObjectPattern, isOptionalCallExpression, isOptionalMemberExpression, isReturnStatement, isSequenceExpression, isSwitchStatement, isTSArrayType, isTSAsExpression, isTSInstantiationExpression, isTSIntersectionType, isTSNonNullExpression, isTSOptionalType, isTSRestType, isTSTypeAssertion, isTSUnionType, isTaggedTemplateExpression, isThrowStatement, isTypeAnnotation, isUnaryLike, isUnionTypeAnnotation, isVariableDeclarator, isWhileStatement, isYieldExpression, isTSSatisfiesExpression } = _t;\nconst PRECEDENCE = {\n    \"||\": 0,\n    \"??\": 0,\n    \"|>\": 0,\n    \"&&\": 1,\n    \"|\": 2,\n    \"^\": 3,\n    \"&\": 4,\n    \"==\": 5,\n    \"===\": 5,\n    \"!=\": 5,\n    \"!==\": 5,\n    \"<\": 6,\n    \">\": 6,\n    \"<=\": 6,\n    \">=\": 6,\n    in: 6,\n    instanceof: 6,\n    \">>\": 7,\n    \"<<\": 7,\n    \">>>\": 7,\n    \"+\": 8,\n    \"-\": 8,\n    \"*\": 9,\n    \"/\": 9,\n    \"%\": 9,\n    \"**\": 10\n};\nfunction isTSTypeExpression(node) {\n    return isTSAsExpression(node) || isTSSatisfiesExpression(node) || isTSTypeAssertion(node);\n}\nconst isClassExtendsClause = (node, parent)=>isClass(parent, {\n        superClass: node\n    });\nconst hasPostfixPart = (node, parent)=>(isMemberExpression(parent) || isOptionalMemberExpression(parent)) && parent.object === node || (isCallExpression(parent) || isOptionalCallExpression(parent) || isNewExpression(parent)) && parent.callee === node || isTaggedTemplateExpression(parent) && parent.tag === node || isTSNonNullExpression(parent);\nfunction NullableTypeAnnotation(node, parent) {\n    return isArrayTypeAnnotation(parent);\n}\nfunction FunctionTypeAnnotation(node, parent, printStack) {\n    if (printStack.length < 3) return;\n    return isUnionTypeAnnotation(parent) || isIntersectionTypeAnnotation(parent) || isArrayTypeAnnotation(parent) || isTypeAnnotation(parent) && isArrowFunctionExpression(printStack[printStack.length - 3]);\n}\nfunction UpdateExpression(node, parent) {\n    return hasPostfixPart(node, parent) || isClassExtendsClause(node, parent);\n}\nfunction ObjectExpression(node, parent, printStack) {\n    return isFirstInContext(printStack, 3);\n}\nfunction DoExpression(node, parent, printStack) {\n    return !node.async && isFirstInContext(printStack, 1);\n}\nfunction Binary(node, parent) {\n    if (node.operator === \"**\" && isBinaryExpression(parent, {\n        operator: \"**\"\n    })) return parent.left === node;\n    if (isClassExtendsClause(node, parent)) return true;\n    if (hasPostfixPart(node, parent) || isUnaryLike(parent) || isAwaitExpression(parent)) return true;\n    if (isBinary(parent)) {\n        const parentOp = parent.operator;\n        const parentPos = PRECEDENCE[parentOp];\n        const nodeOp = node.operator;\n        const nodePos = PRECEDENCE[nodeOp];\n        if (parentPos === nodePos && parent.right === node && !isLogicalExpression(parent) || parentPos > nodePos) return true;\n    }\n}\nfunction UnionTypeAnnotation(node, parent) {\n    return isArrayTypeAnnotation(parent) || isNullableTypeAnnotation(parent) || isIntersectionTypeAnnotation(parent) || isUnionTypeAnnotation(parent);\n}\nfunction OptionalIndexedAccessType(node, parent) {\n    return isIndexedAccessType(parent, {\n        objectType: node\n    });\n}\nfunction TSAsExpression() {\n    return true;\n}\nfunction TSUnionType(node, parent) {\n    return isTSArrayType(parent) || isTSOptionalType(parent) || isTSIntersectionType(parent) || isTSUnionType(parent) || isTSRestType(parent);\n}\nfunction TSInferType(node, parent) {\n    return isTSArrayType(parent) || isTSOptionalType(parent);\n}\nfunction TSInstantiationExpression(node, parent) {\n    return (isCallExpression(parent) || isOptionalCallExpression(parent) || isNewExpression(parent) || isTSInstantiationExpression(parent)) && !!parent.typeParameters;\n}\nfunction BinaryExpression(node, parent) {\n    return node.operator === \"in\" && (isVariableDeclarator(parent) || isFor(parent));\n}\nfunction SequenceExpression(node, parent) {\n    if (isForStatement(parent) || isThrowStatement(parent) || isReturnStatement(parent) || isIfStatement(parent) && parent.test === node || isWhileStatement(parent) && parent.test === node || isForInStatement(parent) && parent.right === node || isSwitchStatement(parent) && parent.discriminant === node || isExpressionStatement(parent) && parent.expression === node) return false;\n    return true;\n}\nfunction YieldExpression(node, parent) {\n    return isBinary(parent) || isUnaryLike(parent) || hasPostfixPart(node, parent) || isAwaitExpression(parent) && isYieldExpression(node) || isConditionalExpression(parent) && node === parent.test || isClassExtendsClause(node, parent);\n}\nfunction ClassExpression(node, parent, printStack) {\n    return isFirstInContext(printStack, 5);\n}\nfunction UnaryLike(node, parent) {\n    return hasPostfixPart(node, parent) || isBinaryExpression(parent, {\n        operator: \"**\",\n        left: node\n    }) || isClassExtendsClause(node, parent);\n}\nfunction FunctionExpression(node, parent, printStack) {\n    return isFirstInContext(printStack, 5);\n}\nfunction ArrowFunctionExpression(node, parent) {\n    return isExportDeclaration(parent) || ConditionalExpression(node, parent);\n}\nfunction ConditionalExpression(node, parent) {\n    if (isUnaryLike(parent) || isBinary(parent) || isConditionalExpression(parent, {\n        test: node\n    }) || isAwaitExpression(parent) || isTSTypeExpression(parent)) return true;\n    return UnaryLike(node, parent);\n}\nfunction OptionalMemberExpression(node, parent) {\n    return isCallExpression(parent, {\n        callee: node\n    }) || isMemberExpression(parent, {\n        object: node\n    });\n}\nfunction AssignmentExpression(node, parent) {\n    if (isObjectPattern(node.left)) return true;\n    else return ConditionalExpression(node, parent);\n}\nfunction LogicalExpression(node, parent) {\n    if (isTSTypeExpression(parent)) return true;\n    switch(node.operator){\n        case \"||\":\n            if (!isLogicalExpression(parent)) return false;\n            return parent.operator === \"??\" || parent.operator === \"&&\";\n        case \"&&\":\n            return isLogicalExpression(parent, {\n                operator: \"??\"\n            });\n        case \"??\":\n            return isLogicalExpression(parent) && parent.operator !== \"??\";\n    }\n}\nfunction Identifier(node, parent, printStack) {\n    var _node$extra;\n    if ((_node$extra = node.extra) != null && _node$extra.parenthesized && isAssignmentExpression(parent, {\n        left: node\n    }) && (isFunctionExpression(parent.right) || isClassExpression(parent.right)) && parent.right.id == null) return true;\n    if (node.name === \"let\") {\n        const isFollowedByBracket = isMemberExpression(parent, {\n            object: node,\n            computed: true\n        }) || isOptionalMemberExpression(parent, {\n            object: node,\n            computed: true,\n            optional: false\n        });\n        return isFirstInContext(printStack, isFollowedByBracket ? 57 : 32);\n    }\n    return node.name === \"async\" && isForOfStatement(parent) && node === parent.left;\n}\nfunction isFirstInContext(printStack, checkParam) {\n    const expressionStatement = checkParam & 1;\n    const arrowBody = checkParam & 2;\n    const exportDefault = checkParam & 4;\n    const forHead = checkParam & 8;\n    const forInHead = checkParam & 16;\n    const forOfHead = checkParam & 32;\n    let i = printStack.length - 1;\n    if (i <= 0) return;\n    let node = printStack[i];\n    i--;\n    let parent = printStack[i];\n    while(i >= 0){\n        if (expressionStatement && isExpressionStatement(parent, {\n            expression: node\n        }) || exportDefault && isExportDefaultDeclaration(parent, {\n            declaration: node\n        }) || arrowBody && isArrowFunctionExpression(parent, {\n            body: node\n        }) || forHead && isForStatement(parent, {\n            init: node\n        }) || forInHead && isForInStatement(parent, {\n            left: node\n        }) || forOfHead && isForOfStatement(parent, {\n            left: node\n        })) return true;\n        if (i > 0 && (hasPostfixPart(node, parent) && !isNewExpression(parent) || isSequenceExpression(parent) && parent.expressions[0] === node || isUpdateExpression(parent) && !parent.prefix || isConditional(parent, {\n            test: node\n        }) || isBinary(parent, {\n            left: node\n        }) || isAssignmentExpression(parent, {\n            left: node\n        }))) {\n            node = parent;\n            i--;\n            parent = printStack[i];\n        } else return false;\n    }\n    return false;\n}\n\n},{\"29c9983899da93b0\":\"d4Ce7\"}],\"e93Bw\":[function(require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nvar _templateLiterals = require(\"870439b2bcc20340\");\nObject.keys(_templateLiterals).forEach(function(key) {\n    if (key === \"default\" || key === \"__esModule\") return;\n    if (key in exports && exports[key] === _templateLiterals[key]) return;\n    Object.defineProperty(exports, key, {\n        enumerable: true,\n        get: function() {\n            return _templateLiterals[key];\n        }\n    });\n});\nvar _expressions = require(\"3256872e807ff45a\");\nObject.keys(_expressions).forEach(function(key) {\n    if (key === \"default\" || key === \"__esModule\") return;\n    if (key in exports && exports[key] === _expressions[key]) return;\n    Object.defineProperty(exports, key, {\n        enumerable: true,\n        get: function() {\n            return _expressions[key];\n        }\n    });\n});\nvar _statements = require(\"e59e802623a55cbd\");\nObject.keys(_statements).forEach(function(key) {\n    if (key === \"default\" || key === \"__esModule\") return;\n    if (key in exports && exports[key] === _statements[key]) return;\n    Object.defineProperty(exports, key, {\n        enumerable: true,\n        get: function() {\n            return _statements[key];\n        }\n    });\n});\nvar _classes = require(\"448b084631d9494f\");\nObject.keys(_classes).forEach(function(key) {\n    if (key === \"default\" || key === \"__esModule\") return;\n    if (key in exports && exports[key] === _classes[key]) return;\n    Object.defineProperty(exports, key, {\n        enumerable: true,\n        get: function() {\n            return _classes[key];\n        }\n    });\n});\nvar _methods = require(\"50512b7b92f3bcb9\");\nObject.keys(_methods).forEach(function(key) {\n    if (key === \"default\" || key === \"__esModule\") return;\n    if (key in exports && exports[key] === _methods[key]) return;\n    Object.defineProperty(exports, key, {\n        enumerable: true,\n        get: function() {\n            return _methods[key];\n        }\n    });\n});\nvar _modules = require(\"a8d411e38a6e7b29\");\nObject.keys(_modules).forEach(function(key) {\n    if (key === \"default\" || key === \"__esModule\") return;\n    if (key in exports && exports[key] === _modules[key]) return;\n    Object.defineProperty(exports, key, {\n        enumerable: true,\n        get: function() {\n            return _modules[key];\n        }\n    });\n});\nvar _types = require(\"73bf10ecdb6d7554\");\nObject.keys(_types).forEach(function(key) {\n    if (key === \"default\" || key === \"__esModule\") return;\n    if (key in exports && exports[key] === _types[key]) return;\n    Object.defineProperty(exports, key, {\n        enumerable: true,\n        get: function() {\n            return _types[key];\n        }\n    });\n});\nvar _flow = require(\"b87ce1601e4591f2\");\nObject.keys(_flow).forEach(function(key) {\n    if (key === \"default\" || key === \"__esModule\") return;\n    if (key in exports && exports[key] === _flow[key]) return;\n    Object.defineProperty(exports, key, {\n        enumerable: true,\n        get: function() {\n            return _flow[key];\n        }\n    });\n});\nvar _base = require(\"26b86412824e8b1f\");\nObject.keys(_base).forEach(function(key) {\n    if (key === \"default\" || key === \"__esModule\") return;\n    if (key in exports && exports[key] === _base[key]) return;\n    Object.defineProperty(exports, key, {\n        enumerable: true,\n        get: function() {\n            return _base[key];\n        }\n    });\n});\nvar _jsx = require(\"d3ca78bfad926fd2\");\nObject.keys(_jsx).forEach(function(key) {\n    if (key === \"default\" || key === \"__esModule\") return;\n    if (key in exports && exports[key] === _jsx[key]) return;\n    Object.defineProperty(exports, key, {\n        enumerable: true,\n        get: function() {\n            return _jsx[key];\n        }\n    });\n});\nvar _typescript = require(\"ca64751e9ec8f072\");\nObject.keys(_typescript).forEach(function(key) {\n    if (key === \"default\" || key === \"__esModule\") return;\n    if (key in exports && exports[key] === _typescript[key]) return;\n    Object.defineProperty(exports, key, {\n        enumerable: true,\n        get: function() {\n            return _typescript[key];\n        }\n    });\n});\n\n},{\"870439b2bcc20340\":\"hfNBr\",\"3256872e807ff45a\":\"g7cat\",\"e59e802623a55cbd\":\"irX0l\",\"448b084631d9494f\":\"avcei\",\"50512b7b92f3bcb9\":\"7u1Wx\",\"a8d411e38a6e7b29\":\"j6uz3\",\"73bf10ecdb6d7554\":\"aEbDj\",\"b87ce1601e4591f2\":\"akgrj\",\"26b86412824e8b1f\":\"7XCFF\",\"d3ca78bfad926fd2\":\"2hieC\",\"ca64751e9ec8f072\":\"kUGLL\"}],\"hfNBr\":[function(require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.TaggedTemplateExpression = TaggedTemplateExpression;\nexports.TemplateElement = TemplateElement;\nexports.TemplateLiteral = TemplateLiteral;\nfunction TaggedTemplateExpression(node) {\n    this.print(node.tag, node);\n    this.print(node.typeParameters, node);\n    this.print(node.quasi, node);\n}\nfunction TemplateElement(node, parent) {\n    const isFirst = parent.quasis[0] === node;\n    const isLast = parent.quasis[parent.quasis.length - 1] === node;\n    const value = (isFirst ? \"`\" : \"}\") + node.value.raw + (isLast ? \"`\" : \"${\");\n    this.token(value, true);\n}\nfunction TemplateLiteral(node) {\n    const quasis = node.quasis;\n    for(let i = 0; i < quasis.length; i++){\n        this.print(quasis[i], node);\n        if (i + 1 < quasis.length) this.print(node.expressions[i], node);\n    }\n}\n\n},{}],\"g7cat\":[function(require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.LogicalExpression = exports.BinaryExpression = exports.AssignmentExpression = AssignmentExpression;\nexports.AssignmentPattern = AssignmentPattern;\nexports.AwaitExpression = AwaitExpression;\nexports.BindExpression = BindExpression;\nexports.CallExpression = CallExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.Decorator = Decorator;\nexports.DoExpression = DoExpression;\nexports.EmptyStatement = EmptyStatement;\nexports.ExpressionStatement = ExpressionStatement;\nexports.Import = Import;\nexports.MemberExpression = MemberExpression;\nexports.MetaProperty = MetaProperty;\nexports.ModuleExpression = ModuleExpression;\nexports.NewExpression = NewExpression;\nexports.OptionalCallExpression = OptionalCallExpression;\nexports.OptionalMemberExpression = OptionalMemberExpression;\nexports.ParenthesizedExpression = ParenthesizedExpression;\nexports.PrivateName = PrivateName;\nexports.SequenceExpression = SequenceExpression;\nexports.Super = Super;\nexports.ThisExpression = ThisExpression;\nexports.UnaryExpression = UnaryExpression;\nexports.UpdateExpression = UpdateExpression;\nexports.V8IntrinsicIdentifier = V8IntrinsicIdentifier;\nexports.YieldExpression = YieldExpression;\nexports._shouldPrintDecoratorsBeforeExport = _shouldPrintDecoratorsBeforeExport;\nvar _t = require(\"7ce32c397e633721\");\nvar n = require(\"3cdb8138500d5131\");\nconst { isCallExpression, isLiteral, isMemberExpression, isNewExpression } = _t;\nfunction UnaryExpression(node) {\n    const { operator } = node;\n    if (operator === \"void\" || operator === \"delete\" || operator === \"typeof\" || operator === \"throw\") {\n        this.word(operator);\n        this.space();\n    } else this.token(operator);\n    this.print(node.argument, node);\n}\nfunction DoExpression(node) {\n    if (node.async) {\n        this.word(\"async\", true);\n        this.space();\n    }\n    this.word(\"do\");\n    this.space();\n    this.print(node.body, node);\n}\nfunction ParenthesizedExpression(node) {\n    this.tokenChar(40);\n    this.print(node.expression, node);\n    this.rightParens(node);\n}\nfunction UpdateExpression(node) {\n    if (node.prefix) {\n        this.token(node.operator);\n        this.print(node.argument, node);\n    } else {\n        this.printTerminatorless(node.argument, node, true);\n        this.token(node.operator);\n    }\n}\nfunction ConditionalExpression(node) {\n    this.print(node.test, node);\n    this.space();\n    this.tokenChar(63);\n    this.space();\n    this.print(node.consequent, node);\n    this.space();\n    this.tokenChar(58);\n    this.space();\n    this.print(node.alternate, node);\n}\nfunction NewExpression(node, parent) {\n    this.word(\"new\");\n    this.space();\n    this.print(node.callee, node);\n    if (this.format.minified && node.arguments.length === 0 && !node.optional && !isCallExpression(parent, {\n        callee: node\n    }) && !isMemberExpression(parent) && !isNewExpression(parent)) return;\n    this.print(node.typeArguments, node);\n    this.print(node.typeParameters, node);\n    if (node.optional) this.token(\"?.\");\n    this.tokenChar(40);\n    this.printList(node.arguments, node);\n    this.rightParens(node);\n}\nfunction SequenceExpression(node) {\n    this.printList(node.expressions, node);\n}\nfunction ThisExpression() {\n    this.word(\"this\");\n}\nfunction Super() {\n    this.word(\"super\");\n}\nfunction isDecoratorMemberExpression(node) {\n    switch(node.type){\n        case \"Identifier\":\n            return true;\n        case \"MemberExpression\":\n            return !node.computed && node.property.type === \"Identifier\" && isDecoratorMemberExpression(node.object);\n        default:\n            return false;\n    }\n}\nfunction shouldParenthesizeDecoratorExpression(node) {\n    if (node.type === \"ParenthesizedExpression\") return false;\n    return !isDecoratorMemberExpression(node.type === \"CallExpression\" ? node.callee : node);\n}\nfunction _shouldPrintDecoratorsBeforeExport(node) {\n    if (typeof this.format.decoratorsBeforeExport === \"boolean\") return this.format.decoratorsBeforeExport;\n    return typeof node.start === \"number\" && node.start === node.declaration.start;\n}\nfunction Decorator(node) {\n    this.tokenChar(64);\n    const { expression } = node;\n    if (shouldParenthesizeDecoratorExpression(expression)) {\n        this.tokenChar(40);\n        this.print(expression, node);\n        this.tokenChar(41);\n    } else this.print(expression, node);\n    this.newline();\n}\nfunction OptionalMemberExpression(node) {\n    let { computed } = node;\n    const { optional, property } = node;\n    this.print(node.object, node);\n    if (!computed && isMemberExpression(property)) throw new TypeError(\"Got a MemberExpression for MemberExpression property\");\n    if (isLiteral(property) && typeof property.value === \"number\") computed = true;\n    if (optional) this.token(\"?.\");\n    if (computed) {\n        this.tokenChar(91);\n        this.print(property, node);\n        this.tokenChar(93);\n    } else {\n        if (!optional) this.tokenChar(46);\n        this.print(property, node);\n    }\n}\nfunction OptionalCallExpression(node) {\n    this.print(node.callee, node);\n    this.print(node.typeParameters, node);\n    if (node.optional) this.token(\"?.\");\n    this.print(node.typeArguments, node);\n    this.tokenChar(40);\n    this.printList(node.arguments, node);\n    this.rightParens(node);\n}\nfunction CallExpression(node) {\n    this.print(node.callee, node);\n    this.print(node.typeArguments, node);\n    this.print(node.typeParameters, node);\n    this.tokenChar(40);\n    this.printList(node.arguments, node);\n    this.rightParens(node);\n}\nfunction Import() {\n    this.word(\"import\");\n}\nfunction AwaitExpression(node) {\n    this.word(\"await\");\n    if (node.argument) {\n        this.space();\n        this.printTerminatorless(node.argument, node, false);\n    }\n}\nfunction YieldExpression(node) {\n    this.word(\"yield\", true);\n    if (node.delegate) {\n        this.tokenChar(42);\n        if (node.argument) {\n            this.space();\n            this.print(node.argument, node);\n        }\n    } else if (node.argument) {\n        this.space();\n        this.printTerminatorless(node.argument, node, false);\n    }\n}\nfunction EmptyStatement() {\n    this.semicolon(true);\n}\nfunction ExpressionStatement(node) {\n    this.print(node.expression, node);\n    this.semicolon();\n}\nfunction AssignmentPattern(node) {\n    this.print(node.left, node);\n    if (node.left.optional) this.tokenChar(63);\n    this.print(node.left.typeAnnotation, node);\n    this.space();\n    this.tokenChar(61);\n    this.space();\n    this.print(node.right, node);\n}\nfunction AssignmentExpression(node, parent) {\n    const parens = this.inForStatementInitCounter && node.operator === \"in\" && !n.needsParens(node, parent);\n    if (parens) this.tokenChar(40);\n    this.print(node.left, node);\n    this.space();\n    if (node.operator === \"in\" || node.operator === \"instanceof\") this.word(node.operator);\n    else this.token(node.operator);\n    this.space();\n    this.print(node.right, node);\n    if (parens) this.tokenChar(41);\n}\nfunction BindExpression(node) {\n    this.print(node.object, node);\n    this.token(\"::\");\n    this.print(node.callee, node);\n}\nfunction MemberExpression(node) {\n    this.print(node.object, node);\n    if (!node.computed && isMemberExpression(node.property)) throw new TypeError(\"Got a MemberExpression for MemberExpression property\");\n    let computed = node.computed;\n    if (isLiteral(node.property) && typeof node.property.value === \"number\") computed = true;\n    if (computed) {\n        this.tokenChar(91);\n        this.print(node.property, node);\n        this.tokenChar(93);\n    } else {\n        this.tokenChar(46);\n        this.print(node.property, node);\n    }\n}\nfunction MetaProperty(node) {\n    this.print(node.meta, node);\n    this.tokenChar(46);\n    this.print(node.property, node);\n}\nfunction PrivateName(node) {\n    this.tokenChar(35);\n    this.print(node.id, node);\n}\nfunction V8IntrinsicIdentifier(node) {\n    this.tokenChar(37);\n    this.word(node.name);\n}\nfunction ModuleExpression(node) {\n    this.word(\"module\", true);\n    this.space();\n    this.tokenChar(123);\n    this.indent();\n    const { body } = node;\n    if (body.body.length || body.directives.length) this.newline();\n    this.print(body, node);\n    this.dedent();\n    this.rightBrace(node);\n}\n\n},{\"7ce32c397e633721\":\"d4Ce7\",\"3cdb8138500d5131\":\"dLL5b\"}],\"irX0l\":[function(require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.BreakStatement = BreakStatement;\nexports.CatchClause = CatchClause;\nexports.ContinueStatement = ContinueStatement;\nexports.DebuggerStatement = DebuggerStatement;\nexports.DoWhileStatement = DoWhileStatement;\nexports.ForOfStatement = exports.ForInStatement = void 0;\nexports.ForStatement = ForStatement;\nexports.IfStatement = IfStatement;\nexports.LabeledStatement = LabeledStatement;\nexports.ReturnStatement = ReturnStatement;\nexports.SwitchCase = SwitchCase;\nexports.SwitchStatement = SwitchStatement;\nexports.ThrowStatement = ThrowStatement;\nexports.TryStatement = TryStatement;\nexports.VariableDeclaration = VariableDeclaration;\nexports.VariableDeclarator = VariableDeclarator;\nexports.WhileStatement = WhileStatement;\nexports.WithStatement = WithStatement;\nvar _t = require(\"aa441d1f02a4e8a6\");\nconst { isFor, isForStatement, isIfStatement, isStatement } = _t;\nfunction WithStatement(node) {\n    this.word(\"with\");\n    this.space();\n    this.tokenChar(40);\n    this.print(node.object, node);\n    this.tokenChar(41);\n    this.printBlock(node);\n}\nfunction IfStatement(node) {\n    this.word(\"if\");\n    this.space();\n    this.tokenChar(40);\n    this.print(node.test, node);\n    this.tokenChar(41);\n    this.space();\n    const needsBlock = node.alternate && isIfStatement(getLastStatement(node.consequent));\n    if (needsBlock) {\n        this.tokenChar(123);\n        this.newline();\n        this.indent();\n    }\n    this.printAndIndentOnComments(node.consequent, node);\n    if (needsBlock) {\n        this.dedent();\n        this.newline();\n        this.tokenChar(125);\n    }\n    if (node.alternate) {\n        if (this.endsWith(125)) this.space();\n        this.word(\"else\");\n        this.space();\n        this.printAndIndentOnComments(node.alternate, node);\n    }\n}\nfunction getLastStatement(statement) {\n    const { body } = statement;\n    if (isStatement(body) === false) return statement;\n    return getLastStatement(body);\n}\nfunction ForStatement(node) {\n    this.word(\"for\");\n    this.space();\n    this.tokenChar(40);\n    this.inForStatementInitCounter++;\n    this.print(node.init, node);\n    this.inForStatementInitCounter--;\n    this.tokenChar(59);\n    if (node.test) {\n        this.space();\n        this.print(node.test, node);\n    }\n    this.tokenChar(59);\n    if (node.update) {\n        this.space();\n        this.print(node.update, node);\n    }\n    this.tokenChar(41);\n    this.printBlock(node);\n}\nfunction WhileStatement(node) {\n    this.word(\"while\");\n    this.space();\n    this.tokenChar(40);\n    this.print(node.test, node);\n    this.tokenChar(41);\n    this.printBlock(node);\n}\nfunction ForXStatement(node) {\n    this.word(\"for\");\n    this.space();\n    const isForOf = node.type === \"ForOfStatement\";\n    if (isForOf && node.await) {\n        this.word(\"await\");\n        this.space();\n    }\n    this.noIndentInnerCommentsHere();\n    this.tokenChar(40);\n    this.print(node.left, node);\n    this.space();\n    this.word(isForOf ? \"of\" : \"in\");\n    this.space();\n    this.print(node.right, node);\n    this.tokenChar(41);\n    this.printBlock(node);\n}\nconst ForInStatement = ForXStatement;\nexports.ForInStatement = ForInStatement;\nconst ForOfStatement = ForXStatement;\nexports.ForOfStatement = ForOfStatement;\nfunction DoWhileStatement(node) {\n    this.word(\"do\");\n    this.space();\n    this.print(node.body, node);\n    this.space();\n    this.word(\"while\");\n    this.space();\n    this.tokenChar(40);\n    this.print(node.test, node);\n    this.tokenChar(41);\n    this.semicolon();\n}\nfunction printStatementAfterKeyword(printer, node, parent, isLabel) {\n    if (node) {\n        printer.space();\n        printer.printTerminatorless(node, parent, isLabel);\n    }\n    printer.semicolon();\n}\nfunction BreakStatement(node) {\n    this.word(\"break\");\n    printStatementAfterKeyword(this, node.label, node, true);\n}\nfunction ContinueStatement(node) {\n    this.word(\"continue\");\n    printStatementAfterKeyword(this, node.label, node, true);\n}\nfunction ReturnStatement(node) {\n    this.word(\"return\");\n    printStatementAfterKeyword(this, node.argument, node, false);\n}\nfunction ThrowStatement(node) {\n    this.word(\"throw\");\n    printStatementAfterKeyword(this, node.argument, node, false);\n}\nfunction LabeledStatement(node) {\n    this.print(node.label, node);\n    this.tokenChar(58);\n    this.space();\n    this.print(node.body, node);\n}\nfunction TryStatement(node) {\n    this.word(\"try\");\n    this.space();\n    this.print(node.block, node);\n    this.space();\n    if (node.handlers) this.print(node.handlers[0], node);\n    else this.print(node.handler, node);\n    if (node.finalizer) {\n        this.space();\n        this.word(\"finally\");\n        this.space();\n        this.print(node.finalizer, node);\n    }\n}\nfunction CatchClause(node) {\n    this.word(\"catch\");\n    this.space();\n    if (node.param) {\n        this.tokenChar(40);\n        this.print(node.param, node);\n        this.print(node.param.typeAnnotation, node);\n        this.tokenChar(41);\n        this.space();\n    }\n    this.print(node.body, node);\n}\nfunction SwitchStatement(node) {\n    this.word(\"switch\");\n    this.space();\n    this.tokenChar(40);\n    this.print(node.discriminant, node);\n    this.tokenChar(41);\n    this.space();\n    this.tokenChar(123);\n    this.printSequence(node.cases, node, {\n        indent: true,\n        addNewlines (leading, cas) {\n            if (!leading && node.cases[node.cases.length - 1] === cas) return -1;\n        }\n    });\n    this.rightBrace(node);\n}\nfunction SwitchCase(node) {\n    if (node.test) {\n        this.word(\"case\");\n        this.space();\n        this.print(node.test, node);\n        this.tokenChar(58);\n    } else {\n        this.word(\"default\");\n        this.tokenChar(58);\n    }\n    if (node.consequent.length) {\n        this.newline();\n        this.printSequence(node.consequent, node, {\n            indent: true\n        });\n    }\n}\nfunction DebuggerStatement() {\n    this.word(\"debugger\");\n    this.semicolon();\n}\nfunction VariableDeclaration(node, parent) {\n    if (node.declare) {\n        this.word(\"declare\");\n        this.space();\n    }\n    const { kind } = node;\n    this.word(kind, kind === \"using\" || kind === \"await using\");\n    this.space();\n    let hasInits = false;\n    if (!isFor(parent)) {\n        for (const declar of node.declarations)if (declar.init) hasInits = true;\n    }\n    this.printList(node.declarations, node, {\n        separator: hasInits ? function() {\n            this.tokenChar(44);\n            this.newline();\n        } : undefined,\n        indent: node.declarations.length > 1 ? true : false\n    });\n    if (isFor(parent)) {\n        if (isForStatement(parent)) {\n            if (parent.init === node) return;\n        } else {\n            if (parent.left === node) return;\n        }\n    }\n    this.semicolon();\n}\nfunction VariableDeclarator(node) {\n    this.print(node.id, node);\n    if (node.definite) this.tokenChar(33);\n    this.print(node.id.typeAnnotation, node);\n    if (node.init) {\n        this.space();\n        this.tokenChar(61);\n        this.space();\n        this.print(node.init, node);\n    }\n}\n\n},{\"aa441d1f02a4e8a6\":\"d4Ce7\"}],\"avcei\":[function(require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.ClassAccessorProperty = ClassAccessorProperty;\nexports.ClassBody = ClassBody;\nexports.ClassExpression = exports.ClassDeclaration = ClassDeclaration;\nexports.ClassMethod = ClassMethod;\nexports.ClassPrivateMethod = ClassPrivateMethod;\nexports.ClassPrivateProperty = ClassPrivateProperty;\nexports.ClassProperty = ClassProperty;\nexports.StaticBlock = StaticBlock;\nexports._classMethodHead = _classMethodHead;\nvar _t = require(\"550501988c201555\");\nconst { isExportDefaultDeclaration, isExportNamedDeclaration } = _t;\nfunction ClassDeclaration(node, parent) {\n    const inExport = isExportDefaultDeclaration(parent) || isExportNamedDeclaration(parent);\n    if (!inExport || !this._shouldPrintDecoratorsBeforeExport(parent)) this.printJoin(node.decorators, node);\n    if (node.declare) {\n        this.word(\"declare\");\n        this.space();\n    }\n    if (node.abstract) {\n        this.word(\"abstract\");\n        this.space();\n    }\n    this.word(\"class\");\n    if (node.id) {\n        this.space();\n        this.print(node.id, node);\n    }\n    this.print(node.typeParameters, node);\n    if (node.superClass) {\n        this.space();\n        this.word(\"extends\");\n        this.space();\n        this.print(node.superClass, node);\n        this.print(node.superTypeParameters, node);\n    }\n    if (node.implements) {\n        this.space();\n        this.word(\"implements\");\n        this.space();\n        this.printList(node.implements, node);\n    }\n    this.space();\n    this.print(node.body, node);\n}\nfunction ClassBody(node) {\n    this.tokenChar(123);\n    if (node.body.length === 0) this.tokenChar(125);\n    else {\n        this.newline();\n        this.printSequence(node.body, node, {\n            indent: true\n        });\n        if (!this.endsWith(10)) this.newline();\n        this.rightBrace(node);\n    }\n}\nfunction ClassProperty(node) {\n    var _node$key$loc;\n    this.printJoin(node.decorators, node);\n    const endLine = (_node$key$loc = node.key.loc) == null || (_node$key$loc = _node$key$loc.end) == null ? void 0 : _node$key$loc.line;\n    if (endLine) this.catchUp(endLine);\n    this.tsPrintClassMemberModifiers(node);\n    if (node.computed) {\n        this.tokenChar(91);\n        this.print(node.key, node);\n        this.tokenChar(93);\n    } else {\n        this._variance(node);\n        this.print(node.key, node);\n    }\n    if (node.optional) this.tokenChar(63);\n    if (node.definite) this.tokenChar(33);\n    this.print(node.typeAnnotation, node);\n    if (node.value) {\n        this.space();\n        this.tokenChar(61);\n        this.space();\n        this.print(node.value, node);\n    }\n    this.semicolon();\n}\nfunction ClassAccessorProperty(node) {\n    var _node$key$loc2;\n    this.printJoin(node.decorators, node);\n    const endLine = (_node$key$loc2 = node.key.loc) == null || (_node$key$loc2 = _node$key$loc2.end) == null ? void 0 : _node$key$loc2.line;\n    if (endLine) this.catchUp(endLine);\n    this.tsPrintClassMemberModifiers(node);\n    this.word(\"accessor\", true);\n    this.space();\n    if (node.computed) {\n        this.tokenChar(91);\n        this.print(node.key, node);\n        this.tokenChar(93);\n    } else {\n        this._variance(node);\n        this.print(node.key, node);\n    }\n    if (node.optional) this.tokenChar(63);\n    if (node.definite) this.tokenChar(33);\n    this.print(node.typeAnnotation, node);\n    if (node.value) {\n        this.space();\n        this.tokenChar(61);\n        this.space();\n        this.print(node.value, node);\n    }\n    this.semicolon();\n}\nfunction ClassPrivateProperty(node) {\n    this.printJoin(node.decorators, node);\n    if (node.static) {\n        this.word(\"static\");\n        this.space();\n    }\n    this.print(node.key, node);\n    this.print(node.typeAnnotation, node);\n    if (node.value) {\n        this.space();\n        this.tokenChar(61);\n        this.space();\n        this.print(node.value, node);\n    }\n    this.semicolon();\n}\nfunction ClassMethod(node) {\n    this._classMethodHead(node);\n    this.space();\n    this.print(node.body, node);\n}\nfunction ClassPrivateMethod(node) {\n    this._classMethodHead(node);\n    this.space();\n    this.print(node.body, node);\n}\nfunction _classMethodHead(node) {\n    var _node$key$loc3;\n    this.printJoin(node.decorators, node);\n    const endLine = (_node$key$loc3 = node.key.loc) == null || (_node$key$loc3 = _node$key$loc3.end) == null ? void 0 : _node$key$loc3.line;\n    if (endLine) this.catchUp(endLine);\n    this.tsPrintClassMemberModifiers(node);\n    this._methodHead(node);\n}\nfunction StaticBlock(node) {\n    this.word(\"static\");\n    this.space();\n    this.tokenChar(123);\n    if (node.body.length === 0) this.tokenChar(125);\n    else {\n        this.newline();\n        this.printSequence(node.body, node, {\n            indent: true\n        });\n        this.rightBrace(node);\n    }\n}\n\n},{\"550501988c201555\":\"d4Ce7\"}],\"7u1Wx\":[function(require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.ArrowFunctionExpression = ArrowFunctionExpression;\nexports.FunctionDeclaration = exports.FunctionExpression = FunctionExpression;\nexports._functionHead = _functionHead;\nexports._methodHead = _methodHead;\nexports._param = _param;\nexports._parameters = _parameters;\nexports._params = _params;\nexports._predicate = _predicate;\nvar _t = require(\"2e263ae6e0bf16d7\");\nconst { isIdentifier } = _t;\nfunction _params(node, idNode, parentNode) {\n    this.print(node.typeParameters, node);\n    const nameInfo = _getFuncIdName.call(this, idNode, parentNode);\n    if (nameInfo) this.sourceIdentifierName(nameInfo.name, nameInfo.pos);\n    this.tokenChar(40);\n    this._parameters(node.params, node);\n    this.tokenChar(41);\n    const noLineTerminator = node.type === \"ArrowFunctionExpression\";\n    this.print(node.returnType, node, noLineTerminator);\n    this._noLineTerminator = noLineTerminator;\n}\nfunction _parameters(parameters, parent) {\n    const paramLength = parameters.length;\n    for(let i = 0; i < paramLength; i++){\n        this._param(parameters[i], parent);\n        if (i < parameters.length - 1) {\n            this.tokenChar(44);\n            this.space();\n        }\n    }\n}\nfunction _param(parameter, parent) {\n    this.printJoin(parameter.decorators, parameter);\n    this.print(parameter, parent);\n    if (parameter.optional) this.tokenChar(63);\n    this.print(parameter.typeAnnotation, parameter);\n}\nfunction _methodHead(node) {\n    const kind = node.kind;\n    const key = node.key;\n    if (kind === \"get\" || kind === \"set\") {\n        this.word(kind);\n        this.space();\n    }\n    if (node.async) {\n        this.word(\"async\", true);\n        this.space();\n    }\n    if (kind === \"method\" || kind === \"init\") {\n        if (node.generator) this.tokenChar(42);\n    }\n    if (node.computed) {\n        this.tokenChar(91);\n        this.print(key, node);\n        this.tokenChar(93);\n    } else this.print(key, node);\n    if (node.optional) this.tokenChar(63);\n    this._params(node, node.computed && node.key.type !== \"StringLiteral\" ? undefined : node.key, undefined);\n}\nfunction _predicate(node, noLineTerminatorAfter) {\n    if (node.predicate) {\n        if (!node.returnType) this.tokenChar(58);\n        this.space();\n        this.print(node.predicate, node, noLineTerminatorAfter);\n    }\n}\nfunction _functionHead(node, parent) {\n    if (node.async) {\n        this.word(\"async\");\n        this._endsWithInnerRaw = false;\n        this.space();\n    }\n    this.word(\"function\");\n    if (node.generator) {\n        this._endsWithInnerRaw = false;\n        this.tokenChar(42);\n    }\n    this.space();\n    if (node.id) this.print(node.id, node);\n    this._params(node, node.id, parent);\n    if (node.type !== \"TSDeclareFunction\") this._predicate(node);\n}\nfunction FunctionExpression(node, parent) {\n    this._functionHead(node, parent);\n    this.space();\n    this.print(node.body, node);\n}\nfunction ArrowFunctionExpression(node, parent) {\n    if (node.async) {\n        this.word(\"async\", true);\n        this.space();\n    }\n    let firstParam;\n    if (!this.format.retainLines && node.params.length === 1 && isIdentifier(firstParam = node.params[0]) && !hasTypesOrComments(node, firstParam)) this.print(firstParam, node, true);\n    else this._params(node, undefined, parent);\n    this._predicate(node, true);\n    this.space();\n    this.printInnerComments();\n    this.token(\"=>\");\n    this.space();\n    this.print(node.body, node);\n}\nfunction hasTypesOrComments(node, param) {\n    var _param$leadingComment, _param$trailingCommen;\n    return !!(node.typeParameters || node.returnType || node.predicate || param.typeAnnotation || param.optional || (_param$leadingComment = param.leadingComments) != null && _param$leadingComment.length || (_param$trailingCommen = param.trailingComments) != null && _param$trailingCommen.length);\n}\nfunction _getFuncIdName(idNode, parent) {\n    let id = idNode;\n    if (!id && parent) {\n        const parentType = parent.type;\n        if (parentType === \"VariableDeclarator\") id = parent.id;\n        else if (parentType === \"AssignmentExpression\" || parentType === \"AssignmentPattern\") id = parent.left;\n        else if (parentType === \"ObjectProperty\" || parentType === \"ClassProperty\") {\n            if (!parent.computed || parent.key.type === \"StringLiteral\") id = parent.key;\n        } else if (parentType === \"ClassPrivateProperty\" || parentType === \"ClassAccessorProperty\") id = parent.key;\n    }\n    if (!id) return;\n    let nameInfo;\n    if (id.type === \"Identifier\") {\n        var _id$loc, _id$loc2;\n        nameInfo = {\n            pos: (_id$loc = id.loc) == null ? void 0 : _id$loc.start,\n            name: ((_id$loc2 = id.loc) == null ? void 0 : _id$loc2.identifierName) || id.name\n        };\n    } else if (id.type === \"PrivateName\") {\n        var _id$loc3;\n        nameInfo = {\n            pos: (_id$loc3 = id.loc) == null ? void 0 : _id$loc3.start,\n            name: \"#\" + id.id.name\n        };\n    } else if (id.type === \"StringLiteral\") {\n        var _id$loc4;\n        nameInfo = {\n            pos: (_id$loc4 = id.loc) == null ? void 0 : _id$loc4.start,\n            name: id.value\n        };\n    }\n    return nameInfo;\n}\n\n},{\"2e263ae6e0bf16d7\":\"d4Ce7\"}],\"j6uz3\":[function(require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.ExportAllDeclaration = ExportAllDeclaration;\nexports.ExportDefaultDeclaration = ExportDefaultDeclaration;\nexports.ExportDefaultSpecifier = ExportDefaultSpecifier;\nexports.ExportNamedDeclaration = ExportNamedDeclaration;\nexports.ExportNamespaceSpecifier = ExportNamespaceSpecifier;\nexports.ExportSpecifier = ExportSpecifier;\nexports.ImportAttribute = ImportAttribute;\nexports.ImportDeclaration = ImportDeclaration;\nexports.ImportDefaultSpecifier = ImportDefaultSpecifier;\nexports.ImportExpression = ImportExpression;\nexports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;\nexports.ImportSpecifier = ImportSpecifier;\nexports._printAttributes = _printAttributes;\nvar _t = require(\"b22f0a9a67a9a36\");\nconst { isClassDeclaration, isExportDefaultSpecifier, isExportNamespaceSpecifier, isImportDefaultSpecifier, isImportNamespaceSpecifier, isStatement } = _t;\nfunction ImportSpecifier(node) {\n    if (node.importKind === \"type\" || node.importKind === \"typeof\") {\n        this.word(node.importKind);\n        this.space();\n    }\n    this.print(node.imported, node);\n    if (node.local && node.local.name !== node.imported.name) {\n        this.space();\n        this.word(\"as\");\n        this.space();\n        this.print(node.local, node);\n    }\n}\nfunction ImportDefaultSpecifier(node) {\n    this.print(node.local, node);\n}\nfunction ExportDefaultSpecifier(node) {\n    this.print(node.exported, node);\n}\nfunction ExportSpecifier(node) {\n    if (node.exportKind === \"type\") {\n        this.word(\"type\");\n        this.space();\n    }\n    this.print(node.local, node);\n    if (node.exported && node.local.name !== node.exported.name) {\n        this.space();\n        this.word(\"as\");\n        this.space();\n        this.print(node.exported, node);\n    }\n}\nfunction ExportNamespaceSpecifier(node) {\n    this.tokenChar(42);\n    this.space();\n    this.word(\"as\");\n    this.space();\n    this.print(node.exported, node);\n}\nlet warningShown = false;\nfunction _printAttributes(node) {\n    const { importAttributesKeyword } = this.format;\n    const { attributes, assertions } = node;\n    if (attributes && !importAttributesKeyword && !warningShown) {\n        warningShown = true;\n        console.warn(`\\\nYou are using import attributes, without specifying the desired output syntax.\nPlease specify the \"importAttributesKeyword\" generator option, whose value can be one of:\n - \"with\"        : \\`import { a } from \"b\" with { type: \"json\" };\\`\n - \"assert\"      : \\`import { a } from \"b\" assert { type: \"json\" };\\`\n - \"with-legacy\" : \\`import { a } from \"b\" with type: \"json\";\\`\n`);\n    }\n    const useAssertKeyword = importAttributesKeyword === \"assert\" || !importAttributesKeyword && assertions;\n    this.word(useAssertKeyword ? \"assert\" : \"with\");\n    this.space();\n    if (!useAssertKeyword && importAttributesKeyword !== \"with\") {\n        this.printList(attributes || assertions, node);\n        return;\n    }\n    this.tokenChar(123);\n    this.space();\n    this.printList(attributes || assertions, node);\n    this.space();\n    this.tokenChar(125);\n}\nfunction ExportAllDeclaration(node) {\n    var _node$attributes, _node$assertions;\n    this.word(\"export\");\n    this.space();\n    if (node.exportKind === \"type\") {\n        this.word(\"type\");\n        this.space();\n    }\n    this.tokenChar(42);\n    this.space();\n    this.word(\"from\");\n    this.space();\n    if ((_node$attributes = node.attributes) != null && _node$attributes.length || (_node$assertions = node.assertions) != null && _node$assertions.length) {\n        this.print(node.source, node, true);\n        this.space();\n        this._printAttributes(node);\n    } else this.print(node.source, node);\n    this.semicolon();\n}\nfunction maybePrintDecoratorsBeforeExport(printer, node) {\n    if (isClassDeclaration(node.declaration) && printer._shouldPrintDecoratorsBeforeExport(node)) printer.printJoin(node.declaration.decorators, node);\n}\nfunction ExportNamedDeclaration(node) {\n    maybePrintDecoratorsBeforeExport(this, node);\n    this.word(\"export\");\n    this.space();\n    if (node.declaration) {\n        const declar = node.declaration;\n        this.print(declar, node);\n        if (!isStatement(declar)) this.semicolon();\n    } else {\n        if (node.exportKind === \"type\") {\n            this.word(\"type\");\n            this.space();\n        }\n        const specifiers = node.specifiers.slice(0);\n        let hasSpecial = false;\n        for(;;){\n            const first = specifiers[0];\n            if (isExportDefaultSpecifier(first) || isExportNamespaceSpecifier(first)) {\n                hasSpecial = true;\n                this.print(specifiers.shift(), node);\n                if (specifiers.length) {\n                    this.tokenChar(44);\n                    this.space();\n                }\n            } else break;\n        }\n        if (specifiers.length || !specifiers.length && !hasSpecial) {\n            this.tokenChar(123);\n            if (specifiers.length) {\n                this.space();\n                this.printList(specifiers, node);\n                this.space();\n            }\n            this.tokenChar(125);\n        }\n        if (node.source) {\n            var _node$attributes2, _node$assertions2;\n            this.space();\n            this.word(\"from\");\n            this.space();\n            if ((_node$attributes2 = node.attributes) != null && _node$attributes2.length || (_node$assertions2 = node.assertions) != null && _node$assertions2.length) {\n                this.print(node.source, node, true);\n                this.space();\n                this._printAttributes(node);\n            } else this.print(node.source, node);\n        }\n        this.semicolon();\n    }\n}\nfunction ExportDefaultDeclaration(node) {\n    maybePrintDecoratorsBeforeExport(this, node);\n    this.word(\"export\");\n    this.noIndentInnerCommentsHere();\n    this.space();\n    this.word(\"default\");\n    this.space();\n    const declar = node.declaration;\n    this.print(declar, node);\n    if (!isStatement(declar)) this.semicolon();\n}\nfunction ImportDeclaration(node) {\n    var _node$attributes3, _node$assertions3;\n    this.word(\"import\");\n    this.space();\n    const isTypeKind = node.importKind === \"type\" || node.importKind === \"typeof\";\n    if (isTypeKind) {\n        this.noIndentInnerCommentsHere();\n        this.word(node.importKind);\n        this.space();\n    } else if (node.module) {\n        this.noIndentInnerCommentsHere();\n        this.word(\"module\");\n        this.space();\n    } else if (node.phase) {\n        this.noIndentInnerCommentsHere();\n        this.word(node.phase);\n        this.space();\n    }\n    const specifiers = node.specifiers.slice(0);\n    const hasSpecifiers = !!specifiers.length;\n    while(hasSpecifiers){\n        const first = specifiers[0];\n        if (isImportDefaultSpecifier(first) || isImportNamespaceSpecifier(first)) {\n            this.print(specifiers.shift(), node);\n            if (specifiers.length) {\n                this.tokenChar(44);\n                this.space();\n            }\n        } else break;\n    }\n    if (specifiers.length) {\n        this.tokenChar(123);\n        this.space();\n        this.printList(specifiers, node);\n        this.space();\n        this.tokenChar(125);\n    } else if (isTypeKind && !hasSpecifiers) {\n        this.tokenChar(123);\n        this.tokenChar(125);\n    }\n    if (hasSpecifiers || isTypeKind) {\n        this.space();\n        this.word(\"from\");\n        this.space();\n    }\n    if ((_node$attributes3 = node.attributes) != null && _node$attributes3.length || (_node$assertions3 = node.assertions) != null && _node$assertions3.length) {\n        this.print(node.source, node, true);\n        this.space();\n        this._printAttributes(node);\n    } else this.print(node.source, node);\n    this.semicolon();\n}\nfunction ImportAttribute(node) {\n    this.print(node.key);\n    this.tokenChar(58);\n    this.space();\n    this.print(node.value);\n}\nfunction ImportNamespaceSpecifier(node) {\n    this.tokenChar(42);\n    this.space();\n    this.word(\"as\");\n    this.space();\n    this.print(node.local, node);\n}\nfunction ImportExpression(node) {\n    this.word(\"import\");\n    if (node.phase) {\n        this.tokenChar(46);\n        this.word(node.phase);\n    }\n    this.tokenChar(40);\n    this.print(node.source, node);\n    if (node.options != null) {\n        this.tokenChar(44);\n        this.space();\n        this.print(node.options, node);\n    }\n    this.tokenChar(41);\n}\n\n},{\"b22f0a9a67a9a36\":\"d4Ce7\"}],\"aEbDj\":[function(require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.ArgumentPlaceholder = ArgumentPlaceholder;\nexports.ArrayPattern = exports.ArrayExpression = ArrayExpression;\nexports.BigIntLiteral = BigIntLiteral;\nexports.BooleanLiteral = BooleanLiteral;\nexports.DecimalLiteral = DecimalLiteral;\nexports.Identifier = Identifier;\nexports.NullLiteral = NullLiteral;\nexports.NumericLiteral = NumericLiteral;\nexports.ObjectPattern = exports.ObjectExpression = ObjectExpression;\nexports.ObjectMethod = ObjectMethod;\nexports.ObjectProperty = ObjectProperty;\nexports.PipelineBareFunction = PipelineBareFunction;\nexports.PipelinePrimaryTopicReference = PipelinePrimaryTopicReference;\nexports.PipelineTopicExpression = PipelineTopicExpression;\nexports.RecordExpression = RecordExpression;\nexports.RegExpLiteral = RegExpLiteral;\nexports.SpreadElement = exports.RestElement = RestElement;\nexports.StringLiteral = StringLiteral;\nexports.TopicReference = TopicReference;\nexports.TupleExpression = TupleExpression;\nvar _t = require(\"18c7fb08ed0d13b1\");\nvar _jsesc = require(\"49ca67bb9fd01ecd\");\nconst { isAssignmentPattern, isIdentifier } = _t;\nfunction Identifier(node) {\n    var _node$loc;\n    this.sourceIdentifierName(((_node$loc = node.loc) == null ? void 0 : _node$loc.identifierName) || node.name);\n    this.word(node.name);\n}\nfunction ArgumentPlaceholder() {\n    this.tokenChar(63);\n}\nfunction RestElement(node) {\n    this.token(\"...\");\n    this.print(node.argument, node);\n}\nfunction ObjectExpression(node) {\n    const props = node.properties;\n    this.tokenChar(123);\n    if (props.length) {\n        this.space();\n        this.printList(props, node, {\n            indent: true,\n            statement: true\n        });\n        this.space();\n    }\n    this.sourceWithOffset(\"end\", node.loc, -1);\n    this.tokenChar(125);\n}\nfunction ObjectMethod(node) {\n    this.printJoin(node.decorators, node);\n    this._methodHead(node);\n    this.space();\n    this.print(node.body, node);\n}\nfunction ObjectProperty(node) {\n    this.printJoin(node.decorators, node);\n    if (node.computed) {\n        this.tokenChar(91);\n        this.print(node.key, node);\n        this.tokenChar(93);\n    } else {\n        if (isAssignmentPattern(node.value) && isIdentifier(node.key) && node.key.name === node.value.left.name) {\n            this.print(node.value, node);\n            return;\n        }\n        this.print(node.key, node);\n        if (node.shorthand && isIdentifier(node.key) && isIdentifier(node.value) && node.key.name === node.value.name) return;\n    }\n    this.tokenChar(58);\n    this.space();\n    this.print(node.value, node);\n}\nfunction ArrayExpression(node) {\n    const elems = node.elements;\n    const len = elems.length;\n    this.tokenChar(91);\n    for(let i = 0; i < elems.length; i++){\n        const elem = elems[i];\n        if (elem) {\n            if (i > 0) this.space();\n            this.print(elem, node);\n            if (i < len - 1) this.tokenChar(44);\n        } else this.tokenChar(44);\n    }\n    this.tokenChar(93);\n}\nfunction RecordExpression(node) {\n    const props = node.properties;\n    let startToken;\n    let endToken;\n    if (this.format.recordAndTupleSyntaxType === \"bar\") {\n        startToken = \"{|\";\n        endToken = \"|}\";\n    } else if (this.format.recordAndTupleSyntaxType !== \"hash\" && this.format.recordAndTupleSyntaxType != null) throw new Error(`The \"recordAndTupleSyntaxType\" generator option must be \"bar\" or \"hash\" (${JSON.stringify(this.format.recordAndTupleSyntaxType)} received).`);\n    else {\n        startToken = \"#{\";\n        endToken = \"}\";\n    }\n    this.token(startToken);\n    if (props.length) {\n        this.space();\n        this.printList(props, node, {\n            indent: true,\n            statement: true\n        });\n        this.space();\n    }\n    this.token(endToken);\n}\nfunction TupleExpression(node) {\n    const elems = node.elements;\n    const len = elems.length;\n    let startToken;\n    let endToken;\n    if (this.format.recordAndTupleSyntaxType === \"bar\") {\n        startToken = \"[|\";\n        endToken = \"|]\";\n    } else if (this.format.recordAndTupleSyntaxType === \"hash\") {\n        startToken = \"#[\";\n        endToken = \"]\";\n    } else throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);\n    this.token(startToken);\n    for(let i = 0; i < elems.length; i++){\n        const elem = elems[i];\n        if (elem) {\n            if (i > 0) this.space();\n            this.print(elem, node);\n            if (i < len - 1) this.tokenChar(44);\n        }\n    }\n    this.token(endToken);\n}\nfunction RegExpLiteral(node) {\n    this.word(`/${node.pattern}/${node.flags}`);\n}\nfunction BooleanLiteral(node) {\n    this.word(node.value ? \"true\" : \"false\");\n}\nfunction NullLiteral() {\n    this.word(\"null\");\n}\nfunction NumericLiteral(node) {\n    const raw = this.getPossibleRaw(node);\n    const opts = this.format.jsescOption;\n    const value = node.value + \"\";\n    if (opts.numbers) this.number(_jsesc(node.value, opts));\n    else if (raw == null) this.number(value);\n    else if (this.format.minified) this.number(raw.length < value.length ? raw : value);\n    else this.number(raw);\n}\nfunction StringLiteral(node) {\n    const raw = this.getPossibleRaw(node);\n    if (!this.format.minified && raw !== undefined) {\n        this.token(raw);\n        return;\n    }\n    const val = _jsesc(node.value, this.format.jsescOption);\n    this.token(val);\n}\nfunction BigIntLiteral(node) {\n    const raw = this.getPossibleRaw(node);\n    if (!this.format.minified && raw !== undefined) {\n        this.word(raw);\n        return;\n    }\n    this.word(node.value + \"n\");\n}\nfunction DecimalLiteral(node) {\n    const raw = this.getPossibleRaw(node);\n    if (!this.format.minified && raw !== undefined) {\n        this.word(raw);\n        return;\n    }\n    this.word(node.value + \"m\");\n}\nconst validTopicTokenSet = new Set([\n    \"^^\",\n    \"@@\",\n    \"^\",\n    \"%\",\n    \"#\"\n]);\nfunction TopicReference() {\n    const { topicToken } = this.format;\n    if (validTopicTokenSet.has(topicToken)) this.token(topicToken);\n    else {\n        const givenTopicTokenJSON = JSON.stringify(topicToken);\n        const validTopics = Array.from(validTopicTokenSet, (v)=>JSON.stringify(v));\n        throw new Error(`The \"topicToken\" generator option must be one of ` + `${validTopics.join(\", \")} (${givenTopicTokenJSON} received instead).`);\n    }\n}\nfunction PipelineTopicExpression(node) {\n    this.print(node.expression, node);\n}\nfunction PipelineBareFunction(node) {\n    this.print(node.callee, node);\n}\nfunction PipelinePrimaryTopicReference() {\n    this.tokenChar(35);\n}\n\n},{\"18c7fb08ed0d13b1\":\"d4Ce7\",\"49ca67bb9fd01ecd\":\"hQe9P\"}],\"hQe9P\":[function(require,module,exports) {\nvar Buffer = require(\"7348f8880839706c\").Buffer;\n\"use strict\";\nconst object = {};\nconst hasOwnProperty = object.hasOwnProperty;\nconst forOwn = (object, callback)=>{\n    for(const key in object)if (hasOwnProperty.call(object, key)) callback(key, object[key]);\n};\nconst extend = (destination, source)=>{\n    if (!source) return destination;\n    forOwn(source, (key, value)=>{\n        destination[key] = value;\n    });\n    return destination;\n};\nconst forEach = (array, callback)=>{\n    const length = array.length;\n    let index = -1;\n    while(++index < length)callback(array[index]);\n};\nconst toString = object.toString;\nconst isArray = Array.isArray;\nconst isBuffer = Buffer.isBuffer;\nconst isObject = (value)=>{\n    // This is a very simple check, but its good enough for what we need.\n    return toString.call(value) == \"[object Object]\";\n};\nconst isString = (value)=>{\n    return typeof value == \"string\" || toString.call(value) == \"[object String]\";\n};\nconst isNumber = (value)=>{\n    return typeof value == \"number\" || toString.call(value) == \"[object Number]\";\n};\nconst isFunction = (value)=>{\n    return typeof value == \"function\";\n};\nconst isMap = (value)=>{\n    return toString.call(value) == \"[object Map]\";\n};\nconst isSet = (value)=>{\n    return toString.call(value) == \"[object Set]\";\n};\n/*--------------------------------------------------------------------------*/ // https://mathiasbynens.be/notes/javascript-escapes#single\nconst singleEscapes = {\n    '\"': '\\\\\"',\n    \"'\": \"\\\\'\",\n    \"\\\\\": \"\\\\\\\\\",\n    \"\\b\": \"\\\\b\",\n    \"\\f\": \"\\\\f\",\n    \"\\n\": \"\\\\n\",\n    \"\\r\": \"\\\\r\",\n    \"\t\": \"\\\\t\"\n};\nconst regexSingleEscape = /[\"'\\\\\\b\\f\\n\\r\\t]/;\nconst regexDigit = /[0-9]/;\nconst regexWhitelist = /[ !#-&\\(-\\[\\]-_a-~]/;\nconst jsesc = (argument, options)=>{\n    const increaseIndentation = ()=>{\n        oldIndent = indent;\n        ++options.indentLevel;\n        indent = options.indent.repeat(options.indentLevel);\n    };\n    // Handle options\n    const defaults = {\n        \"escapeEverything\": false,\n        \"minimal\": false,\n        \"isScriptContext\": false,\n        \"quotes\": \"single\",\n        \"wrap\": false,\n        \"es6\": false,\n        \"json\": false,\n        \"compact\": true,\n        \"lowercaseHex\": false,\n        \"numbers\": \"decimal\",\n        \"indent\": \"\t\",\n        \"indentLevel\": 0,\n        \"__inline1__\": false,\n        \"__inline2__\": false\n    };\n    const json = options && options.json;\n    if (json) {\n        defaults.quotes = \"double\";\n        defaults.wrap = true;\n    }\n    options = extend(defaults, options);\n    if (options.quotes != \"single\" && options.quotes != \"double\" && options.quotes != \"backtick\") options.quotes = \"single\";\n    const quote = options.quotes == \"double\" ? '\"' : options.quotes == \"backtick\" ? \"`\" : \"'\";\n    const compact = options.compact;\n    const lowercaseHex = options.lowercaseHex;\n    let indent = options.indent.repeat(options.indentLevel);\n    let oldIndent = \"\";\n    const inline1 = options.__inline1__;\n    const inline2 = options.__inline2__;\n    const newLine = compact ? \"\" : \"\\n\";\n    let result;\n    let isEmpty = true;\n    const useBinNumbers = options.numbers == \"binary\";\n    const useOctNumbers = options.numbers == \"octal\";\n    const useDecNumbers = options.numbers == \"decimal\";\n    const useHexNumbers = options.numbers == \"hexadecimal\";\n    if (json && argument && isFunction(argument.toJSON)) argument = argument.toJSON();\n    if (!isString(argument)) {\n        if (isMap(argument)) {\n            if (argument.size == 0) return \"new Map()\";\n            if (!compact) {\n                options.__inline1__ = true;\n                options.__inline2__ = false;\n            }\n            return \"new Map(\" + jsesc(Array.from(argument), options) + \")\";\n        }\n        if (isSet(argument)) {\n            if (argument.size == 0) return \"new Set()\";\n            return \"new Set(\" + jsesc(Array.from(argument), options) + \")\";\n        }\n        if (isBuffer(argument)) {\n            if (argument.length == 0) return \"Buffer.from([])\";\n            return \"Buffer.from(\" + jsesc(Array.from(argument), options) + \")\";\n        }\n        if (isArray(argument)) {\n            result = [];\n            options.wrap = true;\n            if (inline1) {\n                options.__inline1__ = false;\n                options.__inline2__ = true;\n            }\n            if (!inline2) increaseIndentation();\n            forEach(argument, (value)=>{\n                isEmpty = false;\n                if (inline2) options.__inline2__ = false;\n                result.push((compact || inline2 ? \"\" : indent) + jsesc(value, options));\n            });\n            if (isEmpty) return \"[]\";\n            if (inline2) return \"[\" + result.join(\", \") + \"]\";\n            return \"[\" + newLine + result.join(\",\" + newLine) + newLine + (compact ? \"\" : oldIndent) + \"]\";\n        } else if (isNumber(argument)) {\n            if (json) // Some number values (e.g. `Infinity`) cannot be represented in JSON.\n            return JSON.stringify(argument);\n            if (useDecNumbers) return String(argument);\n            if (useHexNumbers) {\n                let hexadecimal = argument.toString(16);\n                if (!lowercaseHex) hexadecimal = hexadecimal.toUpperCase();\n                return \"0x\" + hexadecimal;\n            }\n            if (useBinNumbers) return \"0b\" + argument.toString(2);\n            if (useOctNumbers) return \"0o\" + argument.toString(8);\n        } else if (!isObject(argument)) {\n            if (json) // For some values (e.g. `undefined`, `function` objects),\n            // `JSON.stringify(value)` returns `undefined` (which isnt valid\n            // JSON) instead of `'null'`.\n            return JSON.stringify(argument) || \"null\";\n            return String(argument);\n        } else {\n            result = [];\n            options.wrap = true;\n            increaseIndentation();\n            forOwn(argument, (key, value)=>{\n                isEmpty = false;\n                result.push((compact ? \"\" : indent) + jsesc(key, options) + \":\" + (compact ? \"\" : \" \") + jsesc(value, options));\n            });\n            if (isEmpty) return \"{}\";\n            return \"{\" + newLine + result.join(\",\" + newLine) + newLine + (compact ? \"\" : oldIndent) + \"}\";\n        }\n    }\n    const string = argument;\n    // Loop over each code unit in the string and escape it\n    let index = -1;\n    const length = string.length;\n    result = \"\";\n    while(++index < length){\n        const character = string.charAt(index);\n        if (options.es6) {\n            const first = string.charCodeAt(index);\n            if (first >= 0xD800 && first <= 0xDBFF && // high surrogate\n            length > index + 1 // there is a next code unit\n            ) {\n                const second = string.charCodeAt(index + 1);\n                if (second >= 0xDC00 && second <= 0xDFFF) {\n                    // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n                    const codePoint = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n                    let hexadecimal = codePoint.toString(16);\n                    if (!lowercaseHex) hexadecimal = hexadecimal.toUpperCase();\n                    result += \"\\\\u{\" + hexadecimal + \"}\";\n                    ++index;\n                    continue;\n                }\n            }\n        }\n        if (!options.escapeEverything) {\n            if (regexWhitelist.test(character)) {\n                // Its a printable ASCII character that is not `\"`, `'` or `\\`,\n                // so dont escape it.\n                result += character;\n                continue;\n            }\n            if (character == '\"') {\n                result += quote == character ? '\\\\\"' : character;\n                continue;\n            }\n            if (character == \"`\") {\n                result += quote == character ? \"\\\\`\" : character;\n                continue;\n            }\n            if (character == \"'\") {\n                result += quote == character ? \"\\\\'\" : character;\n                continue;\n            }\n        }\n        if (character == \"\\0\" && !json && !regexDigit.test(string.charAt(index + 1))) {\n            result += \"\\\\0\";\n            continue;\n        }\n        if (regexSingleEscape.test(character)) {\n            // no need for a `hasOwnProperty` check here\n            result += singleEscapes[character];\n            continue;\n        }\n        const charCode = character.charCodeAt(0);\n        if (options.minimal && charCode != 0x2028 && charCode != 0x2029) {\n            result += character;\n            continue;\n        }\n        let hexadecimal = charCode.toString(16);\n        if (!lowercaseHex) hexadecimal = hexadecimal.toUpperCase();\n        const longhand = hexadecimal.length > 2 || json;\n        const escaped = \"\\\\\" + (longhand ? \"u\" : \"x\") + (\"0000\" + hexadecimal).slice(longhand ? -4 : -2);\n        result += escaped;\n        continue;\n    }\n    if (options.wrap) result = quote + result + quote;\n    if (quote == \"`\") result = result.replace(/\\$\\{/g, \"\\\\${\");\n    if (options.isScriptContext) // https://mathiasbynens.be/notes/etago\n    return result.replace(/<\\/(script|style)/gi, \"<\\\\/$1\").replace(/<!--/g, json ? \"\\\\u003C!--\" : \"\\\\x3C!--\");\n    return result;\n};\njsesc.version = \"2.5.2\";\nmodule.exports = jsesc;\n\n},{\"7348f8880839706c\":\"hNvPC\"}],\"akgrj\":[function(require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.AnyTypeAnnotation = AnyTypeAnnotation;\nexports.ArrayTypeAnnotation = ArrayTypeAnnotation;\nexports.BooleanLiteralTypeAnnotation = BooleanLiteralTypeAnnotation;\nexports.BooleanTypeAnnotation = BooleanTypeAnnotation;\nexports.DeclareClass = DeclareClass;\nexports.DeclareExportAllDeclaration = DeclareExportAllDeclaration;\nexports.DeclareExportDeclaration = DeclareExportDeclaration;\nexports.DeclareFunction = DeclareFunction;\nexports.DeclareInterface = DeclareInterface;\nexports.DeclareModule = DeclareModule;\nexports.DeclareModuleExports = DeclareModuleExports;\nexports.DeclareOpaqueType = DeclareOpaqueType;\nexports.DeclareTypeAlias = DeclareTypeAlias;\nexports.DeclareVariable = DeclareVariable;\nexports.DeclaredPredicate = DeclaredPredicate;\nexports.EmptyTypeAnnotation = EmptyTypeAnnotation;\nexports.EnumBooleanBody = EnumBooleanBody;\nexports.EnumBooleanMember = EnumBooleanMember;\nexports.EnumDeclaration = EnumDeclaration;\nexports.EnumDefaultedMember = EnumDefaultedMember;\nexports.EnumNumberBody = EnumNumberBody;\nexports.EnumNumberMember = EnumNumberMember;\nexports.EnumStringBody = EnumStringBody;\nexports.EnumStringMember = EnumStringMember;\nexports.EnumSymbolBody = EnumSymbolBody;\nexports.ExistsTypeAnnotation = ExistsTypeAnnotation;\nexports.FunctionTypeAnnotation = FunctionTypeAnnotation;\nexports.FunctionTypeParam = FunctionTypeParam;\nexports.IndexedAccessType = IndexedAccessType;\nexports.InferredPredicate = InferredPredicate;\nexports.InterfaceDeclaration = InterfaceDeclaration;\nexports.GenericTypeAnnotation = exports.ClassImplements = exports.InterfaceExtends = InterfaceExtends;\nexports.InterfaceTypeAnnotation = InterfaceTypeAnnotation;\nexports.IntersectionTypeAnnotation = IntersectionTypeAnnotation;\nexports.MixedTypeAnnotation = MixedTypeAnnotation;\nexports.NullLiteralTypeAnnotation = NullLiteralTypeAnnotation;\nexports.NullableTypeAnnotation = NullableTypeAnnotation;\nObject.defineProperty(exports, \"NumberLiteralTypeAnnotation\", {\n    enumerable: true,\n    get: function() {\n        return _types2.NumericLiteral;\n    }\n});\nexports.NumberTypeAnnotation = NumberTypeAnnotation;\nexports.ObjectTypeAnnotation = ObjectTypeAnnotation;\nexports.ObjectTypeCallProperty = ObjectTypeCallProperty;\nexports.ObjectTypeIndexer = ObjectTypeIndexer;\nexports.ObjectTypeInternalSlot = ObjectTypeInternalSlot;\nexports.ObjectTypeProperty = ObjectTypeProperty;\nexports.ObjectTypeSpreadProperty = ObjectTypeSpreadProperty;\nexports.OpaqueType = OpaqueType;\nexports.OptionalIndexedAccessType = OptionalIndexedAccessType;\nexports.QualifiedTypeIdentifier = QualifiedTypeIdentifier;\nObject.defineProperty(exports, \"StringLiteralTypeAnnotation\", {\n    enumerable: true,\n    get: function() {\n        return _types2.StringLiteral;\n    }\n});\nexports.StringTypeAnnotation = StringTypeAnnotation;\nexports.SymbolTypeAnnotation = SymbolTypeAnnotation;\nexports.ThisTypeAnnotation = ThisTypeAnnotation;\nexports.TupleTypeAnnotation = TupleTypeAnnotation;\nexports.TypeAlias = TypeAlias;\nexports.TypeAnnotation = TypeAnnotation;\nexports.TypeCastExpression = TypeCastExpression;\nexports.TypeParameter = TypeParameter;\nexports.TypeParameterDeclaration = exports.TypeParameterInstantiation = TypeParameterInstantiation;\nexports.TypeofTypeAnnotation = TypeofTypeAnnotation;\nexports.UnionTypeAnnotation = UnionTypeAnnotation;\nexports.Variance = Variance;\nexports.VoidTypeAnnotation = VoidTypeAnnotation;\nexports._interfaceish = _interfaceish;\nexports._variance = _variance;\nvar _t = require(\"1f417b5d05be6092\");\nvar _modules = require(\"f19583aad5cac1e7\");\nvar _types2 = require(\"bd3412e910d75fb8\");\nconst { isDeclareExportDeclaration, isStatement } = _t;\nfunction AnyTypeAnnotation() {\n    this.word(\"any\");\n}\nfunction ArrayTypeAnnotation(node) {\n    this.print(node.elementType, node, true);\n    this.tokenChar(91);\n    this.tokenChar(93);\n}\nfunction BooleanTypeAnnotation() {\n    this.word(\"boolean\");\n}\nfunction BooleanLiteralTypeAnnotation(node) {\n    this.word(node.value ? \"true\" : \"false\");\n}\nfunction NullLiteralTypeAnnotation() {\n    this.word(\"null\");\n}\nfunction DeclareClass(node, parent) {\n    if (!isDeclareExportDeclaration(parent)) {\n        this.word(\"declare\");\n        this.space();\n    }\n    this.word(\"class\");\n    this.space();\n    this._interfaceish(node);\n}\nfunction DeclareFunction(node, parent) {\n    if (!isDeclareExportDeclaration(parent)) {\n        this.word(\"declare\");\n        this.space();\n    }\n    this.word(\"function\");\n    this.space();\n    this.print(node.id, node);\n    this.print(node.id.typeAnnotation.typeAnnotation, node);\n    if (node.predicate) {\n        this.space();\n        this.print(node.predicate, node);\n    }\n    this.semicolon();\n}\nfunction InferredPredicate() {\n    this.tokenChar(37);\n    this.word(\"checks\");\n}\nfunction DeclaredPredicate(node) {\n    this.tokenChar(37);\n    this.word(\"checks\");\n    this.tokenChar(40);\n    this.print(node.value, node);\n    this.tokenChar(41);\n}\nfunction DeclareInterface(node) {\n    this.word(\"declare\");\n    this.space();\n    this.InterfaceDeclaration(node);\n}\nfunction DeclareModule(node) {\n    this.word(\"declare\");\n    this.space();\n    this.word(\"module\");\n    this.space();\n    this.print(node.id, node);\n    this.space();\n    this.print(node.body, node);\n}\nfunction DeclareModuleExports(node) {\n    this.word(\"declare\");\n    this.space();\n    this.word(\"module\");\n    this.tokenChar(46);\n    this.word(\"exports\");\n    this.print(node.typeAnnotation, node);\n}\nfunction DeclareTypeAlias(node) {\n    this.word(\"declare\");\n    this.space();\n    this.TypeAlias(node);\n}\nfunction DeclareOpaqueType(node, parent) {\n    if (!isDeclareExportDeclaration(parent)) {\n        this.word(\"declare\");\n        this.space();\n    }\n    this.OpaqueType(node);\n}\nfunction DeclareVariable(node, parent) {\n    if (!isDeclareExportDeclaration(parent)) {\n        this.word(\"declare\");\n        this.space();\n    }\n    this.word(\"var\");\n    this.space();\n    this.print(node.id, node);\n    this.print(node.id.typeAnnotation, node);\n    this.semicolon();\n}\nfunction DeclareExportDeclaration(node) {\n    this.word(\"declare\");\n    this.space();\n    this.word(\"export\");\n    this.space();\n    if (node.default) {\n        this.word(\"default\");\n        this.space();\n    }\n    FlowExportDeclaration.call(this, node);\n}\nfunction DeclareExportAllDeclaration(node) {\n    this.word(\"declare\");\n    this.space();\n    _modules.ExportAllDeclaration.call(this, node);\n}\nfunction EnumDeclaration(node) {\n    const { id, body } = node;\n    this.word(\"enum\");\n    this.space();\n    this.print(id, node);\n    this.print(body, node);\n}\nfunction enumExplicitType(context, name, hasExplicitType) {\n    if (hasExplicitType) {\n        context.space();\n        context.word(\"of\");\n        context.space();\n        context.word(name);\n    }\n    context.space();\n}\nfunction enumBody(context, node) {\n    const { members } = node;\n    context.token(\"{\");\n    context.indent();\n    context.newline();\n    for (const member of members){\n        context.print(member, node);\n        context.newline();\n    }\n    if (node.hasUnknownMembers) {\n        context.token(\"...\");\n        context.newline();\n    }\n    context.dedent();\n    context.token(\"}\");\n}\nfunction EnumBooleanBody(node) {\n    const { explicitType } = node;\n    enumExplicitType(this, \"boolean\", explicitType);\n    enumBody(this, node);\n}\nfunction EnumNumberBody(node) {\n    const { explicitType } = node;\n    enumExplicitType(this, \"number\", explicitType);\n    enumBody(this, node);\n}\nfunction EnumStringBody(node) {\n    const { explicitType } = node;\n    enumExplicitType(this, \"string\", explicitType);\n    enumBody(this, node);\n}\nfunction EnumSymbolBody(node) {\n    enumExplicitType(this, \"symbol\", true);\n    enumBody(this, node);\n}\nfunction EnumDefaultedMember(node) {\n    const { id } = node;\n    this.print(id, node);\n    this.tokenChar(44);\n}\nfunction enumInitializedMember(context, node) {\n    const { id, init } = node;\n    context.print(id, node);\n    context.space();\n    context.token(\"=\");\n    context.space();\n    context.print(init, node);\n    context.token(\",\");\n}\nfunction EnumBooleanMember(node) {\n    enumInitializedMember(this, node);\n}\nfunction EnumNumberMember(node) {\n    enumInitializedMember(this, node);\n}\nfunction EnumStringMember(node) {\n    enumInitializedMember(this, node);\n}\nfunction FlowExportDeclaration(node) {\n    if (node.declaration) {\n        const declar = node.declaration;\n        this.print(declar, node);\n        if (!isStatement(declar)) this.semicolon();\n    } else {\n        this.tokenChar(123);\n        if (node.specifiers.length) {\n            this.space();\n            this.printList(node.specifiers, node);\n            this.space();\n        }\n        this.tokenChar(125);\n        if (node.source) {\n            this.space();\n            this.word(\"from\");\n            this.space();\n            this.print(node.source, node);\n        }\n        this.semicolon();\n    }\n}\nfunction ExistsTypeAnnotation() {\n    this.tokenChar(42);\n}\nfunction FunctionTypeAnnotation(node, parent) {\n    this.print(node.typeParameters, node);\n    this.tokenChar(40);\n    if (node.this) {\n        this.word(\"this\");\n        this.tokenChar(58);\n        this.space();\n        this.print(node.this.typeAnnotation, node);\n        if (node.params.length || node.rest) {\n            this.tokenChar(44);\n            this.space();\n        }\n    }\n    this.printList(node.params, node);\n    if (node.rest) {\n        if (node.params.length) {\n            this.tokenChar(44);\n            this.space();\n        }\n        this.token(\"...\");\n        this.print(node.rest, node);\n    }\n    this.tokenChar(41);\n    const type = parent == null ? void 0 : parent.type;\n    if (type != null && (type === \"ObjectTypeCallProperty\" || type === \"ObjectTypeInternalSlot\" || type === \"DeclareFunction\" || type === \"ObjectTypeProperty\" && parent.method)) this.tokenChar(58);\n    else {\n        this.space();\n        this.token(\"=>\");\n    }\n    this.space();\n    this.print(node.returnType, node);\n}\nfunction FunctionTypeParam(node) {\n    this.print(node.name, node);\n    if (node.optional) this.tokenChar(63);\n    if (node.name) {\n        this.tokenChar(58);\n        this.space();\n    }\n    this.print(node.typeAnnotation, node);\n}\nfunction InterfaceExtends(node) {\n    this.print(node.id, node);\n    this.print(node.typeParameters, node, true);\n}\nfunction _interfaceish(node) {\n    var _node$extends;\n    this.print(node.id, node);\n    this.print(node.typeParameters, node);\n    if ((_node$extends = node.extends) != null && _node$extends.length) {\n        this.space();\n        this.word(\"extends\");\n        this.space();\n        this.printList(node.extends, node);\n    }\n    if (node.type === \"DeclareClass\") {\n        var _node$mixins, _node$implements;\n        if ((_node$mixins = node.mixins) != null && _node$mixins.length) {\n            this.space();\n            this.word(\"mixins\");\n            this.space();\n            this.printList(node.mixins, node);\n        }\n        if ((_node$implements = node.implements) != null && _node$implements.length) {\n            this.space();\n            this.word(\"implements\");\n            this.space();\n            this.printList(node.implements, node);\n        }\n    }\n    this.space();\n    this.print(node.body, node);\n}\nfunction _variance(node) {\n    var _node$variance;\n    const kind = (_node$variance = node.variance) == null ? void 0 : _node$variance.kind;\n    if (kind != null) {\n        if (kind === \"plus\") this.tokenChar(43);\n        else if (kind === \"minus\") this.tokenChar(45);\n    }\n}\nfunction InterfaceDeclaration(node) {\n    this.word(\"interface\");\n    this.space();\n    this._interfaceish(node);\n}\nfunction andSeparator() {\n    this.space();\n    this.tokenChar(38);\n    this.space();\n}\nfunction InterfaceTypeAnnotation(node) {\n    var _node$extends2;\n    this.word(\"interface\");\n    if ((_node$extends2 = node.extends) != null && _node$extends2.length) {\n        this.space();\n        this.word(\"extends\");\n        this.space();\n        this.printList(node.extends, node);\n    }\n    this.space();\n    this.print(node.body, node);\n}\nfunction IntersectionTypeAnnotation(node) {\n    this.printJoin(node.types, node, {\n        separator: andSeparator\n    });\n}\nfunction MixedTypeAnnotation() {\n    this.word(\"mixed\");\n}\nfunction EmptyTypeAnnotation() {\n    this.word(\"empty\");\n}\nfunction NullableTypeAnnotation(node) {\n    this.tokenChar(63);\n    this.print(node.typeAnnotation, node);\n}\nfunction NumberTypeAnnotation() {\n    this.word(\"number\");\n}\nfunction StringTypeAnnotation() {\n    this.word(\"string\");\n}\nfunction ThisTypeAnnotation() {\n    this.word(\"this\");\n}\nfunction TupleTypeAnnotation(node) {\n    this.tokenChar(91);\n    this.printList(node.types, node);\n    this.tokenChar(93);\n}\nfunction TypeofTypeAnnotation(node) {\n    this.word(\"typeof\");\n    this.space();\n    this.print(node.argument, node);\n}\nfunction TypeAlias(node) {\n    this.word(\"type\");\n    this.space();\n    this.print(node.id, node);\n    this.print(node.typeParameters, node);\n    this.space();\n    this.tokenChar(61);\n    this.space();\n    this.print(node.right, node);\n    this.semicolon();\n}\nfunction TypeAnnotation(node) {\n    this.tokenChar(58);\n    this.space();\n    if (node.optional) this.tokenChar(63);\n    this.print(node.typeAnnotation, node);\n}\nfunction TypeParameterInstantiation(node) {\n    this.tokenChar(60);\n    this.printList(node.params, node, {});\n    this.tokenChar(62);\n}\nfunction TypeParameter(node) {\n    this._variance(node);\n    this.word(node.name);\n    if (node.bound) this.print(node.bound, node);\n    if (node.default) {\n        this.space();\n        this.tokenChar(61);\n        this.space();\n        this.print(node.default, node);\n    }\n}\nfunction OpaqueType(node) {\n    this.word(\"opaque\");\n    this.space();\n    this.word(\"type\");\n    this.space();\n    this.print(node.id, node);\n    this.print(node.typeParameters, node);\n    if (node.supertype) {\n        this.tokenChar(58);\n        this.space();\n        this.print(node.supertype, node);\n    }\n    if (node.impltype) {\n        this.space();\n        this.tokenChar(61);\n        this.space();\n        this.print(node.impltype, node);\n    }\n    this.semicolon();\n}\nfunction ObjectTypeAnnotation(node) {\n    if (node.exact) this.token(\"{|\");\n    else this.tokenChar(123);\n    const props = [\n        ...node.properties,\n        ...node.callProperties || [],\n        ...node.indexers || [],\n        ...node.internalSlots || []\n    ];\n    if (props.length) {\n        this.newline();\n        this.space();\n        this.printJoin(props, node, {\n            addNewlines (leading) {\n                if (leading && !props[0]) return 1;\n            },\n            indent: true,\n            statement: true,\n            iterator: ()=>{\n                if (props.length !== 1 || node.inexact) {\n                    this.tokenChar(44);\n                    this.space();\n                }\n            }\n        });\n        this.space();\n    }\n    if (node.inexact) {\n        this.indent();\n        this.token(\"...\");\n        if (props.length) this.newline();\n        this.dedent();\n    }\n    if (node.exact) this.token(\"|}\");\n    else this.tokenChar(125);\n}\nfunction ObjectTypeInternalSlot(node) {\n    if (node.static) {\n        this.word(\"static\");\n        this.space();\n    }\n    this.tokenChar(91);\n    this.tokenChar(91);\n    this.print(node.id, node);\n    this.tokenChar(93);\n    this.tokenChar(93);\n    if (node.optional) this.tokenChar(63);\n    if (!node.method) {\n        this.tokenChar(58);\n        this.space();\n    }\n    this.print(node.value, node);\n}\nfunction ObjectTypeCallProperty(node) {\n    if (node.static) {\n        this.word(\"static\");\n        this.space();\n    }\n    this.print(node.value, node);\n}\nfunction ObjectTypeIndexer(node) {\n    if (node.static) {\n        this.word(\"static\");\n        this.space();\n    }\n    this._variance(node);\n    this.tokenChar(91);\n    if (node.id) {\n        this.print(node.id, node);\n        this.tokenChar(58);\n        this.space();\n    }\n    this.print(node.key, node);\n    this.tokenChar(93);\n    this.tokenChar(58);\n    this.space();\n    this.print(node.value, node);\n}\nfunction ObjectTypeProperty(node) {\n    if (node.proto) {\n        this.word(\"proto\");\n        this.space();\n    }\n    if (node.static) {\n        this.word(\"static\");\n        this.space();\n    }\n    if (node.kind === \"get\" || node.kind === \"set\") {\n        this.word(node.kind);\n        this.space();\n    }\n    this._variance(node);\n    this.print(node.key, node);\n    if (node.optional) this.tokenChar(63);\n    if (!node.method) {\n        this.tokenChar(58);\n        this.space();\n    }\n    this.print(node.value, node);\n}\nfunction ObjectTypeSpreadProperty(node) {\n    this.token(\"...\");\n    this.print(node.argument, node);\n}\nfunction QualifiedTypeIdentifier(node) {\n    this.print(node.qualification, node);\n    this.tokenChar(46);\n    this.print(node.id, node);\n}\nfunction SymbolTypeAnnotation() {\n    this.word(\"symbol\");\n}\nfunction orSeparator() {\n    this.space();\n    this.tokenChar(124);\n    this.space();\n}\nfunction UnionTypeAnnotation(node) {\n    this.printJoin(node.types, node, {\n        separator: orSeparator\n    });\n}\nfunction TypeCastExpression(node) {\n    this.tokenChar(40);\n    this.print(node.expression, node);\n    this.print(node.typeAnnotation, node);\n    this.tokenChar(41);\n}\nfunction Variance(node) {\n    if (node.kind === \"plus\") this.tokenChar(43);\n    else this.tokenChar(45);\n}\nfunction VoidTypeAnnotation() {\n    this.word(\"void\");\n}\nfunction IndexedAccessType(node) {\n    this.print(node.objectType, node, true);\n    this.tokenChar(91);\n    this.print(node.indexType, node);\n    this.tokenChar(93);\n}\nfunction OptionalIndexedAccessType(node) {\n    this.print(node.objectType, node);\n    if (node.optional) this.token(\"?.\");\n    this.tokenChar(91);\n    this.print(node.indexType, node);\n    this.tokenChar(93);\n}\n\n},{\"1f417b5d05be6092\":\"d4Ce7\",\"f19583aad5cac1e7\":\"j6uz3\",\"bd3412e910d75fb8\":\"aEbDj\"}],\"7XCFF\":[function(require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.BlockStatement = BlockStatement;\nexports.Directive = Directive;\nexports.DirectiveLiteral = DirectiveLiteral;\nexports.File = File;\nexports.InterpreterDirective = InterpreterDirective;\nexports.Placeholder = Placeholder;\nexports.Program = Program;\nfunction File(node) {\n    if (node.program) this.print(node.program.interpreter, node);\n    this.print(node.program, node);\n}\nfunction Program(node) {\n    var _node$directives;\n    this.noIndentInnerCommentsHere();\n    this.printInnerComments();\n    const directivesLen = (_node$directives = node.directives) == null ? void 0 : _node$directives.length;\n    if (directivesLen) {\n        var _node$directives$trai;\n        const newline = node.body.length ? 2 : 1;\n        this.printSequence(node.directives, node, {\n            trailingCommentsLineOffset: newline\n        });\n        if (!((_node$directives$trai = node.directives[directivesLen - 1].trailingComments) != null && _node$directives$trai.length)) this.newline(newline);\n    }\n    this.printSequence(node.body, node);\n}\nfunction BlockStatement(node) {\n    var _node$directives2;\n    this.tokenChar(123);\n    const directivesLen = (_node$directives2 = node.directives) == null ? void 0 : _node$directives2.length;\n    if (directivesLen) {\n        var _node$directives$trai2;\n        const newline = node.body.length ? 2 : 1;\n        this.printSequence(node.directives, node, {\n            indent: true,\n            trailingCommentsLineOffset: newline\n        });\n        if (!((_node$directives$trai2 = node.directives[directivesLen - 1].trailingComments) != null && _node$directives$trai2.length)) this.newline(newline);\n    }\n    this.printSequence(node.body, node, {\n        indent: true\n    });\n    this.rightBrace(node);\n}\nfunction Directive(node) {\n    this.print(node.value, node);\n    this.semicolon();\n}\nconst unescapedSingleQuoteRE = /(?:^|[^\\\\])(?:\\\\\\\\)*'/;\nconst unescapedDoubleQuoteRE = /(?:^|[^\\\\])(?:\\\\\\\\)*\"/;\nfunction DirectiveLiteral(node) {\n    const raw = this.getPossibleRaw(node);\n    if (!this.format.minified && raw !== undefined) {\n        this.token(raw);\n        return;\n    }\n    const { value } = node;\n    if (!unescapedDoubleQuoteRE.test(value)) this.token(`\"${value}\"`);\n    else if (!unescapedSingleQuoteRE.test(value)) this.token(`'${value}'`);\n    else throw new Error(\"Malformed AST: it is not possible to print a directive containing both unescaped single and double quotes.\");\n}\nfunction InterpreterDirective(node) {\n    this.token(`#!${node.value}`);\n    this.newline(1, true);\n}\nfunction Placeholder(node) {\n    this.token(\"%%\");\n    this.print(node.name);\n    this.token(\"%%\");\n    if (node.expectedNode === \"Statement\") this.semicolon();\n}\n\n},{}],\"2hieC\":[function(require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.JSXAttribute = JSXAttribute;\nexports.JSXClosingElement = JSXClosingElement;\nexports.JSXClosingFragment = JSXClosingFragment;\nexports.JSXElement = JSXElement;\nexports.JSXEmptyExpression = JSXEmptyExpression;\nexports.JSXExpressionContainer = JSXExpressionContainer;\nexports.JSXFragment = JSXFragment;\nexports.JSXIdentifier = JSXIdentifier;\nexports.JSXMemberExpression = JSXMemberExpression;\nexports.JSXNamespacedName = JSXNamespacedName;\nexports.JSXOpeningElement = JSXOpeningElement;\nexports.JSXOpeningFragment = JSXOpeningFragment;\nexports.JSXSpreadAttribute = JSXSpreadAttribute;\nexports.JSXSpreadChild = JSXSpreadChild;\nexports.JSXText = JSXText;\nfunction JSXAttribute(node) {\n    this.print(node.name, node);\n    if (node.value) {\n        this.tokenChar(61);\n        this.print(node.value, node);\n    }\n}\nfunction JSXIdentifier(node) {\n    this.word(node.name);\n}\nfunction JSXNamespacedName(node) {\n    this.print(node.namespace, node);\n    this.tokenChar(58);\n    this.print(node.name, node);\n}\nfunction JSXMemberExpression(node) {\n    this.print(node.object, node);\n    this.tokenChar(46);\n    this.print(node.property, node);\n}\nfunction JSXSpreadAttribute(node) {\n    this.tokenChar(123);\n    this.token(\"...\");\n    this.print(node.argument, node);\n    this.tokenChar(125);\n}\nfunction JSXExpressionContainer(node) {\n    this.tokenChar(123);\n    this.print(node.expression, node);\n    this.tokenChar(125);\n}\nfunction JSXSpreadChild(node) {\n    this.tokenChar(123);\n    this.token(\"...\");\n    this.print(node.expression, node);\n    this.tokenChar(125);\n}\nfunction JSXText(node) {\n    const raw = this.getPossibleRaw(node);\n    if (raw !== undefined) this.token(raw, true);\n    else this.token(node.value, true);\n}\nfunction JSXElement(node) {\n    const open = node.openingElement;\n    this.print(open, node);\n    if (open.selfClosing) return;\n    this.indent();\n    for (const child of node.children)this.print(child, node);\n    this.dedent();\n    this.print(node.closingElement, node);\n}\nfunction spaceSeparator() {\n    this.space();\n}\nfunction JSXOpeningElement(node) {\n    this.tokenChar(60);\n    this.print(node.name, node);\n    this.print(node.typeParameters, node);\n    if (node.attributes.length > 0) {\n        this.space();\n        this.printJoin(node.attributes, node, {\n            separator: spaceSeparator\n        });\n    }\n    if (node.selfClosing) {\n        this.space();\n        this.token(\"/>\");\n    } else this.tokenChar(62);\n}\nfunction JSXClosingElement(node) {\n    this.token(\"</\");\n    this.print(node.name, node);\n    this.tokenChar(62);\n}\nfunction JSXEmptyExpression() {\n    this.printInnerComments();\n}\nfunction JSXFragment(node) {\n    this.print(node.openingFragment, node);\n    this.indent();\n    for (const child of node.children)this.print(child, node);\n    this.dedent();\n    this.print(node.closingFragment, node);\n}\nfunction JSXOpeningFragment() {\n    this.tokenChar(60);\n    this.tokenChar(62);\n}\nfunction JSXClosingFragment() {\n    this.token(\"</\");\n    this.tokenChar(62);\n}\n\n},{}],\"kUGLL\":[function(require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.TSAnyKeyword = TSAnyKeyword;\nexports.TSArrayType = TSArrayType;\nexports.TSSatisfiesExpression = exports.TSAsExpression = TSTypeExpression;\nexports.TSBigIntKeyword = TSBigIntKeyword;\nexports.TSBooleanKeyword = TSBooleanKeyword;\nexports.TSCallSignatureDeclaration = TSCallSignatureDeclaration;\nexports.TSConditionalType = TSConditionalType;\nexports.TSConstructSignatureDeclaration = TSConstructSignatureDeclaration;\nexports.TSConstructorType = TSConstructorType;\nexports.TSDeclareFunction = TSDeclareFunction;\nexports.TSDeclareMethod = TSDeclareMethod;\nexports.TSEnumDeclaration = TSEnumDeclaration;\nexports.TSEnumMember = TSEnumMember;\nexports.TSExportAssignment = TSExportAssignment;\nexports.TSExpressionWithTypeArguments = TSExpressionWithTypeArguments;\nexports.TSExternalModuleReference = TSExternalModuleReference;\nexports.TSFunctionType = TSFunctionType;\nexports.TSImportEqualsDeclaration = TSImportEqualsDeclaration;\nexports.TSImportType = TSImportType;\nexports.TSIndexSignature = TSIndexSignature;\nexports.TSIndexedAccessType = TSIndexedAccessType;\nexports.TSInferType = TSInferType;\nexports.TSInstantiationExpression = TSInstantiationExpression;\nexports.TSInterfaceBody = TSInterfaceBody;\nexports.TSInterfaceDeclaration = TSInterfaceDeclaration;\nexports.TSIntersectionType = TSIntersectionType;\nexports.TSIntrinsicKeyword = TSIntrinsicKeyword;\nexports.TSLiteralType = TSLiteralType;\nexports.TSMappedType = TSMappedType;\nexports.TSMethodSignature = TSMethodSignature;\nexports.TSModuleBlock = TSModuleBlock;\nexports.TSModuleDeclaration = TSModuleDeclaration;\nexports.TSNamedTupleMember = TSNamedTupleMember;\nexports.TSNamespaceExportDeclaration = TSNamespaceExportDeclaration;\nexports.TSNeverKeyword = TSNeverKeyword;\nexports.TSNonNullExpression = TSNonNullExpression;\nexports.TSNullKeyword = TSNullKeyword;\nexports.TSNumberKeyword = TSNumberKeyword;\nexports.TSObjectKeyword = TSObjectKeyword;\nexports.TSOptionalType = TSOptionalType;\nexports.TSParameterProperty = TSParameterProperty;\nexports.TSParenthesizedType = TSParenthesizedType;\nexports.TSPropertySignature = TSPropertySignature;\nexports.TSQualifiedName = TSQualifiedName;\nexports.TSRestType = TSRestType;\nexports.TSStringKeyword = TSStringKeyword;\nexports.TSSymbolKeyword = TSSymbolKeyword;\nexports.TSThisType = TSThisType;\nexports.TSTupleType = TSTupleType;\nexports.TSTypeAliasDeclaration = TSTypeAliasDeclaration;\nexports.TSTypeAnnotation = TSTypeAnnotation;\nexports.TSTypeAssertion = TSTypeAssertion;\nexports.TSTypeLiteral = TSTypeLiteral;\nexports.TSTypeOperator = TSTypeOperator;\nexports.TSTypeParameter = TSTypeParameter;\nexports.TSTypeParameterDeclaration = exports.TSTypeParameterInstantiation = TSTypeParameterInstantiation;\nexports.TSTypePredicate = TSTypePredicate;\nexports.TSTypeQuery = TSTypeQuery;\nexports.TSTypeReference = TSTypeReference;\nexports.TSUndefinedKeyword = TSUndefinedKeyword;\nexports.TSUnionType = TSUnionType;\nexports.TSUnknownKeyword = TSUnknownKeyword;\nexports.TSVoidKeyword = TSVoidKeyword;\nexports.tsPrintClassMemberModifiers = tsPrintClassMemberModifiers;\nexports.tsPrintFunctionOrConstructorType = tsPrintFunctionOrConstructorType;\nexports.tsPrintPropertyOrMethodName = tsPrintPropertyOrMethodName;\nexports.tsPrintSignatureDeclarationBase = tsPrintSignatureDeclarationBase;\nexports.tsPrintTypeLiteralOrInterfaceBody = tsPrintTypeLiteralOrInterfaceBody;\nfunction TSTypeAnnotation(node) {\n    this.tokenChar(58);\n    this.space();\n    if (node.optional) this.tokenChar(63);\n    this.print(node.typeAnnotation, node);\n}\nfunction TSTypeParameterInstantiation(node, parent) {\n    this.tokenChar(60);\n    this.printList(node.params, node, {});\n    if (parent.type === \"ArrowFunctionExpression\" && node.params.length === 1) this.tokenChar(44);\n    this.tokenChar(62);\n}\nfunction TSTypeParameter(node) {\n    if (node.in) {\n        this.word(\"in\");\n        this.space();\n    }\n    if (node.out) {\n        this.word(\"out\");\n        this.space();\n    }\n    this.word(node.name);\n    if (node.constraint) {\n        this.space();\n        this.word(\"extends\");\n        this.space();\n        this.print(node.constraint, node);\n    }\n    if (node.default) {\n        this.space();\n        this.tokenChar(61);\n        this.space();\n        this.print(node.default, node);\n    }\n}\nfunction TSParameterProperty(node) {\n    if (node.accessibility) {\n        this.word(node.accessibility);\n        this.space();\n    }\n    if (node.readonly) {\n        this.word(\"readonly\");\n        this.space();\n    }\n    this._param(node.parameter);\n}\nfunction TSDeclareFunction(node, parent) {\n    if (node.declare) {\n        this.word(\"declare\");\n        this.space();\n    }\n    this._functionHead(node, parent);\n    this.tokenChar(59);\n}\nfunction TSDeclareMethod(node) {\n    this._classMethodHead(node);\n    this.tokenChar(59);\n}\nfunction TSQualifiedName(node) {\n    this.print(node.left, node);\n    this.tokenChar(46);\n    this.print(node.right, node);\n}\nfunction TSCallSignatureDeclaration(node) {\n    this.tsPrintSignatureDeclarationBase(node);\n    this.tokenChar(59);\n}\nfunction TSConstructSignatureDeclaration(node) {\n    this.word(\"new\");\n    this.space();\n    this.tsPrintSignatureDeclarationBase(node);\n    this.tokenChar(59);\n}\nfunction TSPropertySignature(node) {\n    const { readonly, initializer } = node;\n    if (readonly) {\n        this.word(\"readonly\");\n        this.space();\n    }\n    this.tsPrintPropertyOrMethodName(node);\n    this.print(node.typeAnnotation, node);\n    if (initializer) {\n        this.space();\n        this.tokenChar(61);\n        this.space();\n        this.print(initializer, node);\n    }\n    this.tokenChar(59);\n}\nfunction tsPrintPropertyOrMethodName(node) {\n    if (node.computed) this.tokenChar(91);\n    this.print(node.key, node);\n    if (node.computed) this.tokenChar(93);\n    if (node.optional) this.tokenChar(63);\n}\nfunction TSMethodSignature(node) {\n    const { kind } = node;\n    if (kind === \"set\" || kind === \"get\") {\n        this.word(kind);\n        this.space();\n    }\n    this.tsPrintPropertyOrMethodName(node);\n    this.tsPrintSignatureDeclarationBase(node);\n    this.tokenChar(59);\n}\nfunction TSIndexSignature(node) {\n    const { readonly, static: isStatic } = node;\n    if (isStatic) {\n        this.word(\"static\");\n        this.space();\n    }\n    if (readonly) {\n        this.word(\"readonly\");\n        this.space();\n    }\n    this.tokenChar(91);\n    this._parameters(node.parameters, node);\n    this.tokenChar(93);\n    this.print(node.typeAnnotation, node);\n    this.tokenChar(59);\n}\nfunction TSAnyKeyword() {\n    this.word(\"any\");\n}\nfunction TSBigIntKeyword() {\n    this.word(\"bigint\");\n}\nfunction TSUnknownKeyword() {\n    this.word(\"unknown\");\n}\nfunction TSNumberKeyword() {\n    this.word(\"number\");\n}\nfunction TSObjectKeyword() {\n    this.word(\"object\");\n}\nfunction TSBooleanKeyword() {\n    this.word(\"boolean\");\n}\nfunction TSStringKeyword() {\n    this.word(\"string\");\n}\nfunction TSSymbolKeyword() {\n    this.word(\"symbol\");\n}\nfunction TSVoidKeyword() {\n    this.word(\"void\");\n}\nfunction TSUndefinedKeyword() {\n    this.word(\"undefined\");\n}\nfunction TSNullKeyword() {\n    this.word(\"null\");\n}\nfunction TSNeverKeyword() {\n    this.word(\"never\");\n}\nfunction TSIntrinsicKeyword() {\n    this.word(\"intrinsic\");\n}\nfunction TSThisType() {\n    this.word(\"this\");\n}\nfunction TSFunctionType(node) {\n    this.tsPrintFunctionOrConstructorType(node);\n}\nfunction TSConstructorType(node) {\n    if (node.abstract) {\n        this.word(\"abstract\");\n        this.space();\n    }\n    this.word(\"new\");\n    this.space();\n    this.tsPrintFunctionOrConstructorType(node);\n}\nfunction tsPrintFunctionOrConstructorType(node) {\n    const { typeParameters } = node;\n    const parameters = node.parameters;\n    this.print(typeParameters, node);\n    this.tokenChar(40);\n    this._parameters(parameters, node);\n    this.tokenChar(41);\n    this.space();\n    this.token(\"=>\");\n    this.space();\n    const returnType = node.typeAnnotation;\n    this.print(returnType.typeAnnotation, node);\n}\nfunction TSTypeReference(node) {\n    this.print(node.typeName, node, true);\n    this.print(node.typeParameters, node, true);\n}\nfunction TSTypePredicate(node) {\n    if (node.asserts) {\n        this.word(\"asserts\");\n        this.space();\n    }\n    this.print(node.parameterName);\n    if (node.typeAnnotation) {\n        this.space();\n        this.word(\"is\");\n        this.space();\n        this.print(node.typeAnnotation.typeAnnotation);\n    }\n}\nfunction TSTypeQuery(node) {\n    this.word(\"typeof\");\n    this.space();\n    this.print(node.exprName);\n    if (node.typeParameters) this.print(node.typeParameters, node);\n}\nfunction TSTypeLiteral(node) {\n    this.tsPrintTypeLiteralOrInterfaceBody(node.members, node);\n}\nfunction tsPrintTypeLiteralOrInterfaceBody(members, node) {\n    tsPrintBraced(this, members, node);\n}\nfunction tsPrintBraced(printer, members, node) {\n    printer.token(\"{\");\n    if (members.length) {\n        printer.indent();\n        printer.newline();\n        for (const member of members){\n            printer.print(member, node);\n            printer.newline();\n        }\n        printer.dedent();\n    }\n    printer.rightBrace(node);\n}\nfunction TSArrayType(node) {\n    this.print(node.elementType, node, true);\n    this.token(\"[]\");\n}\nfunction TSTupleType(node) {\n    this.tokenChar(91);\n    this.printList(node.elementTypes, node);\n    this.tokenChar(93);\n}\nfunction TSOptionalType(node) {\n    this.print(node.typeAnnotation, node);\n    this.tokenChar(63);\n}\nfunction TSRestType(node) {\n    this.token(\"...\");\n    this.print(node.typeAnnotation, node);\n}\nfunction TSNamedTupleMember(node) {\n    this.print(node.label, node);\n    if (node.optional) this.tokenChar(63);\n    this.tokenChar(58);\n    this.space();\n    this.print(node.elementType, node);\n}\nfunction TSUnionType(node) {\n    tsPrintUnionOrIntersectionType(this, node, \"|\");\n}\nfunction TSIntersectionType(node) {\n    tsPrintUnionOrIntersectionType(this, node, \"&\");\n}\nfunction tsPrintUnionOrIntersectionType(printer, node, sep) {\n    printer.printJoin(node.types, node, {\n        separator () {\n            this.space();\n            this.token(sep);\n            this.space();\n        }\n    });\n}\nfunction TSConditionalType(node) {\n    this.print(node.checkType);\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.print(node.extendsType);\n    this.space();\n    this.tokenChar(63);\n    this.space();\n    this.print(node.trueType);\n    this.space();\n    this.tokenChar(58);\n    this.space();\n    this.print(node.falseType);\n}\nfunction TSInferType(node) {\n    this.token(\"infer\");\n    this.space();\n    this.print(node.typeParameter);\n}\nfunction TSParenthesizedType(node) {\n    this.tokenChar(40);\n    this.print(node.typeAnnotation, node);\n    this.tokenChar(41);\n}\nfunction TSTypeOperator(node) {\n    this.word(node.operator);\n    this.space();\n    this.print(node.typeAnnotation, node);\n}\nfunction TSIndexedAccessType(node) {\n    this.print(node.objectType, node, true);\n    this.tokenChar(91);\n    this.print(node.indexType, node);\n    this.tokenChar(93);\n}\nfunction TSMappedType(node) {\n    const { nameType, optional, readonly, typeParameter } = node;\n    this.tokenChar(123);\n    this.space();\n    if (readonly) {\n        tokenIfPlusMinus(this, readonly);\n        this.word(\"readonly\");\n        this.space();\n    }\n    this.tokenChar(91);\n    this.word(typeParameter.name);\n    this.space();\n    this.word(\"in\");\n    this.space();\n    this.print(typeParameter.constraint, typeParameter);\n    if (nameType) {\n        this.space();\n        this.word(\"as\");\n        this.space();\n        this.print(nameType, node);\n    }\n    this.tokenChar(93);\n    if (optional) {\n        tokenIfPlusMinus(this, optional);\n        this.tokenChar(63);\n    }\n    this.tokenChar(58);\n    this.space();\n    this.print(node.typeAnnotation, node);\n    this.space();\n    this.tokenChar(125);\n}\nfunction tokenIfPlusMinus(self, tok) {\n    if (tok !== true) self.token(tok);\n}\nfunction TSLiteralType(node) {\n    this.print(node.literal, node);\n}\nfunction TSExpressionWithTypeArguments(node) {\n    this.print(node.expression, node);\n    this.print(node.typeParameters, node);\n}\nfunction TSInterfaceDeclaration(node) {\n    const { declare, id, typeParameters, extends: extendz, body } = node;\n    if (declare) {\n        this.word(\"declare\");\n        this.space();\n    }\n    this.word(\"interface\");\n    this.space();\n    this.print(id, node);\n    this.print(typeParameters, node);\n    if (extendz != null && extendz.length) {\n        this.space();\n        this.word(\"extends\");\n        this.space();\n        this.printList(extendz, node);\n    }\n    this.space();\n    this.print(body, node);\n}\nfunction TSInterfaceBody(node) {\n    this.tsPrintTypeLiteralOrInterfaceBody(node.body, node);\n}\nfunction TSTypeAliasDeclaration(node) {\n    const { declare, id, typeParameters, typeAnnotation } = node;\n    if (declare) {\n        this.word(\"declare\");\n        this.space();\n    }\n    this.word(\"type\");\n    this.space();\n    this.print(id, node);\n    this.print(typeParameters, node);\n    this.space();\n    this.tokenChar(61);\n    this.space();\n    this.print(typeAnnotation, node);\n    this.tokenChar(59);\n}\nfunction TSTypeExpression(node) {\n    var _expression$trailingC;\n    const { type, expression, typeAnnotation } = node;\n    const forceParens = !!((_expression$trailingC = expression.trailingComments) != null && _expression$trailingC.length);\n    this.print(expression, node, true, undefined, forceParens);\n    this.space();\n    this.word(type === \"TSAsExpression\" ? \"as\" : \"satisfies\");\n    this.space();\n    this.print(typeAnnotation, node);\n}\nfunction TSTypeAssertion(node) {\n    const { typeAnnotation, expression } = node;\n    this.tokenChar(60);\n    this.print(typeAnnotation, node);\n    this.tokenChar(62);\n    this.space();\n    this.print(expression, node);\n}\nfunction TSInstantiationExpression(node) {\n    this.print(node.expression, node);\n    this.print(node.typeParameters, node);\n}\nfunction TSEnumDeclaration(node) {\n    const { declare, const: isConst, id, members } = node;\n    if (declare) {\n        this.word(\"declare\");\n        this.space();\n    }\n    if (isConst) {\n        this.word(\"const\");\n        this.space();\n    }\n    this.word(\"enum\");\n    this.space();\n    this.print(id, node);\n    this.space();\n    tsPrintBraced(this, members, node);\n}\nfunction TSEnumMember(node) {\n    const { id, initializer } = node;\n    this.print(id, node);\n    if (initializer) {\n        this.space();\n        this.tokenChar(61);\n        this.space();\n        this.print(initializer, node);\n    }\n    this.tokenChar(44);\n}\nfunction TSModuleDeclaration(node) {\n    const { declare, id } = node;\n    if (declare) {\n        this.word(\"declare\");\n        this.space();\n    }\n    if (!node.global) {\n        this.word(id.type === \"Identifier\" ? \"namespace\" : \"module\");\n        this.space();\n    }\n    this.print(id, node);\n    if (!node.body) {\n        this.tokenChar(59);\n        return;\n    }\n    let body = node.body;\n    while(body.type === \"TSModuleDeclaration\"){\n        this.tokenChar(46);\n        this.print(body.id, body);\n        body = body.body;\n    }\n    this.space();\n    this.print(body, node);\n}\nfunction TSModuleBlock(node) {\n    tsPrintBraced(this, node.body, node);\n}\nfunction TSImportType(node) {\n    const { argument, qualifier, typeParameters } = node;\n    this.word(\"import\");\n    this.tokenChar(40);\n    this.print(argument, node);\n    this.tokenChar(41);\n    if (qualifier) {\n        this.tokenChar(46);\n        this.print(qualifier, node);\n    }\n    if (typeParameters) this.print(typeParameters, node);\n}\nfunction TSImportEqualsDeclaration(node) {\n    const { isExport, id, moduleReference } = node;\n    if (isExport) {\n        this.word(\"export\");\n        this.space();\n    }\n    this.word(\"import\");\n    this.space();\n    this.print(id, node);\n    this.space();\n    this.tokenChar(61);\n    this.space();\n    this.print(moduleReference, node);\n    this.tokenChar(59);\n}\nfunction TSExternalModuleReference(node) {\n    this.token(\"require(\");\n    this.print(node.expression, node);\n    this.tokenChar(41);\n}\nfunction TSNonNullExpression(node) {\n    this.print(node.expression, node);\n    this.tokenChar(33);\n}\nfunction TSExportAssignment(node) {\n    this.word(\"export\");\n    this.space();\n    this.tokenChar(61);\n    this.space();\n    this.print(node.expression, node);\n    this.tokenChar(59);\n}\nfunction TSNamespaceExportDeclaration(node) {\n    this.word(\"export\");\n    this.space();\n    this.word(\"as\");\n    this.space();\n    this.word(\"namespace\");\n    this.space();\n    this.print(node.id, node);\n}\nfunction tsPrintSignatureDeclarationBase(node) {\n    const { typeParameters } = node;\n    const parameters = node.parameters;\n    this.print(typeParameters, node);\n    this.tokenChar(40);\n    this._parameters(parameters, node);\n    this.tokenChar(41);\n    const returnType = node.typeAnnotation;\n    this.print(returnType, node);\n}\nfunction tsPrintClassMemberModifiers(node) {\n    const isField = node.type === \"ClassAccessorProperty\" || node.type === \"ClassProperty\";\n    if (isField && node.declare) {\n        this.word(\"declare\");\n        this.space();\n    }\n    if (node.accessibility) {\n        this.word(node.accessibility);\n        this.space();\n    }\n    if (node.static) {\n        this.word(\"static\");\n        this.space();\n    }\n    if (node.override) {\n        this.word(\"override\");\n        this.space();\n    }\n    if (node.abstract) {\n        this.word(\"abstract\");\n        this.space();\n    }\n    if (isField && node.readonly) {\n        this.word(\"readonly\");\n        this.space();\n    }\n}\n\n},{}],\"ay6Km\":[function(require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"ImportInjector\", {\n    enumerable: true,\n    get: function() {\n        return _importInjector.default;\n    }\n});\nexports.addDefault = addDefault;\nexports.addNamed = addNamed;\nexports.addNamespace = addNamespace;\nexports.addSideEffect = addSideEffect;\nObject.defineProperty(exports, \"isModule\", {\n    enumerable: true,\n    get: function() {\n        return _isModule.default;\n    }\n});\nvar _importInjector = require(\"96b0eed29914dafc\");\nvar _isModule = require(\"9c221136987b978a\");\nfunction addDefault(path, importedSource, opts) {\n    return new _importInjector.default(path).addDefault(importedSource, opts);\n}\nfunction addNamed(path, name, importedSource, opts) {\n    return new _importInjector.default(path).addNamed(name, importedSource, opts);\n}\nfunction addNamespace(path, importedSource, opts) {\n    return new _importInjector.default(path).addNamespace(importedSource, opts);\n}\nfunction addSideEffect(path, importedSource, opts) {\n    return new _importInjector.default(path).addSideEffect(importedSource, opts);\n}\n\n},{\"96b0eed29914dafc\":\"f8Zd2\",\"9c221136987b978a\":\"cCicD\"}],\"f8Zd2\":[function(require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = void 0;\nvar _assert = require(\"c7efe450bba07476\");\nvar _t = require(\"d3f825c26a210239\");\nvar _importBuilder = require(\"e3e40aa6bb08370a\");\nvar _isModule = require(\"6b43a34733136215\");\nconst { numericLiteral, sequenceExpression } = _t;\nclass ImportInjector {\n    constructor(path, importedSource, opts){\n        this._defaultOpts = {\n            importedSource: null,\n            importedType: \"commonjs\",\n            importedInterop: \"babel\",\n            importingInterop: \"babel\",\n            ensureLiveReference: false,\n            ensureNoContext: false,\n            importPosition: \"before\"\n        };\n        const programPath = path.find((p)=>p.isProgram());\n        this._programPath = programPath;\n        this._programScope = programPath.scope;\n        this._hub = programPath.hub;\n        this._defaultOpts = this._applyDefaults(importedSource, opts, true);\n    }\n    addDefault(importedSourceIn, opts) {\n        return this.addNamed(\"default\", importedSourceIn, opts);\n    }\n    addNamed(importName, importedSourceIn, opts) {\n        _assert(typeof importName === \"string\");\n        return this._generateImport(this._applyDefaults(importedSourceIn, opts), importName);\n    }\n    addNamespace(importedSourceIn, opts) {\n        return this._generateImport(this._applyDefaults(importedSourceIn, opts), null);\n    }\n    addSideEffect(importedSourceIn, opts) {\n        return this._generateImport(this._applyDefaults(importedSourceIn, opts), void 0);\n    }\n    _applyDefaults(importedSource, opts, isInit = false) {\n        let newOpts;\n        if (typeof importedSource === \"string\") newOpts = Object.assign({}, this._defaultOpts, {\n            importedSource\n        }, opts);\n        else {\n            _assert(!opts, \"Unexpected secondary arguments.\");\n            newOpts = Object.assign({}, this._defaultOpts, importedSource);\n        }\n        if (!isInit && opts) {\n            if (opts.nameHint !== undefined) newOpts.nameHint = opts.nameHint;\n            if (opts.blockHoist !== undefined) newOpts.blockHoist = opts.blockHoist;\n        }\n        return newOpts;\n    }\n    _generateImport(opts, importName) {\n        const isDefault = importName === \"default\";\n        const isNamed = !!importName && !isDefault;\n        const isNamespace = importName === null;\n        const { importedSource, importedType, importedInterop, importingInterop, ensureLiveReference, ensureNoContext, nameHint, importPosition, blockHoist } = opts;\n        let name = nameHint || importName;\n        const isMod = (0, _isModule.default)(this._programPath);\n        const isModuleForNode = isMod && importingInterop === \"node\";\n        const isModuleForBabel = isMod && importingInterop === \"babel\";\n        if (importPosition === \"after\" && !isMod) throw new Error(`\"importPosition\": \"after\" is only supported in modules`);\n        const builder = new _importBuilder.default(importedSource, this._programScope, this._hub);\n        if (importedType === \"es6\") {\n            if (!isModuleForNode && !isModuleForBabel) throw new Error(\"Cannot import an ES6 module from CommonJS\");\n            builder.import();\n            if (isNamespace) builder.namespace(nameHint || importedSource);\n            else if (isDefault || isNamed) builder.named(name, importName);\n        } else if (importedType !== \"commonjs\") throw new Error(`Unexpected interopType \"${importedType}\"`);\n        else if (importedInterop === \"babel\") {\n            if (isModuleForNode) {\n                name = name !== \"default\" ? name : importedSource;\n                const es6Default = `${importedSource}$es6Default`;\n                builder.import();\n                if (isNamespace) builder.default(es6Default).var(name || importedSource).wildcardInterop();\n                else if (isDefault) {\n                    if (ensureLiveReference) builder.default(es6Default).var(name || importedSource).defaultInterop().read(\"default\");\n                    else builder.default(es6Default).var(name).defaultInterop().prop(importName);\n                } else if (isNamed) builder.default(es6Default).read(importName);\n            } else if (isModuleForBabel) {\n                builder.import();\n                if (isNamespace) builder.namespace(name || importedSource);\n                else if (isDefault || isNamed) builder.named(name, importName);\n            } else {\n                builder.require();\n                if (isNamespace) builder.var(name || importedSource).wildcardInterop();\n                else if ((isDefault || isNamed) && ensureLiveReference) {\n                    if (isDefault) {\n                        name = name !== \"default\" ? name : importedSource;\n                        builder.var(name).read(importName);\n                        builder.defaultInterop();\n                    } else builder.var(importedSource).read(importName);\n                } else if (isDefault) builder.var(name).defaultInterop().prop(importName);\n                else if (isNamed) builder.var(name).prop(importName);\n            }\n        } else if (importedInterop === \"compiled\") {\n            if (isModuleForNode) {\n                builder.import();\n                if (isNamespace) builder.default(name || importedSource);\n                else if (isDefault || isNamed) builder.default(importedSource).read(name);\n            } else if (isModuleForBabel) {\n                builder.import();\n                if (isNamespace) builder.namespace(name || importedSource);\n                else if (isDefault || isNamed) builder.named(name, importName);\n            } else {\n                builder.require();\n                if (isNamespace) builder.var(name || importedSource);\n                else if (isDefault || isNamed) {\n                    if (ensureLiveReference) builder.var(importedSource).read(name);\n                    else builder.prop(importName).var(name);\n                }\n            }\n        } else if (importedInterop === \"uncompiled\") {\n            if (isDefault && ensureLiveReference) throw new Error(\"No live reference for commonjs default\");\n            if (isModuleForNode) {\n                builder.import();\n                if (isNamespace) builder.default(name || importedSource);\n                else if (isDefault) builder.default(name);\n                else if (isNamed) builder.default(importedSource).read(name);\n            } else if (isModuleForBabel) {\n                builder.import();\n                if (isNamespace) builder.default(name || importedSource);\n                else if (isDefault) builder.default(name);\n                else if (isNamed) builder.named(name, importName);\n            } else {\n                builder.require();\n                if (isNamespace) builder.var(name || importedSource);\n                else if (isDefault) builder.var(name);\n                else if (isNamed) {\n                    if (ensureLiveReference) builder.var(importedSource).read(name);\n                    else builder.var(name).prop(importName);\n                }\n            }\n        } else throw new Error(`Unknown importedInterop \"${importedInterop}\".`);\n        const { statements, resultName } = builder.done();\n        this._insertStatements(statements, importPosition, blockHoist);\n        if ((isDefault || isNamed) && ensureNoContext && resultName.type !== \"Identifier\") return sequenceExpression([\n            numericLiteral(0),\n            resultName\n        ]);\n        return resultName;\n    }\n    _insertStatements(statements, importPosition = \"before\", blockHoist = 3) {\n        const body = this._programPath.get(\"body\");\n        if (importPosition === \"after\") {\n            for(let i = body.length - 1; i >= 0; i--)if (body[i].isImportDeclaration()) {\n                body[i].insertAfter(statements);\n                return;\n            }\n        } else {\n            statements.forEach((node)=>{\n                node._blockHoist = blockHoist;\n            });\n            const targetPath = body.find((p)=>{\n                const val = p.node._blockHoist;\n                return Number.isFinite(val) && val < 4;\n            });\n            if (targetPath) {\n                targetPath.insertBefore(statements);\n                return;\n            }\n        }\n        this._programPath.unshiftContainer(\"body\", statements);\n    }\n}\nexports.default = ImportInjector;\n\n},{\"c7efe450bba07476\":\"ddnVl\",\"d3f825c26a210239\":\"d4Ce7\",\"e3e40aa6bb08370a\":\"bLbSy\",\"6b43a34733136215\":\"cCicD\"}],\"bLbSy\":[function(require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = void 0;\nvar _assert = require(\"901e08c395d06e2e\");\nvar _t = require(\"a944f7f5b8b02f10\");\nconst { callExpression, cloneNode, expressionStatement, identifier, importDeclaration, importDefaultSpecifier, importNamespaceSpecifier, importSpecifier, memberExpression, stringLiteral, variableDeclaration, variableDeclarator } = _t;\nclass ImportBuilder {\n    constructor(importedSource, scope, hub){\n        this._statements = [];\n        this._resultName = null;\n        this._importedSource = void 0;\n        this._scope = scope;\n        this._hub = hub;\n        this._importedSource = importedSource;\n    }\n    done() {\n        return {\n            statements: this._statements,\n            resultName: this._resultName\n        };\n    }\n    import() {\n        this._statements.push(importDeclaration([], stringLiteral(this._importedSource)));\n        return this;\n    }\n    require() {\n        this._statements.push(expressionStatement(callExpression(identifier(\"require\"), [\n            stringLiteral(this._importedSource)\n        ])));\n        return this;\n    }\n    namespace(name = \"namespace\") {\n        const local = this._scope.generateUidIdentifier(name);\n        const statement = this._statements[this._statements.length - 1];\n        _assert(statement.type === \"ImportDeclaration\");\n        _assert(statement.specifiers.length === 0);\n        statement.specifiers = [\n            importNamespaceSpecifier(local)\n        ];\n        this._resultName = cloneNode(local);\n        return this;\n    }\n    default(name) {\n        const id = this._scope.generateUidIdentifier(name);\n        const statement = this._statements[this._statements.length - 1];\n        _assert(statement.type === \"ImportDeclaration\");\n        _assert(statement.specifiers.length === 0);\n        statement.specifiers = [\n            importDefaultSpecifier(id)\n        ];\n        this._resultName = cloneNode(id);\n        return this;\n    }\n    named(name, importName) {\n        if (importName === \"default\") return this.default(name);\n        const id = this._scope.generateUidIdentifier(name);\n        const statement = this._statements[this._statements.length - 1];\n        _assert(statement.type === \"ImportDeclaration\");\n        _assert(statement.specifiers.length === 0);\n        statement.specifiers = [\n            importSpecifier(id, identifier(importName))\n        ];\n        this._resultName = cloneNode(id);\n        return this;\n    }\n    var(name) {\n        const id = this._scope.generateUidIdentifier(name);\n        let statement = this._statements[this._statements.length - 1];\n        if (statement.type !== \"ExpressionStatement\") {\n            _assert(this._resultName);\n            statement = expressionStatement(this._resultName);\n            this._statements.push(statement);\n        }\n        this._statements[this._statements.length - 1] = variableDeclaration(\"var\", [\n            variableDeclarator(id, statement.expression)\n        ]);\n        this._resultName = cloneNode(id);\n        return this;\n    }\n    defaultInterop() {\n        return this._interop(this._hub.addHelper(\"interopRequireDefault\"));\n    }\n    wildcardInterop() {\n        return this._interop(this._hub.addHelper(\"interopRequireWildcard\"));\n    }\n    _interop(callee) {\n        const statement = this._statements[this._statements.length - 1];\n        if (statement.type === \"ExpressionStatement\") statement.expression = callExpression(callee, [\n            statement.expression\n        ]);\n        else if (statement.type === \"VariableDeclaration\") {\n            _assert(statement.declarations.length === 1);\n            statement.declarations[0].init = callExpression(callee, [\n                statement.declarations[0].init\n            ]);\n        } else _assert.fail(\"Unexpected type.\");\n        return this;\n    }\n    prop(name) {\n        const statement = this._statements[this._statements.length - 1];\n        if (statement.type === \"ExpressionStatement\") statement.expression = memberExpression(statement.expression, identifier(name));\n        else if (statement.type === \"VariableDeclaration\") {\n            _assert(statement.declarations.length === 1);\n            statement.declarations[0].init = memberExpression(statement.declarations[0].init, identifier(name));\n        } else _assert.fail(\"Unexpected type:\" + statement.type);\n        return this;\n    }\n    read(name) {\n        this._resultName = memberExpression(this._resultName, identifier(name));\n    }\n}\nexports.default = ImportBuilder;\n\n},{\"901e08c395d06e2e\":\"ddnVl\",\"a944f7f5b8b02f10\":\"d4Ce7\"}],\"cCicD\":[function(require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = isModule;\nfunction isModule(path) {\n    return path.node.sourceType === \"module\";\n}\n\n},{}]},[], null, \"parcelRequire4ef6\")\n\n//# sourceMappingURL=babel.5fb614ff.js.map\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CodeGenerator = void 0;\nexports.default = generate;\nvar _sourceMap = require(\"./source-map.js\");\nvar _printer = require(\"./printer.js\");\nclass Generator extends _printer.default {\n  constructor(ast, opts = {}, code) {\n    const format = normalizeOptions(code, opts);\n    const map = opts.sourceMaps ? new _sourceMap.default(opts, code) : null;\n    super(format, map);\n    this.ast = void 0;\n    this.ast = ast;\n  }\n  generate() {\n    return super.generate(this.ast);\n  }\n}\nfunction normalizeOptions(code, opts) {\n  var _opts$recordAndTupleS;\n  const format = {\n    auxiliaryCommentBefore: opts.auxiliaryCommentBefore,\n    auxiliaryCommentAfter: opts.auxiliaryCommentAfter,\n    shouldPrintComment: opts.shouldPrintComment,\n    retainLines: opts.retainLines,\n    retainFunctionParens: opts.retainFunctionParens,\n    comments: opts.comments == null || opts.comments,\n    compact: opts.compact,\n    minified: opts.minified,\n    concise: opts.concise,\n    indent: {\n      adjustMultilineComment: true,\n      style: \"  \"\n    },\n    jsescOption: Object.assign({\n      quotes: \"double\",\n      wrap: true,\n      minimal: false\n    }, opts.jsescOption),\n    recordAndTupleSyntaxType: (_opts$recordAndTupleS = opts.recordAndTupleSyntaxType) != null ? _opts$recordAndTupleS : \"hash\",\n    topicToken: opts.topicToken,\n    importAttributesKeyword: opts.importAttributesKeyword\n  };\n  {\n    format.decoratorsBeforeExport = opts.decoratorsBeforeExport;\n    format.jsescOption.json = opts.jsonCompatibleStrings;\n  }\n  if (format.minified) {\n    format.compact = true;\n    format.shouldPrintComment = format.shouldPrintComment || (() => format.comments);\n  } else {\n    format.shouldPrintComment = format.shouldPrintComment || (value => format.comments || value.includes(\"@license\") || value.includes(\"@preserve\"));\n  }\n  if (format.compact === \"auto\") {\n    format.compact = typeof code === \"string\" && code.length > 500000;\n    if (format.compact) {\n      console.error(\"[BABEL] Note: The code generator has deoptimised the styling of \" + `${opts.filename} as it exceeds the max of ${\"500KB\"}.`);\n    }\n  }\n  if (format.compact) {\n    format.indent.adjustMultilineComment = false;\n  }\n  const {\n    auxiliaryCommentBefore,\n    auxiliaryCommentAfter,\n    shouldPrintComment\n  } = format;\n  if (auxiliaryCommentBefore && !shouldPrintComment(auxiliaryCommentBefore)) {\n    format.auxiliaryCommentBefore = undefined;\n  }\n  if (auxiliaryCommentAfter && !shouldPrintComment(auxiliaryCommentAfter)) {\n    format.auxiliaryCommentAfter = undefined;\n  }\n  return format;\n}\nclass CodeGenerator {\n  constructor(ast, opts, code) {\n    this._generator = void 0;\n    this._generator = new Generator(ast, opts, code);\n  }\n  generate() {\n    return this._generator.generate();\n  }\n}\nexports.CodeGenerator = CodeGenerator;\nfunction generate(ast, opts, code) {\n  const gen = new Generator(ast, opts, code);\n  return gen.generate();\n}\n\n//# sourceMappingURL=index.js.map\n","import SourceMap from \"./source-map.ts\";\nimport Printer from \"./printer.ts\";\nimport type * as t from \"@babel/types\";\nimport type { Opts as jsescOptions } from \"jsesc\";\nimport type { Format } from \"./printer.ts\";\nimport type {\n  RecordAndTuplePluginOptions,\n  PipelineOperatorPluginOptions,\n} from \"@babel/parser\";\nimport type {\n  EncodedSourceMap,\n  DecodedSourceMap,\n  Mapping,\n} from \"@jridgewell/gen-mapping\";\n\n/**\n * Babel's code generator, turns an ast into code, maintaining sourcemaps,\n * user preferences, and valid output.\n */\n\nclass Generator extends Printer {\n  constructor(\n    ast: t.Node,\n    opts: GeneratorOptions = {},\n    code: string | { [filename: string]: string },\n  ) {\n    const format = normalizeOptions(code, opts);\n    const map = opts.sourceMaps ? new SourceMap(opts, code) : null;\n    super(format, map);\n\n    this.ast = ast;\n  }\n\n  ast: t.Node;\n\n  /**\n   * Generate code and sourcemap from ast.\n   *\n   * Appends comments that weren't attached to any node to the end of the generated output.\n   */\n\n  generate() {\n    return super.generate(this.ast);\n  }\n}\n\n/**\n * Normalize generator options, setting defaults.\n *\n * - Detects code indentation.\n * - If `opts.compact = \"auto\"` and the code is over 500KB, `compact` will be set to `true`.\n */\n\nfunction normalizeOptions(\n  code: string | { [filename: string]: string },\n  opts: GeneratorOptions,\n): Format {\n  const format: Format = {\n    auxiliaryCommentBefore: opts.auxiliaryCommentBefore,\n    auxiliaryCommentAfter: opts.auxiliaryCommentAfter,\n    shouldPrintComment: opts.shouldPrintComment,\n    retainLines: opts.retainLines,\n    retainFunctionParens: opts.retainFunctionParens,\n    comments: opts.comments == null || opts.comments,\n    compact: opts.compact,\n    minified: opts.minified,\n    concise: opts.concise,\n    indent: {\n      adjustMultilineComment: true,\n      style: \"  \",\n    },\n    jsescOption: {\n      quotes: \"double\",\n      wrap: true,\n      minimal: process.env.BABEL_8_BREAKING ? true : false,\n      ...opts.jsescOption,\n    },\n    recordAndTupleSyntaxType: opts.recordAndTupleSyntaxType ?? \"hash\",\n    topicToken: opts.topicToken,\n    importAttributesKeyword: opts.importAttributesKeyword,\n  };\n\n  if (!process.env.BABEL_8_BREAKING) {\n    format.decoratorsBeforeExport = opts.decoratorsBeforeExport;\n    format.jsescOption.json = opts.jsonCompatibleStrings;\n  }\n\n  if (format.minified) {\n    format.compact = true;\n\n    format.shouldPrintComment =\n      format.shouldPrintComment || (() => format.comments);\n  } else {\n    format.shouldPrintComment =\n      format.shouldPrintComment ||\n      (value =>\n        format.comments ||\n        value.includes(\"@license\") ||\n        value.includes(\"@preserve\"));\n  }\n\n  if (format.compact === \"auto\") {\n    format.compact = typeof code === \"string\" && code.length > 500_000; // 500KB\n\n    if (format.compact) {\n      console.error(\n        \"[BABEL] Note: The code generator has deoptimised the styling of \" +\n          `${opts.filename} as it exceeds the max of ${\"500KB\"}.`,\n      );\n    }\n  }\n\n  if (format.compact) {\n    format.indent.adjustMultilineComment = false;\n  }\n\n  const { auxiliaryCommentBefore, auxiliaryCommentAfter, shouldPrintComment } =\n    format;\n\n  if (auxiliaryCommentBefore && !shouldPrintComment(auxiliaryCommentBefore)) {\n    format.auxiliaryCommentBefore = undefined;\n  }\n  if (auxiliaryCommentAfter && !shouldPrintComment(auxiliaryCommentAfter)) {\n    format.auxiliaryCommentAfter = undefined;\n  }\n\n  return format;\n}\n\nexport interface GeneratorOptions {\n  /**\n   * Optional string to add as a block comment at the start of the output file.\n   */\n  auxiliaryCommentBefore?: string;\n\n  /**\n   * Optional string to add as a block comment at the end of the output file.\n   */\n  auxiliaryCommentAfter?: string;\n\n  /**\n   * Function that takes a comment (as a string) and returns true if the comment should be included in the output.\n   * By default, comments are included if `opts.comments` is `true` or if `opts.minified` is `false` and the comment\n   * contains `@preserve` or `@license`.\n   */\n  shouldPrintComment?(comment: string): boolean;\n\n  /**\n   * Attempt to use the same line numbers in the output code as in the source code (helps preserve stack traces).\n   * Defaults to `false`.\n   */\n  retainLines?: boolean;\n\n  /**\n   * Retain parens around function expressions (could be used to change engine parsing behavior)\n   * Defaults to `false`.\n   */\n  retainFunctionParens?: boolean;\n\n  /**\n   * Should comments be included in output? Defaults to `true`.\n   */\n  comments?: boolean;\n\n  /**\n   * Set to true to avoid adding whitespace for formatting. Defaults to the value of `opts.minified`.\n   */\n  compact?: boolean | \"auto\";\n\n  /**\n   * Should the output be minified. Defaults to `false`.\n   */\n  minified?: boolean;\n\n  /**\n   * Set to true to reduce whitespace (but not as much as opts.compact). Defaults to `false`.\n   */\n  concise?: boolean;\n\n  /**\n   * Used in warning messages\n   */\n  filename?: string;\n\n  /**\n   * Enable generating source maps. Defaults to `false`.\n   */\n  sourceMaps?: boolean;\n\n  inputSourceMap?: any;\n\n  /**\n   * A root for all relative URLs in the source map.\n   */\n  sourceRoot?: string;\n\n  /**\n   * The filename for the source code (i.e. the code in the `code` argument).\n   * This will only be used if `code` is a string.\n   */\n  sourceFileName?: string;\n\n  /**\n   * Set to true to run jsesc with \"json\": true to print \"\\u00A9\" vs. \"\";\n   * @deprecated use `jsescOptions: { json: true }` instead\n   */\n  jsonCompatibleStrings?: boolean;\n\n  /**\n   * Set to true to enable support for experimental decorators syntax before\n   * module exports. If not specified, decorators will be printed in the same\n   * position as they were in the input source code.\n   * @deprecated Removed in Babel 8\n   */\n  decoratorsBeforeExport?: boolean;\n\n  /**\n   * Options for outputting jsesc representation.\n   */\n  jsescOption?: jsescOptions;\n\n  /**\n   * For use with the recordAndTuple token.\n   */\n  recordAndTupleSyntaxType?: RecordAndTuplePluginOptions[\"syntaxType\"];\n\n  /**\n   * For use with the Hack-style pipe operator.\n   * Changes what token is used for pipe bodies topic references.\n   */\n  topicToken?: PipelineOperatorPluginOptions[\"topicToken\"];\n\n  /**\n   * The import attributes syntax style:\n   * - \"with\"        : `import { a } from \"b\" with { type: \"json\" };`\n   * - \"assert\"      : `import { a } from \"b\" assert { type: \"json\" };`\n   * - \"with-legacy\" : `import { a } from \"b\" with type: \"json\";`\n   */\n  importAttributesKeyword?: \"with\" | \"assert\" | \"with-legacy\";\n}\n\nexport interface GeneratorResult {\n  code: string;\n  map: EncodedSourceMap | null;\n  decodedMap: DecodedSourceMap | undefined;\n  rawMappings: Mapping[] | undefined;\n}\n\n/**\n * We originally exported the Generator class above, but to make it extra clear that it is a private API,\n * we have moved that to an internal class instance and simplified the interface to the two public methods\n * that we wish to support.\n */\n\nexport class CodeGenerator {\n  private _generator: Generator;\n  constructor(ast: t.Node, opts?: GeneratorOptions, code?: string) {\n    this._generator = new Generator(ast, opts, code);\n  }\n  generate(): GeneratorResult {\n    return this._generator.generate();\n  }\n}\n\n/**\n * Turns an AST into code, maintaining sourcemaps, user preferences, and valid output.\n * @param ast - the abstract syntax tree from which to generate output code.\n * @param opts - used for specifying options for code generation.\n * @param code - the original source code, used for source maps.\n * @returns - an object containing the output code and source map.\n */\nexport default function generate(\n  ast: t.Node,\n  opts?: GeneratorOptions,\n  code?: string | { [filename: string]: string },\n) {\n  const gen = new Generator(ast, opts, code);\n  return gen.generate();\n}\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _genMapping = require(\"@jridgewell/gen-mapping\");\nvar _traceMapping = require(\"@jridgewell/trace-mapping\");\nclass SourceMap {\n  constructor(opts, code) {\n    var _opts$sourceFileName;\n    this._map = void 0;\n    this._rawMappings = void 0;\n    this._sourceFileName = void 0;\n    this._lastGenLine = 0;\n    this._lastSourceLine = 0;\n    this._lastSourceColumn = 0;\n    this._inputMap = void 0;\n    const map = this._map = new _genMapping.GenMapping({\n      sourceRoot: opts.sourceRoot\n    });\n    this._sourceFileName = (_opts$sourceFileName = opts.sourceFileName) == null ? void 0 : _opts$sourceFileName.replace(/\\\\/g, \"/\");\n    this._rawMappings = undefined;\n    if (opts.inputSourceMap) {\n      this._inputMap = new _traceMapping.TraceMap(opts.inputSourceMap);\n      const resolvedSources = this._inputMap.resolvedSources;\n      if (resolvedSources.length) {\n        for (let i = 0; i < resolvedSources.length; i++) {\n          var _this$_inputMap$sourc;\n          (0, _genMapping.setSourceContent)(map, resolvedSources[i], (_this$_inputMap$sourc = this._inputMap.sourcesContent) == null ? void 0 : _this$_inputMap$sourc[i]);\n        }\n      }\n    }\n    if (typeof code === \"string\" && !opts.inputSourceMap) {\n      (0, _genMapping.setSourceContent)(map, this._sourceFileName, code);\n    } else if (typeof code === \"object\") {\n      for (const sourceFileName of Object.keys(code)) {\n        (0, _genMapping.setSourceContent)(map, sourceFileName.replace(/\\\\/g, \"/\"), code[sourceFileName]);\n      }\n    }\n  }\n  get() {\n    return (0, _genMapping.toEncodedMap)(this._map);\n  }\n  getDecoded() {\n    return (0, _genMapping.toDecodedMap)(this._map);\n  }\n  getRawMappings() {\n    return this._rawMappings || (this._rawMappings = (0, _genMapping.allMappings)(this._map));\n  }\n  mark(generated, line, column, identifierName, identifierNamePos, filename) {\n    var _originalMapping;\n    this._rawMappings = undefined;\n    let originalMapping;\n    if (line != null) {\n      if (this._inputMap) {\n        originalMapping = (0, _traceMapping.originalPositionFor)(this._inputMap, {\n          line,\n          column\n        });\n        if (!originalMapping.name && identifierNamePos) {\n          const originalIdentifierMapping = (0, _traceMapping.originalPositionFor)(this._inputMap, identifierNamePos);\n          if (originalIdentifierMapping.name) {\n            identifierName = originalIdentifierMapping.name;\n          }\n        }\n      } else {\n        originalMapping = {\n          source: (filename == null ? void 0 : filename.replace(/\\\\/g, \"/\")) || this._sourceFileName,\n          line: line,\n          column: column\n        };\n      }\n    }\n    (0, _genMapping.maybeAddMapping)(this._map, {\n      name: identifierName,\n      generated,\n      source: (_originalMapping = originalMapping) == null ? void 0 : _originalMapping.source,\n      original: originalMapping\n    });\n  }\n}\nexports.default = SourceMap;\n\n//# sourceMappingURL=source-map.js.map\n","import {\n  GenMapping,\n  maybeAddMapping,\n  setSourceContent,\n  allMappings,\n  toEncodedMap,\n  toDecodedMap,\n} from \"@jridgewell/gen-mapping\";\n\nimport type {\n  EncodedSourceMap,\n  DecodedSourceMap,\n  Mapping,\n} from \"@jridgewell/gen-mapping\";\n\nimport {\n  type SourceMapInput,\n  originalPositionFor,\n  TraceMap,\n} from \"@jridgewell/trace-mapping\";\n\n/**\n * Build a sourcemap.\n */\n\nexport default class SourceMap {\n  private _map: GenMapping;\n  private _rawMappings: Mapping[] | undefined;\n  private _sourceFileName: string | undefined;\n\n  // Any real line is > 0, so init to 0 is fine.\n  private _lastGenLine = 0;\n  private _lastSourceLine = 0;\n\n  // Source columns can be 0, but we only check in unison with sourceLine, which\n  // inits to an impossible value. So init to 0 is fine.\n  private _lastSourceColumn = 0;\n\n  public _inputMap: TraceMap;\n\n  constructor(\n    opts: {\n      sourceFileName?: string;\n      sourceRoot?: string;\n      inputSourceMap?: SourceMapInput;\n    },\n    code: string | { [sourceFileName: string]: string },\n  ) {\n    const map = (this._map = new GenMapping({ sourceRoot: opts.sourceRoot }));\n    this._sourceFileName = opts.sourceFileName?.replace(/\\\\/g, \"/\");\n    this._rawMappings = undefined;\n\n    if (opts.inputSourceMap) {\n      this._inputMap = new TraceMap(opts.inputSourceMap);\n      const resolvedSources = this._inputMap.resolvedSources;\n      if (resolvedSources.length) {\n        for (let i = 0; i < resolvedSources.length; i++) {\n          setSourceContent(\n            map,\n            resolvedSources[i],\n            this._inputMap.sourcesContent?.[i],\n          );\n        }\n      }\n    }\n\n    if (typeof code === \"string\" && !opts.inputSourceMap) {\n      setSourceContent(map, this._sourceFileName, code);\n    } else if (typeof code === \"object\") {\n      for (const sourceFileName of Object.keys(code)) {\n        setSourceContent(\n          map,\n          sourceFileName.replace(/\\\\/g, \"/\"),\n          code[sourceFileName],\n        );\n      }\n    }\n  }\n\n  /**\n   * Get the sourcemap.\n   */\n  get(): EncodedSourceMap {\n    return toEncodedMap(this._map);\n  }\n\n  getDecoded(): DecodedSourceMap {\n    return toDecodedMap(this._map);\n  }\n\n  getRawMappings(): Mapping[] {\n    return (this._rawMappings ||= allMappings(this._map));\n  }\n\n  /**\n   * Mark the current generated position with a source position. May also be passed null line/column\n   * values to insert a mapping to nothing.\n   */\n\n  mark(\n    generated: { line: number; column: number },\n    line: number,\n    column: number,\n    identifierName?: string | null,\n    identifierNamePos?: { line: number; column: number },\n    filename?: string | null,\n  ) {\n    this._rawMappings = undefined;\n\n    let originalMapping: {\n      source: string | null;\n      name?: string | null;\n      line: number | null;\n      column: number | null;\n    };\n\n    if (line != null) {\n      if (this._inputMap) {\n        // This is the lookup for this mark\n        originalMapping = originalPositionFor(this._inputMap, {\n          line,\n          column,\n        });\n\n        // If the we found a name, nothing else needs to be done\n        // Maybe we're marking a `(` and the input map already had a name attached there,\n        // or we're marking a `(` and the sourcemap spanned a `foo(`,\n        // or we're marking an identifier, etc.\n        if (!originalMapping.name && identifierNamePos) {\n          // We're trying to mark a `(` (as that's the only thing that provides\n          // an identifierNamePos currently), and we the AST had an identifier attached.\n          // Lookup it's original name.\n          const originalIdentifierMapping = originalPositionFor(\n            this._inputMap,\n            identifierNamePos,\n          );\n          if (originalIdentifierMapping.name) {\n            identifierName = originalIdentifierMapping.name;\n          }\n        }\n      } else {\n        originalMapping = {\n          source: filename?.replace(/\\\\/g, \"/\") || this._sourceFileName,\n          line: line,\n          column: column,\n        };\n      }\n    }\n\n    maybeAddMapping(this._map, {\n      name: identifierName,\n      generated,\n      source: originalMapping?.source,\n      original: originalMapping,\n    });\n  }\n}\n","import { SetArray, put } from '@jridgewell/set-array';\nimport { encode } from '@jridgewell/sourcemap-codec';\nimport { TraceMap, decodedMappings } from '@jridgewell/trace-mapping';\n\nconst COLUMN = 0;\nconst SOURCES_INDEX = 1;\nconst SOURCE_LINE = 2;\nconst SOURCE_COLUMN = 3;\nconst NAMES_INDEX = 4;\n\nconst NO_NAME = -1;\n/**\n * A low-level API to associate a generated position with an original source position. Line and\n * column here are 0-based, unlike `addMapping`.\n */\nlet addSegment;\n/**\n * A high-level API to associate a generated position with an original source position. Line is\n * 1-based, but column is 0-based, due to legacy behavior in `source-map` library.\n */\nlet addMapping;\n/**\n * Same as `addSegment`, but will only add the segment if it generates useful information in the\n * resulting map. This only works correctly if segments are added **in order**, meaning you should\n * not add a segment with a lower generated line/column than one that came before.\n */\nlet maybeAddSegment;\n/**\n * Same as `addMapping`, but will only add the mapping if it generates useful information in the\n * resulting map. This only works correctly if mappings are added **in order**, meaning you should\n * not add a mapping with a lower generated line/column than one that came before.\n */\nlet maybeAddMapping;\n/**\n * Adds/removes the content of the source file to the source map.\n */\nlet setSourceContent;\n/**\n * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nlet toDecodedMap;\n/**\n * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nlet toEncodedMap;\n/**\n * Constructs a new GenMapping, using the already present mappings of the input.\n */\nlet fromMap;\n/**\n * Returns an array of high-level mapping objects for every recorded segment, which could then be\n * passed to the `source-map` library.\n */\nlet allMappings;\n// This split declaration is only so that terser can elminiate the static initialization block.\nlet addSegmentInternal;\n/**\n * Provides the state to generate a sourcemap.\n */\nclass GenMapping {\n    constructor({ file, sourceRoot } = {}) {\n        this._names = new SetArray();\n        this._sources = new SetArray();\n        this._sourcesContent = [];\n        this._mappings = [];\n        this.file = file;\n        this.sourceRoot = sourceRoot;\n    }\n}\n(() => {\n    addSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) => {\n        return addSegmentInternal(false, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);\n    };\n    maybeAddSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) => {\n        return addSegmentInternal(true, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);\n    };\n    addMapping = (map, mapping) => {\n        return addMappingInternal(false, map, mapping);\n    };\n    maybeAddMapping = (map, mapping) => {\n        return addMappingInternal(true, map, mapping);\n    };\n    setSourceContent = (map, source, content) => {\n        const { _sources: sources, _sourcesContent: sourcesContent } = map;\n        sourcesContent[put(sources, source)] = content;\n    };\n    toDecodedMap = (map) => {\n        const { file, sourceRoot, _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names, } = map;\n        removeEmptyFinalLines(mappings);\n        return {\n            version: 3,\n            file: file || undefined,\n            names: names.array,\n            sourceRoot: sourceRoot || undefined,\n            sources: sources.array,\n            sourcesContent,\n            mappings,\n        };\n    };\n    toEncodedMap = (map) => {\n        const decoded = toDecodedMap(map);\n        return Object.assign(Object.assign({}, decoded), { mappings: encode(decoded.mappings) });\n    };\n    allMappings = (map) => {\n        const out = [];\n        const { _mappings: mappings, _sources: sources, _names: names } = map;\n        for (let i = 0; i < mappings.length; i++) {\n            const line = mappings[i];\n            for (let j = 0; j < line.length; j++) {\n                const seg = line[j];\n                const generated = { line: i + 1, column: seg[COLUMN] };\n                let source = undefined;\n                let original = undefined;\n                let name = undefined;\n                if (seg.length !== 1) {\n                    source = sources.array[seg[SOURCES_INDEX]];\n                    original = { line: seg[SOURCE_LINE] + 1, column: seg[SOURCE_COLUMN] };\n                    if (seg.length === 5)\n                        name = names.array[seg[NAMES_INDEX]];\n                }\n                out.push({ generated, source, original, name });\n            }\n        }\n        return out;\n    };\n    fromMap = (input) => {\n        const map = new TraceMap(input);\n        const gen = new GenMapping({ file: map.file, sourceRoot: map.sourceRoot });\n        putAll(gen._names, map.names);\n        putAll(gen._sources, map.sources);\n        gen._sourcesContent = map.sourcesContent || map.sources.map(() => null);\n        gen._mappings = decodedMappings(map);\n        return gen;\n    };\n    // Internal helpers\n    addSegmentInternal = (skipable, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) => {\n        const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names, } = map;\n        const line = getLine(mappings, genLine);\n        const index = getColumnIndex(line, genColumn);\n        if (!source) {\n            if (skipable && skipSourceless(line, index))\n                return;\n            return insert(line, index, [genColumn]);\n        }\n        const sourcesIndex = put(sources, source);\n        const namesIndex = name ? put(names, name) : NO_NAME;\n        if (sourcesIndex === sourcesContent.length)\n            sourcesContent[sourcesIndex] = content !== null && content !== void 0 ? content : null;\n        if (skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {\n            return;\n        }\n        return insert(line, index, name\n            ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex]\n            : [genColumn, sourcesIndex, sourceLine, sourceColumn]);\n    };\n})();\nfunction getLine(mappings, index) {\n    for (let i = mappings.length; i <= index; i++) {\n        mappings[i] = [];\n    }\n    return mappings[index];\n}\nfunction getColumnIndex(line, genColumn) {\n    let index = line.length;\n    for (let i = index - 1; i >= 0; index = i--) {\n        const current = line[i];\n        if (genColumn >= current[COLUMN])\n            break;\n    }\n    return index;\n}\nfunction insert(array, index, value) {\n    for (let i = array.length; i > index; i--) {\n        array[i] = array[i - 1];\n    }\n    array[index] = value;\n}\nfunction removeEmptyFinalLines(mappings) {\n    const { length } = mappings;\n    let len = length;\n    for (let i = len - 1; i >= 0; len = i, i--) {\n        if (mappings[i].length > 0)\n            break;\n    }\n    if (len < length)\n        mappings.length = len;\n}\nfunction putAll(strarr, array) {\n    for (let i = 0; i < array.length; i++)\n        put(strarr, array[i]);\n}\nfunction skipSourceless(line, index) {\n    // The start of a line is already sourceless, so adding a sourceless segment to the beginning\n    // doesn't generate any useful information.\n    if (index === 0)\n        return true;\n    const prev = line[index - 1];\n    // If the previous segment is also sourceless, then adding another sourceless segment doesn't\n    // genrate any new information. Else, this segment will end the source/named segment and point to\n    // a sourceless position, which is useful.\n    return prev.length === 1;\n}\nfunction skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex) {\n    // A source/named segment at the start of a line gives position at that genColumn\n    if (index === 0)\n        return false;\n    const prev = line[index - 1];\n    // If the previous segment is sourceless, then we're transitioning to a source.\n    if (prev.length === 1)\n        return false;\n    // If the previous segment maps to the exact same source position, then this segment doesn't\n    // provide any new position information.\n    return (sourcesIndex === prev[SOURCES_INDEX] &&\n        sourceLine === prev[SOURCE_LINE] &&\n        sourceColumn === prev[SOURCE_COLUMN] &&\n        namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME));\n}\nfunction addMappingInternal(skipable, map, mapping) {\n    const { generated, source, original, name, content } = mapping;\n    if (!source) {\n        return addSegmentInternal(skipable, map, generated.line - 1, generated.column, null, null, null, null, null);\n    }\n    const s = source;\n    return addSegmentInternal(skipable, map, generated.line - 1, generated.column, s, original.line - 1, original.column, name, content);\n}\n\nexport { GenMapping, addMapping, addSegment, allMappings, fromMap, maybeAddMapping, maybeAddSegment, setSourceContent, toDecodedMap, toEncodedMap };\n//# sourceMappingURL=gen-mapping.mjs.map\n","type GeneratedColumn = number;\ntype SourcesIndex = number;\ntype SourceLine = number;\ntype SourceColumn = number;\ntype NamesIndex = number;\n\nexport type SourceMapSegment =\n  | [GeneratedColumn]\n  | [GeneratedColumn, SourcesIndex, SourceLine, SourceColumn]\n  | [GeneratedColumn, SourcesIndex, SourceLine, SourceColumn, NamesIndex];\n\nexport const COLUMN = 0;\nexport const SOURCES_INDEX = 1;\nexport const SOURCE_LINE = 2;\nexport const SOURCE_COLUMN = 3;\nexport const NAMES_INDEX = 4;\n","import { SetArray, put } from '@jridgewell/set-array';\nimport { encode } from '@jridgewell/sourcemap-codec';\nimport { TraceMap, decodedMappings } from '@jridgewell/trace-mapping';\n\nimport {\n  COLUMN,\n  SOURCES_INDEX,\n  SOURCE_LINE,\n  SOURCE_COLUMN,\n  NAMES_INDEX,\n} from './sourcemap-segment';\n\nimport type { SourceMapInput } from '@jridgewell/trace-mapping';\nimport type { SourceMapSegment } from './sourcemap-segment';\nimport type { DecodedSourceMap, EncodedSourceMap, Pos, Mapping } from './types';\n\nexport type { DecodedSourceMap, EncodedSourceMap, Mapping };\n\nexport type Options = {\n  file?: string | null;\n  sourceRoot?: string | null;\n};\n\nconst NO_NAME = -1;\n\n/**\n * A low-level API to associate a generated position with an original source position. Line and\n * column here are 0-based, unlike `addMapping`.\n */\nexport let addSegment: {\n  (\n    map: GenMapping,\n    genLine: number,\n    genColumn: number,\n    source?: null,\n    sourceLine?: null,\n    sourceColumn?: null,\n    name?: null,\n    content?: null,\n  ): void;\n  (\n    map: GenMapping,\n    genLine: number,\n    genColumn: number,\n    source: string,\n    sourceLine: number,\n    sourceColumn: number,\n    name?: null,\n    content?: string | null,\n  ): void;\n  (\n    map: GenMapping,\n    genLine: number,\n    genColumn: number,\n    source: string,\n    sourceLine: number,\n    sourceColumn: number,\n    name: string,\n    content?: string | null,\n  ): void;\n};\n\n/**\n * A high-level API to associate a generated position with an original source position. Line is\n * 1-based, but column is 0-based, due to legacy behavior in `source-map` library.\n */\nexport let addMapping: {\n  (\n    map: GenMapping,\n    mapping: {\n      generated: Pos;\n      source?: null;\n      original?: null;\n      name?: null;\n      content?: null;\n    },\n  ): void;\n  (\n    map: GenMapping,\n    mapping: {\n      generated: Pos;\n      source: string;\n      original: Pos;\n      name?: null;\n      content?: string | null;\n    },\n  ): void;\n  (\n    map: GenMapping,\n    mapping: {\n      generated: Pos;\n      source: string;\n      original: Pos;\n      name: string;\n      content?: string | null;\n    },\n  ): void;\n};\n\n/**\n * Same as `addSegment`, but will only add the segment if it generates useful information in the\n * resulting map. This only works correctly if segments are added **in order**, meaning you should\n * not add a segment with a lower generated line/column than one that came before.\n */\nexport let maybeAddSegment: typeof addSegment;\n\n/**\n * Same as `addMapping`, but will only add the mapping if it generates useful information in the\n * resulting map. This only works correctly if mappings are added **in order**, meaning you should\n * not add a mapping with a lower generated line/column than one that came before.\n */\nexport let maybeAddMapping: typeof addMapping;\n\n/**\n * Adds/removes the content of the source file to the source map.\n */\nexport let setSourceContent: (map: GenMapping, source: string, content: string | null) => void;\n\n/**\n * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nexport let toDecodedMap: (map: GenMapping) => DecodedSourceMap;\n\n/**\n * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nexport let toEncodedMap: (map: GenMapping) => EncodedSourceMap;\n\n/**\n * Constructs a new GenMapping, using the already present mappings of the input.\n */\nexport let fromMap: (input: SourceMapInput) => GenMapping;\n\n/**\n * Returns an array of high-level mapping objects for every recorded segment, which could then be\n * passed to the `source-map` library.\n */\nexport let allMappings: (map: GenMapping) => Mapping[];\n\n// This split declaration is only so that terser can elminiate the static initialization block.\nlet addSegmentInternal: <S extends string | null | undefined>(\n  skipable: boolean,\n  map: GenMapping,\n  genLine: number,\n  genColumn: number,\n  source: S,\n  sourceLine: S extends string ? number : null | undefined,\n  sourceColumn: S extends string ? number : null | undefined,\n  name: S extends string ? string | null | undefined : null | undefined,\n  content: S extends string ? string | null | undefined : null | undefined,\n) => void;\n\n/**\n * Provides the state to generate a sourcemap.\n */\nexport class GenMapping {\n  private _names = new SetArray();\n  private _sources = new SetArray();\n  private _sourcesContent: (string | null)[] = [];\n  private _mappings: SourceMapSegment[][] = [];\n  declare file: string | null | undefined;\n  declare sourceRoot: string | null | undefined;\n\n  constructor({ file, sourceRoot }: Options = {}) {\n    this.file = file;\n    this.sourceRoot = sourceRoot;\n  }\n\n  static {\n    addSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) => {\n      return addSegmentInternal(\n        false,\n        map,\n        genLine,\n        genColumn,\n        source,\n        sourceLine,\n        sourceColumn,\n        name,\n        content,\n      );\n    };\n\n    maybeAddSegment = (\n      map,\n      genLine,\n      genColumn,\n      source,\n      sourceLine,\n      sourceColumn,\n      name,\n      content,\n    ) => {\n      return addSegmentInternal(\n        true,\n        map,\n        genLine,\n        genColumn,\n        source,\n        sourceLine,\n        sourceColumn,\n        name,\n        content,\n      );\n    };\n\n    addMapping = (map, mapping) => {\n      return addMappingInternal(false, map, mapping as Parameters<typeof addMappingInternal>[2]);\n    };\n\n    maybeAddMapping = (map, mapping) => {\n      return addMappingInternal(true, map, mapping as Parameters<typeof addMappingInternal>[2]);\n    };\n\n    setSourceContent = (map, source, content) => {\n      const { _sources: sources, _sourcesContent: sourcesContent } = map;\n      sourcesContent[put(sources, source)] = content;\n    };\n\n    toDecodedMap = (map) => {\n      const {\n        file,\n        sourceRoot,\n        _mappings: mappings,\n        _sources: sources,\n        _sourcesContent: sourcesContent,\n        _names: names,\n      } = map;\n      removeEmptyFinalLines(mappings);\n\n      return {\n        version: 3,\n        file: file || undefined,\n        names: names.array,\n        sourceRoot: sourceRoot || undefined,\n        sources: sources.array,\n        sourcesContent,\n        mappings,\n      };\n    };\n\n    toEncodedMap = (map) => {\n      const decoded = toDecodedMap(map);\n      return {\n        ...decoded,\n        mappings: encode(decoded.mappings as SourceMapSegment[][]),\n      };\n    };\n\n    allMappings = (map) => {\n      const out: Mapping[] = [];\n      const { _mappings: mappings, _sources: sources, _names: names } = map;\n\n      for (let i = 0; i < mappings.length; i++) {\n        const line = mappings[i];\n        for (let j = 0; j < line.length; j++) {\n          const seg = line[j];\n\n          const generated = { line: i + 1, column: seg[COLUMN] };\n          let source: string | undefined = undefined;\n          let original: Pos | undefined = undefined;\n          let name: string | undefined = undefined;\n\n          if (seg.length !== 1) {\n            source = sources.array[seg[SOURCES_INDEX]];\n            original = { line: seg[SOURCE_LINE] + 1, column: seg[SOURCE_COLUMN] };\n\n            if (seg.length === 5) name = names.array[seg[NAMES_INDEX]];\n          }\n\n          out.push({ generated, source, original, name } as Mapping);\n        }\n      }\n\n      return out;\n    };\n\n    fromMap = (input) => {\n      const map = new TraceMap(input);\n      const gen = new GenMapping({ file: map.file, sourceRoot: map.sourceRoot });\n\n      putAll(gen._names, map.names);\n      putAll(gen._sources, map.sources as string[]);\n      gen._sourcesContent = map.sourcesContent || map.sources.map(() => null);\n      gen._mappings = decodedMappings(map) as GenMapping['_mappings'];\n\n      return gen;\n    };\n\n    // Internal helpers\n    addSegmentInternal = (\n      skipable,\n      map,\n      genLine,\n      genColumn,\n      source,\n      sourceLine,\n      sourceColumn,\n      name,\n      content,\n    ) => {\n      const {\n        _mappings: mappings,\n        _sources: sources,\n        _sourcesContent: sourcesContent,\n        _names: names,\n      } = map;\n      const line = getLine(mappings, genLine);\n      const index = getColumnIndex(line, genColumn);\n\n      if (!source) {\n        if (skipable && skipSourceless(line, index)) return;\n        return insert(line, index, [genColumn]);\n      }\n\n      // Sigh, TypeScript can't figure out sourceLine and sourceColumn aren't nullish if source\n      // isn't nullish.\n      assert<number>(sourceLine);\n      assert<number>(sourceColumn);\n\n      const sourcesIndex = put(sources, source);\n      const namesIndex = name ? put(names, name) : NO_NAME;\n      if (sourcesIndex === sourcesContent.length) sourcesContent[sourcesIndex] = content ?? null;\n\n      if (skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {\n        return;\n      }\n\n      return insert(\n        line,\n        index,\n        name\n          ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex]\n          : [genColumn, sourcesIndex, sourceLine, sourceColumn],\n      );\n    };\n  }\n}\n\nfunction assert<T>(_val: unknown): asserts _val is T {\n  // noop.\n}\n\nfunction getLine(mappings: SourceMapSegment[][], index: number): SourceMapSegment[] {\n  for (let i = mappings.length; i <= index; i++) {\n    mappings[i] = [];\n  }\n  return mappings[index];\n}\n\nfunction getColumnIndex(line: SourceMapSegment[], genColumn: number): number {\n  let index = line.length;\n  for (let i = index - 1; i >= 0; index = i--) {\n    const current = line[i];\n    if (genColumn >= current[COLUMN]) break;\n  }\n  return index;\n}\n\nfunction insert<T>(array: T[], index: number, value: T) {\n  for (let i = array.length; i > index; i--) {\n    array[i] = array[i - 1];\n  }\n  array[index] = value;\n}\n\nfunction removeEmptyFinalLines(mappings: SourceMapSegment[][]) {\n  const { length } = mappings;\n  let len = length;\n  for (let i = len - 1; i >= 0; len = i, i--) {\n    if (mappings[i].length > 0) break;\n  }\n  if (len < length) mappings.length = len;\n}\n\nfunction putAll(strarr: SetArray, array: string[]) {\n  for (let i = 0; i < array.length; i++) put(strarr, array[i]);\n}\n\nfunction skipSourceless(line: SourceMapSegment[], index: number): boolean {\n  // The start of a line is already sourceless, so adding a sourceless segment to the beginning\n  // doesn't generate any useful information.\n  if (index === 0) return true;\n\n  const prev = line[index - 1];\n  // If the previous segment is also sourceless, then adding another sourceless segment doesn't\n  // genrate any new information. Else, this segment will end the source/named segment and point to\n  // a sourceless position, which is useful.\n  return prev.length === 1;\n}\n\nfunction skipSource(\n  line: SourceMapSegment[],\n  index: number,\n  sourcesIndex: number,\n  sourceLine: number,\n  sourceColumn: number,\n  namesIndex: number,\n): boolean {\n  // A source/named segment at the start of a line gives position at that genColumn\n  if (index === 0) return false;\n\n  const prev = line[index - 1];\n\n  // If the previous segment is sourceless, then we're transitioning to a source.\n  if (prev.length === 1) return false;\n\n  // If the previous segment maps to the exact same source position, then this segment doesn't\n  // provide any new position information.\n  return (\n    sourcesIndex === prev[SOURCES_INDEX] &&\n    sourceLine === prev[SOURCE_LINE] &&\n    sourceColumn === prev[SOURCE_COLUMN] &&\n    namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME)\n  );\n}\n\nfunction addMappingInternal<S extends string | null | undefined>(\n  skipable: boolean,\n  map: GenMapping,\n  mapping: {\n    generated: Pos;\n    source: S;\n    original: S extends string ? Pos : null | undefined;\n    name: S extends string ? string | null | undefined : null | undefined;\n    content: S extends string ? string | null | undefined : null | undefined;\n  },\n) {\n  const { generated, source, original, name, content } = mapping;\n  if (!source) {\n    return addSegmentInternal(\n      skipable,\n      map,\n      generated.line - 1,\n      generated.column,\n      null,\n      null,\n      null,\n      null,\n      null,\n    );\n  }\n  const s: string = source;\n  assert<Pos>(original);\n  return addSegmentInternal(\n    skipable,\n    map,\n    generated.line - 1,\n    generated.column,\n    s,\n    original.line - 1,\n    original.column,\n    name,\n    content,\n  );\n}\n","/**\n * Gets the index associated with `key` in the backing array, if it is already present.\n */\nlet get;\n/**\n * Puts `key` into the backing array, if it is not already present. Returns\n * the index of the `key` in the backing array.\n */\nlet put;\n/**\n * Pops the last added item out of the SetArray.\n */\nlet pop;\n/**\n * SetArray acts like a `Set` (allowing only one occurrence of a string `key`), but provides the\n * index of the `key` in the backing array.\n *\n * This is designed to allow synchronizing a second array with the contents of the backing array,\n * like how in a sourcemap `sourcesContent[i]` is the source content associated with `source[i]`,\n * and there are never duplicates.\n */\nclass SetArray {\n    constructor() {\n        this._indexes = { __proto__: null };\n        this.array = [];\n    }\n}\n(() => {\n    get = (strarr, key) => strarr._indexes[key];\n    put = (strarr, key) => {\n        // The key may or may not be present. If it is present, it's a number.\n        const index = get(strarr, key);\n        if (index !== undefined)\n            return index;\n        const { array, _indexes: indexes } = strarr;\n        return (indexes[key] = array.push(key) - 1);\n    };\n    pop = (strarr) => {\n        const { array, _indexes: indexes } = strarr;\n        if (array.length === 0)\n            return;\n        const last = array.pop();\n        indexes[last] = undefined;\n    };\n})();\n\nexport { SetArray, get, pop, put };\n//# sourceMappingURL=set-array.mjs.map\n","/**\n * Gets the index associated with `key` in the backing array, if it is already present.\n */\nexport let get: (strarr: SetArray, key: string) => number | undefined;\n\n/**\n * Puts `key` into the backing array, if it is not already present. Returns\n * the index of the `key` in the backing array.\n */\nexport let put: (strarr: SetArray, key: string) => number;\n\n/**\n * Pops the last added item out of the SetArray.\n */\nexport let pop: (strarr: SetArray) => void;\n\n/**\n * SetArray acts like a `Set` (allowing only one occurrence of a string `key`), but provides the\n * index of the `key` in the backing array.\n *\n * This is designed to allow synchronizing a second array with the contents of the backing array,\n * like how in a sourcemap `sourcesContent[i]` is the source content associated with `source[i]`,\n * and there are never duplicates.\n */\nexport class SetArray {\n  private declare _indexes: { [key: string]: number | undefined };\n  declare array: readonly string[];\n\n  constructor() {\n    this._indexes = { __proto__: null } as any;\n    this.array = [];\n  }\n\n  static {\n    get = (strarr, key) => strarr._indexes[key];\n\n    put = (strarr, key) => {\n      // The key may or may not be present. If it is present, it's a number.\n      const index = get(strarr, key);\n      if (index !== undefined) return index;\n\n      const { array, _indexes: indexes } = strarr;\n\n      return (indexes[key] = (array as string[]).push(key) - 1);\n    };\n\n    pop = (strarr) => {\n      const { array, _indexes: indexes } = strarr;\n      if (array.length === 0) return;\n\n      const last = (array as string[]).pop()!;\n      indexes[last] = undefined;\n    };\n  }\n}\n","const comma = ','.charCodeAt(0);\nconst semicolon = ';'.charCodeAt(0);\nconst chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nconst intToChar = new Uint8Array(64); // 64 possible chars.\nconst charToInt = new Uint8Array(128); // z is 122 in ASCII\nfor (let i = 0; i < chars.length; i++) {\n    const c = chars.charCodeAt(i);\n    intToChar[i] = c;\n    charToInt[c] = i;\n}\n// Provide a fallback for older environments.\nconst td = typeof TextDecoder !== 'undefined'\n    ? /* #__PURE__ */ new TextDecoder()\n    : typeof Buffer !== 'undefined'\n        ? {\n            decode(buf) {\n                const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);\n                return out.toString();\n            },\n        }\n        : {\n            decode(buf) {\n                let out = '';\n                for (let i = 0; i < buf.length; i++) {\n                    out += String.fromCharCode(buf[i]);\n                }\n                return out;\n            },\n        };\nfunction decode(mappings) {\n    const state = new Int32Array(5);\n    const decoded = [];\n    let index = 0;\n    do {\n        const semi = indexOf(mappings, index);\n        const line = [];\n        let sorted = true;\n        let lastCol = 0;\n        state[0] = 0;\n        for (let i = index; i < semi; i++) {\n            let seg;\n            i = decodeInteger(mappings, i, state, 0); // genColumn\n            const col = state[0];\n            if (col < lastCol)\n                sorted = false;\n            lastCol = col;\n            if (hasMoreVlq(mappings, i, semi)) {\n                i = decodeInteger(mappings, i, state, 1); // sourcesIndex\n                i = decodeInteger(mappings, i, state, 2); // sourceLine\n                i = decodeInteger(mappings, i, state, 3); // sourceColumn\n                if (hasMoreVlq(mappings, i, semi)) {\n                    i = decodeInteger(mappings, i, state, 4); // namesIndex\n                    seg = [col, state[1], state[2], state[3], state[4]];\n                }\n                else {\n                    seg = [col, state[1], state[2], state[3]];\n                }\n            }\n            else {\n                seg = [col];\n            }\n            line.push(seg);\n        }\n        if (!sorted)\n            sort(line);\n        decoded.push(line);\n        index = semi + 1;\n    } while (index <= mappings.length);\n    return decoded;\n}\nfunction indexOf(mappings, index) {\n    const idx = mappings.indexOf(';', index);\n    return idx === -1 ? mappings.length : idx;\n}\nfunction decodeInteger(mappings, pos, state, j) {\n    let value = 0;\n    let shift = 0;\n    let integer = 0;\n    do {\n        const c = mappings.charCodeAt(pos++);\n        integer = charToInt[c];\n        value |= (integer & 31) << shift;\n        shift += 5;\n    } while (integer & 32);\n    const shouldNegate = value & 1;\n    value >>>= 1;\n    if (shouldNegate) {\n        value = -0x80000000 | -value;\n    }\n    state[j] += value;\n    return pos;\n}\nfunction hasMoreVlq(mappings, i, length) {\n    if (i >= length)\n        return false;\n    return mappings.charCodeAt(i) !== comma;\n}\nfunction sort(line) {\n    line.sort(sortComparator);\n}\nfunction sortComparator(a, b) {\n    return a[0] - b[0];\n}\nfunction encode(decoded) {\n    const state = new Int32Array(5);\n    const bufLength = 1024 * 16;\n    const subLength = bufLength - 36;\n    const buf = new Uint8Array(bufLength);\n    const sub = buf.subarray(0, subLength);\n    let pos = 0;\n    let out = '';\n    for (let i = 0; i < decoded.length; i++) {\n        const line = decoded[i];\n        if (i > 0) {\n            if (pos === bufLength) {\n                out += td.decode(buf);\n                pos = 0;\n            }\n            buf[pos++] = semicolon;\n        }\n        if (line.length === 0)\n            continue;\n        state[0] = 0;\n        for (let j = 0; j < line.length; j++) {\n            const segment = line[j];\n            // We can push up to 5 ints, each int can take at most 7 chars, and we\n            // may push a comma.\n            if (pos > subLength) {\n                out += td.decode(sub);\n                buf.copyWithin(0, subLength, pos);\n                pos -= subLength;\n            }\n            if (j > 0)\n                buf[pos++] = comma;\n            pos = encodeInteger(buf, pos, state, segment, 0); // genColumn\n            if (segment.length === 1)\n                continue;\n            pos = encodeInteger(buf, pos, state, segment, 1); // sourcesIndex\n            pos = encodeInteger(buf, pos, state, segment, 2); // sourceLine\n            pos = encodeInteger(buf, pos, state, segment, 3); // sourceColumn\n            if (segment.length === 4)\n                continue;\n            pos = encodeInteger(buf, pos, state, segment, 4); // namesIndex\n        }\n    }\n    return out + td.decode(buf.subarray(0, pos));\n}\nfunction encodeInteger(buf, pos, state, segment, j) {\n    const next = segment[j];\n    let num = next - state[j];\n    state[j] = next;\n    num = num < 0 ? (-num << 1) | 1 : num << 1;\n    do {\n        let clamped = num & 0b011111;\n        num >>>= 5;\n        if (num > 0)\n            clamped |= 0b100000;\n        buf[pos++] = intToChar[clamped];\n    } while (num > 0);\n    return pos;\n}\n\nexport { decode, encode };\n//# sourceMappingURL=sourcemap-codec.mjs.map\n","export type SourceMapSegment =\n  | [number]\n  | [number, number, number, number]\n  | [number, number, number, number, number];\nexport type SourceMapLine = SourceMapSegment[];\nexport type SourceMapMappings = SourceMapLine[];\n\nconst comma = ','.charCodeAt(0);\nconst semicolon = ';'.charCodeAt(0);\nconst chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nconst intToChar = new Uint8Array(64); // 64 possible chars.\nconst charToInt = new Uint8Array(128); // z is 122 in ASCII\n\nfor (let i = 0; i < chars.length; i++) {\n  const c = chars.charCodeAt(i);\n  intToChar[i] = c;\n  charToInt[c] = i;\n}\n\n// Provide a fallback for older environments.\nconst td =\n  typeof TextDecoder !== 'undefined'\n    ? /* #__PURE__ */ new TextDecoder()\n    : typeof Buffer !== 'undefined'\n    ? {\n        decode(buf: Uint8Array) {\n          const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);\n          return out.toString();\n        },\n      }\n    : {\n        decode(buf: Uint8Array) {\n          let out = '';\n          for (let i = 0; i < buf.length; i++) {\n            out += String.fromCharCode(buf[i]);\n          }\n          return out;\n        },\n      };\n\nexport function decode(mappings: string): SourceMapMappings {\n  const state: [number, number, number, number, number] = new Int32Array(5) as any;\n  const decoded: SourceMapMappings = [];\n\n  let index = 0;\n  do {\n    const semi = indexOf(mappings, index);\n    const line: SourceMapLine = [];\n    let sorted = true;\n    let lastCol = 0;\n    state[0] = 0;\n\n    for (let i = index; i < semi; i++) {\n      let seg: SourceMapSegment;\n\n      i = decodeInteger(mappings, i, state, 0); // genColumn\n      const col = state[0];\n      if (col < lastCol) sorted = false;\n      lastCol = col;\n\n      if (hasMoreVlq(mappings, i, semi)) {\n        i = decodeInteger(mappings, i, state, 1); // sourcesIndex\n        i = decodeInteger(mappings, i, state, 2); // sourceLine\n        i = decodeInteger(mappings, i, state, 3); // sourceColumn\n\n        if (hasMoreVlq(mappings, i, semi)) {\n          i = decodeInteger(mappings, i, state, 4); // namesIndex\n          seg = [col, state[1], state[2], state[3], state[4]];\n        } else {\n          seg = [col, state[1], state[2], state[3]];\n        }\n      } else {\n        seg = [col];\n      }\n\n      line.push(seg);\n    }\n\n    if (!sorted) sort(line);\n    decoded.push(line);\n    index = semi + 1;\n  } while (index <= mappings.length);\n\n  return decoded;\n}\n\nfunction indexOf(mappings: string, index: number): number {\n  const idx = mappings.indexOf(';', index);\n  return idx === -1 ? mappings.length : idx;\n}\n\nfunction decodeInteger(mappings: string, pos: number, state: SourceMapSegment, j: number): number {\n  let value = 0;\n  let shift = 0;\n  let integer = 0;\n\n  do {\n    const c = mappings.charCodeAt(pos++);\n    integer = charToInt[c];\n    value |= (integer & 31) << shift;\n    shift += 5;\n  } while (integer & 32);\n\n  const shouldNegate = value & 1;\n  value >>>= 1;\n\n  if (shouldNegate) {\n    value = -0x80000000 | -value;\n  }\n\n  state[j] += value;\n  return pos;\n}\n\nfunction hasMoreVlq(mappings: string, i: number, length: number): boolean {\n  if (i >= length) return false;\n  return mappings.charCodeAt(i) !== comma;\n}\n\nfunction sort(line: SourceMapSegment[]) {\n  line.sort(sortComparator);\n}\n\nfunction sortComparator(a: SourceMapSegment, b: SourceMapSegment): number {\n  return a[0] - b[0];\n}\n\nexport function encode(decoded: SourceMapMappings): string;\nexport function encode(decoded: Readonly<SourceMapMappings>): string;\nexport function encode(decoded: Readonly<SourceMapMappings>): string {\n  const state: [number, number, number, number, number] = new Int32Array(5) as any;\n  const bufLength = 1024 * 16;\n  const subLength = bufLength - 36;\n  const buf = new Uint8Array(bufLength);\n  const sub = buf.subarray(0, subLength);\n  let pos = 0;\n  let out = '';\n\n  for (let i = 0; i < decoded.length; i++) {\n    const line = decoded[i];\n    if (i > 0) {\n      if (pos === bufLength) {\n        out += td.decode(buf);\n        pos = 0;\n      }\n      buf[pos++] = semicolon;\n    }\n    if (line.length === 0) continue;\n\n    state[0] = 0;\n\n    for (let j = 0; j < line.length; j++) {\n      const segment = line[j];\n      // We can push up to 5 ints, each int can take at most 7 chars, and we\n      // may push a comma.\n      if (pos > subLength) {\n        out += td.decode(sub);\n        buf.copyWithin(0, subLength, pos);\n        pos -= subLength;\n      }\n      if (j > 0) buf[pos++] = comma;\n\n      pos = encodeInteger(buf, pos, state, segment, 0); // genColumn\n\n      if (segment.length === 1) continue;\n      pos = encodeInteger(buf, pos, state, segment, 1); // sourcesIndex\n      pos = encodeInteger(buf, pos, state, segment, 2); // sourceLine\n      pos = encodeInteger(buf, pos, state, segment, 3); // sourceColumn\n\n      if (segment.length === 4) continue;\n      pos = encodeInteger(buf, pos, state, segment, 4); // namesIndex\n    }\n  }\n\n  return out + td.decode(buf.subarray(0, pos));\n}\n\nfunction encodeInteger(\n  buf: Uint8Array,\n  pos: number,\n  state: SourceMapSegment,\n  segment: SourceMapSegment,\n  j: number,\n): number {\n  const next = segment[j];\n  let num = next - state[j];\n  state[j] = next;\n\n  num = num < 0 ? (-num << 1) | 1 : num << 1;\n  do {\n    let clamped = num & 0b011111;\n    num >>>= 5;\n    if (num > 0) clamped |= 0b100000;\n    buf[pos++] = intToChar[clamped];\n  } while (num > 0);\n\n  return pos;\n}\n","import { encode, decode } from '@jridgewell/sourcemap-codec';\nimport resolveUri from '@jridgewell/resolve-uri';\n\nfunction resolve(input, base) {\n    // The base is always treated as a directory, if it's not empty.\n    // https://github.com/mozilla/source-map/blob/8cb3ee57/lib/util.js#L327\n    // https://github.com/chromium/chromium/blob/da4adbb3/third_party/blink/renderer/devtools/front_end/sdk/SourceMap.js#L400-L401\n    if (base && !base.endsWith('/'))\n        base += '/';\n    return resolveUri(input, base);\n}\n\n/**\n * Removes everything after the last \"/\", but leaves the slash.\n */\nfunction stripFilename(path) {\n    if (!path)\n        return '';\n    const index = path.lastIndexOf('/');\n    return path.slice(0, index + 1);\n}\n\nconst COLUMN = 0;\nconst SOURCES_INDEX = 1;\nconst SOURCE_LINE = 2;\nconst SOURCE_COLUMN = 3;\nconst NAMES_INDEX = 4;\nconst REV_GENERATED_LINE = 1;\nconst REV_GENERATED_COLUMN = 2;\n\nfunction maybeSort(mappings, owned) {\n    const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);\n    if (unsortedIndex === mappings.length)\n        return mappings;\n    // If we own the array (meaning we parsed it from JSON), then we're free to directly mutate it. If\n    // not, we do not want to modify the consumer's input array.\n    if (!owned)\n        mappings = mappings.slice();\n    for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {\n        mappings[i] = sortSegments(mappings[i], owned);\n    }\n    return mappings;\n}\nfunction nextUnsortedSegmentLine(mappings, start) {\n    for (let i = start; i < mappings.length; i++) {\n        if (!isSorted(mappings[i]))\n            return i;\n    }\n    return mappings.length;\n}\nfunction isSorted(line) {\n    for (let j = 1; j < line.length; j++) {\n        if (line[j][COLUMN] < line[j - 1][COLUMN]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction sortSegments(line, owned) {\n    if (!owned)\n        line = line.slice();\n    return line.sort(sortComparator);\n}\nfunction sortComparator(a, b) {\n    return a[COLUMN] - b[COLUMN];\n}\n\nlet found = false;\n/**\n * A binary search implementation that returns the index if a match is found.\n * If no match is found, then the left-index (the index associated with the item that comes just\n * before the desired index) is returned. To maintain proper sort order, a splice would happen at\n * the next index:\n *\n * ```js\n * const array = [1, 3];\n * const needle = 2;\n * const index = binarySearch(array, needle, (item, needle) => item - needle);\n *\n * assert.equal(index, 0);\n * array.splice(index + 1, 0, needle);\n * assert.deepEqual(array, [1, 2, 3]);\n * ```\n */\nfunction binarySearch(haystack, needle, low, high) {\n    while (low <= high) {\n        const mid = low + ((high - low) >> 1);\n        const cmp = haystack[mid][COLUMN] - needle;\n        if (cmp === 0) {\n            found = true;\n            return mid;\n        }\n        if (cmp < 0) {\n            low = mid + 1;\n        }\n        else {\n            high = mid - 1;\n        }\n    }\n    found = false;\n    return low - 1;\n}\nfunction upperBound(haystack, needle, index) {\n    for (let i = index + 1; i < haystack.length; index = i++) {\n        if (haystack[i][COLUMN] !== needle)\n            break;\n    }\n    return index;\n}\nfunction lowerBound(haystack, needle, index) {\n    for (let i = index - 1; i >= 0; index = i--) {\n        if (haystack[i][COLUMN] !== needle)\n            break;\n    }\n    return index;\n}\nfunction memoizedState() {\n    return {\n        lastKey: -1,\n        lastNeedle: -1,\n        lastIndex: -1,\n    };\n}\n/**\n * This overly complicated beast is just to record the last tested line/column and the resulting\n * index, allowing us to skip a few tests if mappings are monotonically increasing.\n */\nfunction memoizedBinarySearch(haystack, needle, state, key) {\n    const { lastKey, lastNeedle, lastIndex } = state;\n    let low = 0;\n    let high = haystack.length - 1;\n    if (key === lastKey) {\n        if (needle === lastNeedle) {\n            found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;\n            return lastIndex;\n        }\n        if (needle >= lastNeedle) {\n            // lastIndex may be -1 if the previous needle was not found.\n            low = lastIndex === -1 ? 0 : lastIndex;\n        }\n        else {\n            high = lastIndex;\n        }\n    }\n    state.lastKey = key;\n    state.lastNeedle = needle;\n    return (state.lastIndex = binarySearch(haystack, needle, low, high));\n}\n\n// Rebuilds the original source files, with mappings that are ordered by source line/column instead\n// of generated line/column.\nfunction buildBySources(decoded, memos) {\n    const sources = memos.map(buildNullArray);\n    for (let i = 0; i < decoded.length; i++) {\n        const line = decoded[i];\n        for (let j = 0; j < line.length; j++) {\n            const seg = line[j];\n            if (seg.length === 1)\n                continue;\n            const sourceIndex = seg[SOURCES_INDEX];\n            const sourceLine = seg[SOURCE_LINE];\n            const sourceColumn = seg[SOURCE_COLUMN];\n            const originalSource = sources[sourceIndex];\n            const originalLine = (originalSource[sourceLine] || (originalSource[sourceLine] = []));\n            const memo = memos[sourceIndex];\n            // The binary search either found a match, or it found the left-index just before where the\n            // segment should go. Either way, we want to insert after that. And there may be multiple\n            // generated segments associated with an original location, so there may need to move several\n            // indexes before we find where we need to insert.\n            const index = upperBound(originalLine, sourceColumn, memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine));\n            insert(originalLine, (memo.lastIndex = index + 1), [sourceColumn, i, seg[COLUMN]]);\n        }\n    }\n    return sources;\n}\nfunction insert(array, index, value) {\n    for (let i = array.length; i > index; i--) {\n        array[i] = array[i - 1];\n    }\n    array[index] = value;\n}\n// Null arrays allow us to use ordered index keys without actually allocating contiguous memory like\n// a real array. We use a null-prototype object to avoid prototype pollution and deoptimizations.\n// Numeric properties on objects are magically sorted in ascending order by the engine regardless of\n// the insertion order. So, by setting any numeric keys, even out of order, we'll get ascending\n// order when iterating with for-in.\nfunction buildNullArray() {\n    return { __proto__: null };\n}\n\nconst AnyMap = function (map, mapUrl) {\n    const parsed = typeof map === 'string' ? JSON.parse(map) : map;\n    if (!('sections' in parsed))\n        return new TraceMap(parsed, mapUrl);\n    const mappings = [];\n    const sources = [];\n    const sourcesContent = [];\n    const names = [];\n    recurse(parsed, mapUrl, mappings, sources, sourcesContent, names, 0, 0, Infinity, Infinity);\n    const joined = {\n        version: 3,\n        file: parsed.file,\n        names,\n        sources,\n        sourcesContent,\n        mappings,\n    };\n    return presortedDecodedMap(joined);\n};\nfunction recurse(input, mapUrl, mappings, sources, sourcesContent, names, lineOffset, columnOffset, stopLine, stopColumn) {\n    const { sections } = input;\n    for (let i = 0; i < sections.length; i++) {\n        const { map, offset } = sections[i];\n        let sl = stopLine;\n        let sc = stopColumn;\n        if (i + 1 < sections.length) {\n            const nextOffset = sections[i + 1].offset;\n            sl = Math.min(stopLine, lineOffset + nextOffset.line);\n            if (sl === stopLine) {\n                sc = Math.min(stopColumn, columnOffset + nextOffset.column);\n            }\n            else if (sl < stopLine) {\n                sc = columnOffset + nextOffset.column;\n            }\n        }\n        addSection(map, mapUrl, mappings, sources, sourcesContent, names, lineOffset + offset.line, columnOffset + offset.column, sl, sc);\n    }\n}\nfunction addSection(input, mapUrl, mappings, sources, sourcesContent, names, lineOffset, columnOffset, stopLine, stopColumn) {\n    if ('sections' in input)\n        return recurse(...arguments);\n    const map = new TraceMap(input, mapUrl);\n    const sourcesOffset = sources.length;\n    const namesOffset = names.length;\n    const decoded = decodedMappings(map);\n    const { resolvedSources, sourcesContent: contents } = map;\n    append(sources, resolvedSources);\n    append(names, map.names);\n    if (contents)\n        append(sourcesContent, contents);\n    else\n        for (let i = 0; i < resolvedSources.length; i++)\n            sourcesContent.push(null);\n    for (let i = 0; i < decoded.length; i++) {\n        const lineI = lineOffset + i;\n        // We can only add so many lines before we step into the range that the next section's map\n        // controls. When we get to the last line, then we'll start checking the segments to see if\n        // they've crossed into the column range. But it may not have any columns that overstep, so we\n        // still need to check that we don't overstep lines, too.\n        if (lineI > stopLine)\n            return;\n        // The out line may already exist in mappings (if we're continuing the line started by a\n        // previous section). Or, we may have jumped ahead several lines to start this section.\n        const out = getLine(mappings, lineI);\n        // On the 0th loop, the section's column offset shifts us forward. On all other lines (since the\n        // map can be multiple lines), it doesn't.\n        const cOffset = i === 0 ? columnOffset : 0;\n        const line = decoded[i];\n        for (let j = 0; j < line.length; j++) {\n            const seg = line[j];\n            const column = cOffset + seg[COLUMN];\n            // If this segment steps into the column range that the next section's map controls, we need\n            // to stop early.\n            if (lineI === stopLine && column >= stopColumn)\n                return;\n            if (seg.length === 1) {\n                out.push([column]);\n                continue;\n            }\n            const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];\n            const sourceLine = seg[SOURCE_LINE];\n            const sourceColumn = seg[SOURCE_COLUMN];\n            out.push(seg.length === 4\n                ? [column, sourcesIndex, sourceLine, sourceColumn]\n                : [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]]);\n        }\n    }\n}\nfunction append(arr, other) {\n    for (let i = 0; i < other.length; i++)\n        arr.push(other[i]);\n}\nfunction getLine(arr, index) {\n    for (let i = arr.length; i <= index; i++)\n        arr[i] = [];\n    return arr[index];\n}\n\nconst LINE_GTR_ZERO = '`line` must be greater than 0 (lines start at line 1)';\nconst COL_GTR_EQ_ZERO = '`column` must be greater than or equal to 0 (columns start at column 0)';\nconst LEAST_UPPER_BOUND = -1;\nconst GREATEST_LOWER_BOUND = 1;\n/**\n * Returns the encoded (VLQ string) form of the SourceMap's mappings field.\n */\nlet encodedMappings;\n/**\n * Returns the decoded (array of lines of segments) form of the SourceMap's mappings field.\n */\nlet decodedMappings;\n/**\n * A low-level API to find the segment associated with a generated line/column (think, from a\n * stack trace). Line and column here are 0-based, unlike `originalPositionFor`.\n */\nlet traceSegment;\n/**\n * A higher-level API to find the source/line/column associated with a generated line/column\n * (think, from a stack trace). Line is 1-based, but column is 0-based, due to legacy behavior in\n * `source-map` library.\n */\nlet originalPositionFor;\n/**\n * Finds the generated line/column position of the provided source/line/column source position.\n */\nlet generatedPositionFor;\n/**\n * Finds all generated line/column positions of the provided source/line/column source position.\n */\nlet allGeneratedPositionsFor;\n/**\n * Iterates each mapping in generated position order.\n */\nlet eachMapping;\n/**\n * Retrieves the source content for a particular source, if its found. Returns null if not.\n */\nlet sourceContentFor;\n/**\n * A helper that skips sorting of the input map's mappings array, which can be expensive for larger\n * maps.\n */\nlet presortedDecodedMap;\n/**\n * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nlet decodedMap;\n/**\n * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nlet encodedMap;\nclass TraceMap {\n    constructor(map, mapUrl) {\n        const isString = typeof map === 'string';\n        if (!isString && map._decodedMemo)\n            return map;\n        const parsed = (isString ? JSON.parse(map) : map);\n        const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;\n        this.version = version;\n        this.file = file;\n        this.names = names || [];\n        this.sourceRoot = sourceRoot;\n        this.sources = sources;\n        this.sourcesContent = sourcesContent;\n        const from = resolve(sourceRoot || '', stripFilename(mapUrl));\n        this.resolvedSources = sources.map((s) => resolve(s || '', from));\n        const { mappings } = parsed;\n        if (typeof mappings === 'string') {\n            this._encoded = mappings;\n            this._decoded = undefined;\n        }\n        else {\n            this._encoded = undefined;\n            this._decoded = maybeSort(mappings, isString);\n        }\n        this._decodedMemo = memoizedState();\n        this._bySources = undefined;\n        this._bySourceMemos = undefined;\n    }\n}\n(() => {\n    encodedMappings = (map) => {\n        var _a;\n        return ((_a = map._encoded) !== null && _a !== void 0 ? _a : (map._encoded = encode(map._decoded)));\n    };\n    decodedMappings = (map) => {\n        return (map._decoded || (map._decoded = decode(map._encoded)));\n    };\n    traceSegment = (map, line, column) => {\n        const decoded = decodedMappings(map);\n        // It's common for parent source maps to have pointers to lines that have no\n        // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n        if (line >= decoded.length)\n            return null;\n        const segments = decoded[line];\n        const index = traceSegmentInternal(segments, map._decodedMemo, line, column, GREATEST_LOWER_BOUND);\n        return index === -1 ? null : segments[index];\n    };\n    originalPositionFor = (map, { line, column, bias }) => {\n        line--;\n        if (line < 0)\n            throw new Error(LINE_GTR_ZERO);\n        if (column < 0)\n            throw new Error(COL_GTR_EQ_ZERO);\n        const decoded = decodedMappings(map);\n        // It's common for parent source maps to have pointers to lines that have no\n        // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n        if (line >= decoded.length)\n            return OMapping(null, null, null, null);\n        const segments = decoded[line];\n        const index = traceSegmentInternal(segments, map._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);\n        if (index === -1)\n            return OMapping(null, null, null, null);\n        const segment = segments[index];\n        if (segment.length === 1)\n            return OMapping(null, null, null, null);\n        const { names, resolvedSources } = map;\n        return OMapping(resolvedSources[segment[SOURCES_INDEX]], segment[SOURCE_LINE] + 1, segment[SOURCE_COLUMN], segment.length === 5 ? names[segment[NAMES_INDEX]] : null);\n    };\n    allGeneratedPositionsFor = (map, { source, line, column, bias }) => {\n        // SourceMapConsumer uses LEAST_UPPER_BOUND for some reason, so we follow suit.\n        return generatedPosition(map, source, line, column, bias || LEAST_UPPER_BOUND, true);\n    };\n    generatedPositionFor = (map, { source, line, column, bias }) => {\n        return generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, false);\n    };\n    eachMapping = (map, cb) => {\n        const decoded = decodedMappings(map);\n        const { names, resolvedSources } = map;\n        for (let i = 0; i < decoded.length; i++) {\n            const line = decoded[i];\n            for (let j = 0; j < line.length; j++) {\n                const seg = line[j];\n                const generatedLine = i + 1;\n                const generatedColumn = seg[0];\n                let source = null;\n                let originalLine = null;\n                let originalColumn = null;\n                let name = null;\n                if (seg.length !== 1) {\n                    source = resolvedSources[seg[1]];\n                    originalLine = seg[2] + 1;\n                    originalColumn = seg[3];\n                }\n                if (seg.length === 5)\n                    name = names[seg[4]];\n                cb({\n                    generatedLine,\n                    generatedColumn,\n                    source,\n                    originalLine,\n                    originalColumn,\n                    name,\n                });\n            }\n        }\n    };\n    sourceContentFor = (map, source) => {\n        const { sources, resolvedSources, sourcesContent } = map;\n        if (sourcesContent == null)\n            return null;\n        let index = sources.indexOf(source);\n        if (index === -1)\n            index = resolvedSources.indexOf(source);\n        return index === -1 ? null : sourcesContent[index];\n    };\n    presortedDecodedMap = (map, mapUrl) => {\n        const tracer = new TraceMap(clone(map, []), mapUrl);\n        tracer._decoded = map.mappings;\n        return tracer;\n    };\n    decodedMap = (map) => {\n        return clone(map, decodedMappings(map));\n    };\n    encodedMap = (map) => {\n        return clone(map, encodedMappings(map));\n    };\n    function generatedPosition(map, source, line, column, bias, all) {\n        line--;\n        if (line < 0)\n            throw new Error(LINE_GTR_ZERO);\n        if (column < 0)\n            throw new Error(COL_GTR_EQ_ZERO);\n        const { sources, resolvedSources } = map;\n        let sourceIndex = sources.indexOf(source);\n        if (sourceIndex === -1)\n            sourceIndex = resolvedSources.indexOf(source);\n        if (sourceIndex === -1)\n            return all ? [] : GMapping(null, null);\n        const generated = (map._bySources || (map._bySources = buildBySources(decodedMappings(map), (map._bySourceMemos = sources.map(memoizedState)))));\n        const segments = generated[sourceIndex][line];\n        if (segments == null)\n            return all ? [] : GMapping(null, null);\n        const memo = map._bySourceMemos[sourceIndex];\n        if (all)\n            return sliceGeneratedPositions(segments, memo, line, column, bias);\n        const index = traceSegmentInternal(segments, memo, line, column, bias);\n        if (index === -1)\n            return GMapping(null, null);\n        const segment = segments[index];\n        return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);\n    }\n})();\nfunction clone(map, mappings) {\n    return {\n        version: map.version,\n        file: map.file,\n        names: map.names,\n        sourceRoot: map.sourceRoot,\n        sources: map.sources,\n        sourcesContent: map.sourcesContent,\n        mappings,\n    };\n}\nfunction OMapping(source, line, column, name) {\n    return { source, line, column, name };\n}\nfunction GMapping(line, column) {\n    return { line, column };\n}\nfunction traceSegmentInternal(segments, memo, line, column, bias) {\n    let index = memoizedBinarySearch(segments, column, memo, line);\n    if (found) {\n        index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);\n    }\n    else if (bias === LEAST_UPPER_BOUND)\n        index++;\n    if (index === -1 || index === segments.length)\n        return -1;\n    return index;\n}\nfunction sliceGeneratedPositions(segments, memo, line, column, bias) {\n    let min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);\n    // We ignored the bias when tracing the segment so that we're guarnateed to find the first (in\n    // insertion order) segment that matched. Even if we did respect the bias when tracing, we would\n    // still need to call `lowerBound()` to find the first segment, which is slower than just looking\n    // for the GREATEST_LOWER_BOUND to begin with. The only difference that matters for us is when the\n    // binary search didn't match, in which case GREATEST_LOWER_BOUND just needs to increment to\n    // match LEAST_UPPER_BOUND.\n    if (!found && bias === LEAST_UPPER_BOUND)\n        min++;\n    if (min === -1 || min === segments.length)\n        return [];\n    // We may have found the segment that started at an earlier column. If this is the case, then we\n    // need to slice all generated segments that match _that_ column, because all such segments span\n    // to our desired column.\n    const matchedColumn = found ? column : segments[min][COLUMN];\n    // The binary search is not guaranteed to find the lower bound when a match wasn't found.\n    if (!found)\n        min = lowerBound(segments, matchedColumn, min);\n    const max = upperBound(segments, matchedColumn, min);\n    const result = [];\n    for (; min <= max; min++) {\n        const segment = segments[min];\n        result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));\n    }\n    return result;\n}\n\nexport { AnyMap, GREATEST_LOWER_BOUND, LEAST_UPPER_BOUND, TraceMap, allGeneratedPositionsFor, decodedMap, decodedMappings, eachMapping, encodedMap, encodedMappings, generatedPositionFor, originalPositionFor, presortedDecodedMap, sourceContentFor, traceSegment };\n//# sourceMappingURL=trace-mapping.mjs.map\n","import resolveUri from '@jridgewell/resolve-uri';\n\nexport default function resolve(input: string, base: string | undefined): string {\n  // The base is always treated as a directory, if it's not empty.\n  // https://github.com/mozilla/source-map/blob/8cb3ee57/lib/util.js#L327\n  // https://github.com/chromium/chromium/blob/da4adbb3/third_party/blink/renderer/devtools/front_end/sdk/SourceMap.js#L400-L401\n  if (base && !base.endsWith('/')) base += '/';\n\n  return resolveUri(input, base);\n}\n","/**\n * Removes everything after the last \"/\", but leaves the slash.\n */\nexport default function stripFilename(path: string | undefined | null): string {\n  if (!path) return '';\n  const index = path.lastIndexOf('/');\n  return path.slice(0, index + 1);\n}\n","type GeneratedColumn = number;\ntype SourcesIndex = number;\ntype SourceLine = number;\ntype SourceColumn = number;\ntype NamesIndex = number;\n\ntype GeneratedLine = number;\n\nexport type SourceMapSegment =\n  | [GeneratedColumn]\n  | [GeneratedColumn, SourcesIndex, SourceLine, SourceColumn]\n  | [GeneratedColumn, SourcesIndex, SourceLine, SourceColumn, NamesIndex];\n\nexport type ReverseSegment = [SourceColumn, GeneratedLine, GeneratedColumn];\n\nexport const COLUMN = 0;\nexport const SOURCES_INDEX = 1;\nexport const SOURCE_LINE = 2;\nexport const SOURCE_COLUMN = 3;\nexport const NAMES_INDEX = 4;\n\nexport const REV_GENERATED_LINE = 1;\nexport const REV_GENERATED_COLUMN = 2;\n","import { COLUMN } from './sourcemap-segment';\n\nimport type { SourceMapSegment } from './sourcemap-segment';\n\nexport default function maybeSort(\n  mappings: SourceMapSegment[][],\n  owned: boolean,\n): SourceMapSegment[][] {\n  const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);\n  if (unsortedIndex === mappings.length) return mappings;\n\n  // If we own the array (meaning we parsed it from JSON), then we're free to directly mutate it. If\n  // not, we do not want to modify the consumer's input array.\n  if (!owned) mappings = mappings.slice();\n\n  for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {\n    mappings[i] = sortSegments(mappings[i], owned);\n  }\n  return mappings;\n}\n\nfunction nextUnsortedSegmentLine(mappings: SourceMapSegment[][], start: number): number {\n  for (let i = start; i < mappings.length; i++) {\n    if (!isSorted(mappings[i])) return i;\n  }\n  return mappings.length;\n}\n\nfunction isSorted(line: SourceMapSegment[]): boolean {\n  for (let j = 1; j < line.length; j++) {\n    if (line[j][COLUMN] < line[j - 1][COLUMN]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction sortSegments(line: SourceMapSegment[], owned: boolean): SourceMapSegment[] {\n  if (!owned) line = line.slice();\n  return line.sort(sortComparator);\n}\n\nfunction sortComparator(a: SourceMapSegment, b: SourceMapSegment): number {\n  return a[COLUMN] - b[COLUMN];\n}\n","import type { SourceMapSegment, ReverseSegment } from './sourcemap-segment';\nimport { COLUMN } from './sourcemap-segment';\n\nexport type MemoState = {\n  lastKey: number;\n  lastNeedle: number;\n  lastIndex: number;\n};\n\nexport let found = false;\n\n/**\n * A binary search implementation that returns the index if a match is found.\n * If no match is found, then the left-index (the index associated with the item that comes just\n * before the desired index) is returned. To maintain proper sort order, a splice would happen at\n * the next index:\n *\n * ```js\n * const array = [1, 3];\n * const needle = 2;\n * const index = binarySearch(array, needle, (item, needle) => item - needle);\n *\n * assert.equal(index, 0);\n * array.splice(index + 1, 0, needle);\n * assert.deepEqual(array, [1, 2, 3]);\n * ```\n */\nexport function binarySearch(\n  haystack: SourceMapSegment[] | ReverseSegment[],\n  needle: number,\n  low: number,\n  high: number,\n): number {\n  while (low <= high) {\n    const mid = low + ((high - low) >> 1);\n    const cmp = haystack[mid][COLUMN] - needle;\n\n    if (cmp === 0) {\n      found = true;\n      return mid;\n    }\n\n    if (cmp < 0) {\n      low = mid + 1;\n    } else {\n      high = mid - 1;\n    }\n  }\n\n  found = false;\n  return low - 1;\n}\n\nexport function upperBound(\n  haystack: SourceMapSegment[] | ReverseSegment[],\n  needle: number,\n  index: number,\n): number {\n  for (let i = index + 1; i < haystack.length; index = i++) {\n    if (haystack[i][COLUMN] !== needle) break;\n  }\n  return index;\n}\n\nexport function lowerBound(\n  haystack: SourceMapSegment[] | ReverseSegment[],\n  needle: number,\n  index: number,\n): number {\n  for (let i = index - 1; i >= 0; index = i--) {\n    if (haystack[i][COLUMN] !== needle) break;\n  }\n  return index;\n}\n\nexport function memoizedState(): MemoState {\n  return {\n    lastKey: -1,\n    lastNeedle: -1,\n    lastIndex: -1,\n  };\n}\n\n/**\n * This overly complicated beast is just to record the last tested line/column and the resulting\n * index, allowing us to skip a few tests if mappings are monotonically increasing.\n */\nexport function memoizedBinarySearch(\n  haystack: SourceMapSegment[] | ReverseSegment[],\n  needle: number,\n  state: MemoState,\n  key: number,\n): number {\n  const { lastKey, lastNeedle, lastIndex } = state;\n\n  let low = 0;\n  let high = haystack.length - 1;\n  if (key === lastKey) {\n    if (needle === lastNeedle) {\n      found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;\n      return lastIndex;\n    }\n\n    if (needle >= lastNeedle) {\n      // lastIndex may be -1 if the previous needle was not found.\n      low = lastIndex === -1 ? 0 : lastIndex;\n    } else {\n      high = lastIndex;\n    }\n  }\n  state.lastKey = key;\n  state.lastNeedle = needle;\n\n  return (state.lastIndex = binarySearch(haystack, needle, low, high));\n}\n","import { COLUMN, SOURCES_INDEX, SOURCE_LINE, SOURCE_COLUMN } from './sourcemap-segment';\nimport { memoizedBinarySearch, upperBound } from './binary-search';\n\nimport type { ReverseSegment, SourceMapSegment } from './sourcemap-segment';\nimport type { MemoState } from './binary-search';\n\nexport type Source = {\n  __proto__: null;\n  [line: number]: Exclude<ReverseSegment, [number]>[];\n};\n\n// Rebuilds the original source files, with mappings that are ordered by source line/column instead\n// of generated line/column.\nexport default function buildBySources(\n  decoded: readonly SourceMapSegment[][],\n  memos: MemoState[],\n): Source[] {\n  const sources: Source[] = memos.map(buildNullArray);\n\n  for (let i = 0; i < decoded.length; i++) {\n    const line = decoded[i];\n    for (let j = 0; j < line.length; j++) {\n      const seg = line[j];\n      if (seg.length === 1) continue;\n\n      const sourceIndex = seg[SOURCES_INDEX];\n      const sourceLine = seg[SOURCE_LINE];\n      const sourceColumn = seg[SOURCE_COLUMN];\n      const originalSource = sources[sourceIndex];\n      const originalLine = (originalSource[sourceLine] ||= []);\n      const memo = memos[sourceIndex];\n\n      // The binary search either found a match, or it found the left-index just before where the\n      // segment should go. Either way, we want to insert after that. And there may be multiple\n      // generated segments associated with an original location, so there may need to move several\n      // indexes before we find where we need to insert.\n      const index = upperBound(\n        originalLine,\n        sourceColumn,\n        memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine),\n      );\n\n      insert(originalLine, (memo.lastIndex = index + 1), [sourceColumn, i, seg[COLUMN]]);\n    }\n  }\n\n  return sources;\n}\n\nfunction insert<T>(array: T[], index: number, value: T) {\n  for (let i = array.length; i > index; i--) {\n    array[i] = array[i - 1];\n  }\n  array[index] = value;\n}\n\n// Null arrays allow us to use ordered index keys without actually allocating contiguous memory like\n// a real array. We use a null-prototype object to avoid prototype pollution and deoptimizations.\n// Numeric properties on objects are magically sorted in ascending order by the engine regardless of\n// the insertion order. So, by setting any numeric keys, even out of order, we'll get ascending\n// order when iterating with for-in.\nfunction buildNullArray<T extends { __proto__: null }>(): T {\n  return { __proto__: null } as T;\n}\n","import { TraceMap, presortedDecodedMap, decodedMappings } from './trace-mapping';\nimport {\n  COLUMN,\n  SOURCES_INDEX,\n  SOURCE_LINE,\n  SOURCE_COLUMN,\n  NAMES_INDEX,\n} from './sourcemap-segment';\n\nimport type {\n  Section,\n  SectionedSourceMap,\n  DecodedSourceMap,\n  SectionedSourceMapInput,\n  Ro,\n} from './types';\nimport type { SourceMapSegment } from './sourcemap-segment';\n\ntype AnyMap = {\n  new (map: SectionedSourceMapInput, mapUrl?: string | null): TraceMap;\n  (map: SectionedSourceMapInput, mapUrl?: string | null): TraceMap;\n};\n\nexport const AnyMap: AnyMap = function (map, mapUrl) {\n  const parsed =\n    typeof map === 'string' ? (JSON.parse(map) as Exclude<SectionedSourceMapInput, string>) : map;\n\n  if (!('sections' in parsed)) return new TraceMap(parsed, mapUrl);\n\n  const mappings: SourceMapSegment[][] = [];\n  const sources: string[] = [];\n  const sourcesContent: (string | null)[] = [];\n  const names: string[] = [];\n\n  recurse(parsed, mapUrl, mappings, sources, sourcesContent, names, 0, 0, Infinity, Infinity);\n\n  const joined: DecodedSourceMap = {\n    version: 3,\n    file: parsed.file,\n    names,\n    sources,\n    sourcesContent,\n    mappings,\n  };\n\n  return presortedDecodedMap(joined);\n} as AnyMap;\n\nfunction recurse(\n  input: Ro<SectionedSourceMap>,\n  mapUrl: string | null | undefined,\n  mappings: SourceMapSegment[][],\n  sources: string[],\n  sourcesContent: (string | null)[],\n  names: string[],\n  lineOffset: number,\n  columnOffset: number,\n  stopLine: number,\n  stopColumn: number,\n) {\n  const { sections } = input;\n  for (let i = 0; i < sections.length; i++) {\n    const { map, offset } = sections[i];\n\n    let sl = stopLine;\n    let sc = stopColumn;\n    if (i + 1 < sections.length) {\n      const nextOffset = sections[i + 1].offset;\n      sl = Math.min(stopLine, lineOffset + nextOffset.line);\n\n      if (sl === stopLine) {\n        sc = Math.min(stopColumn, columnOffset + nextOffset.column);\n      } else if (sl < stopLine) {\n        sc = columnOffset + nextOffset.column;\n      }\n    }\n\n    addSection(\n      map,\n      mapUrl,\n      mappings,\n      sources,\n      sourcesContent,\n      names,\n      lineOffset + offset.line,\n      columnOffset + offset.column,\n      sl,\n      sc,\n    );\n  }\n}\n\nfunction addSection(\n  input: Ro<Section['map']>,\n  mapUrl: string | null | undefined,\n  mappings: SourceMapSegment[][],\n  sources: string[],\n  sourcesContent: (string | null)[],\n  names: string[],\n  lineOffset: number,\n  columnOffset: number,\n  stopLine: number,\n  stopColumn: number,\n) {\n  if ('sections' in input) return recurse(...(arguments as unknown as Parameters<typeof recurse>));\n\n  const map = new TraceMap(input, mapUrl);\n  const sourcesOffset = sources.length;\n  const namesOffset = names.length;\n  const decoded = decodedMappings(map);\n  const { resolvedSources, sourcesContent: contents } = map;\n\n  append(sources, resolvedSources);\n  append(names, map.names);\n  if (contents) append(sourcesContent, contents);\n  else for (let i = 0; i < resolvedSources.length; i++) sourcesContent.push(null);\n\n  for (let i = 0; i < decoded.length; i++) {\n    const lineI = lineOffset + i;\n\n    // We can only add so many lines before we step into the range that the next section's map\n    // controls. When we get to the last line, then we'll start checking the segments to see if\n    // they've crossed into the column range. But it may not have any columns that overstep, so we\n    // still need to check that we don't overstep lines, too.\n    if (lineI > stopLine) return;\n\n    // The out line may already exist in mappings (if we're continuing the line started by a\n    // previous section). Or, we may have jumped ahead several lines to start this section.\n    const out = getLine(mappings, lineI);\n    // On the 0th loop, the section's column offset shifts us forward. On all other lines (since the\n    // map can be multiple lines), it doesn't.\n    const cOffset = i === 0 ? columnOffset : 0;\n\n    const line = decoded[i];\n    for (let j = 0; j < line.length; j++) {\n      const seg = line[j];\n      const column = cOffset + seg[COLUMN];\n\n      // If this segment steps into the column range that the next section's map controls, we need\n      // to stop early.\n      if (lineI === stopLine && column >= stopColumn) return;\n\n      if (seg.length === 1) {\n        out.push([column]);\n        continue;\n      }\n\n      const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];\n      const sourceLine = seg[SOURCE_LINE];\n      const sourceColumn = seg[SOURCE_COLUMN];\n      out.push(\n        seg.length === 4\n          ? [column, sourcesIndex, sourceLine, sourceColumn]\n          : [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]],\n      );\n    }\n  }\n}\n\nfunction append<T>(arr: T[], other: T[]) {\n  for (let i = 0; i < other.length; i++) arr.push(other[i]);\n}\n\nfunction getLine<T>(arr: T[][], index: number): T[] {\n  for (let i = arr.length; i <= index; i++) arr[i] = [];\n  return arr[index];\n}\n","import { encode, decode } from '@jridgewell/sourcemap-codec';\n\nimport resolve from './resolve';\nimport stripFilename from './strip-filename';\nimport maybeSort from './sort';\nimport buildBySources from './by-source';\nimport {\n  memoizedState,\n  memoizedBinarySearch,\n  upperBound,\n  lowerBound,\n  found as bsFound,\n} from './binary-search';\nimport {\n  COLUMN,\n  SOURCES_INDEX,\n  SOURCE_LINE,\n  SOURCE_COLUMN,\n  NAMES_INDEX,\n  REV_GENERATED_LINE,\n  REV_GENERATED_COLUMN,\n} from './sourcemap-segment';\n\nimport type { SourceMapSegment, ReverseSegment } from './sourcemap-segment';\nimport type {\n  SourceMapV3,\n  DecodedSourceMap,\n  EncodedSourceMap,\n  InvalidOriginalMapping,\n  OriginalMapping,\n  InvalidGeneratedMapping,\n  GeneratedMapping,\n  SourceMapInput,\n  Needle,\n  SourceNeedle,\n  SourceMap,\n  EachMapping,\n  Bias,\n} from './types';\nimport type { Source } from './by-source';\nimport type { MemoState } from './binary-search';\n\nexport type { SourceMapSegment } from './sourcemap-segment';\nexport type {\n  SourceMapInput,\n  SectionedSourceMapInput,\n  DecodedSourceMap,\n  EncodedSourceMap,\n  SectionedSourceMap,\n  InvalidOriginalMapping,\n  OriginalMapping as Mapping,\n  OriginalMapping,\n  InvalidGeneratedMapping,\n  GeneratedMapping,\n  EachMapping,\n} from './types';\n\nconst LINE_GTR_ZERO = '`line` must be greater than 0 (lines start at line 1)';\nconst COL_GTR_EQ_ZERO = '`column` must be greater than or equal to 0 (columns start at column 0)';\n\nexport const LEAST_UPPER_BOUND = -1;\nexport const GREATEST_LOWER_BOUND = 1;\n\n/**\n * Returns the encoded (VLQ string) form of the SourceMap's mappings field.\n */\nexport let encodedMappings: (map: TraceMap) => EncodedSourceMap['mappings'];\n\n/**\n * Returns the decoded (array of lines of segments) form of the SourceMap's mappings field.\n */\nexport let decodedMappings: (map: TraceMap) => Readonly<DecodedSourceMap['mappings']>;\n\n/**\n * A low-level API to find the segment associated with a generated line/column (think, from a\n * stack trace). Line and column here are 0-based, unlike `originalPositionFor`.\n */\nexport let traceSegment: (\n  map: TraceMap,\n  line: number,\n  column: number,\n) => Readonly<SourceMapSegment> | null;\n\n/**\n * A higher-level API to find the source/line/column associated with a generated line/column\n * (think, from a stack trace). Line is 1-based, but column is 0-based, due to legacy behavior in\n * `source-map` library.\n */\nexport let originalPositionFor: (\n  map: TraceMap,\n  needle: Needle,\n) => OriginalMapping | InvalidOriginalMapping;\n\n/**\n * Finds the generated line/column position of the provided source/line/column source position.\n */\nexport let generatedPositionFor: (\n  map: TraceMap,\n  needle: SourceNeedle,\n) => GeneratedMapping | InvalidGeneratedMapping;\n\n/**\n * Finds all generated line/column positions of the provided source/line/column source position.\n */\nexport let allGeneratedPositionsFor: (map: TraceMap, needle: SourceNeedle) => GeneratedMapping[];\n\n/**\n * Iterates each mapping in generated position order.\n */\nexport let eachMapping: (map: TraceMap, cb: (mapping: EachMapping) => void) => void;\n\n/**\n * Retrieves the source content for a particular source, if its found. Returns null if not.\n */\nexport let sourceContentFor: (map: TraceMap, source: string) => string | null;\n\n/**\n * A helper that skips sorting of the input map's mappings array, which can be expensive for larger\n * maps.\n */\nexport let presortedDecodedMap: (map: DecodedSourceMap, mapUrl?: string) => TraceMap;\n\n/**\n * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nexport let decodedMap: (\n  map: TraceMap,\n) => Omit<DecodedSourceMap, 'mappings'> & { mappings: readonly SourceMapSegment[][] };\n\n/**\n * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nexport let encodedMap: (map: TraceMap) => EncodedSourceMap;\n\nexport { AnyMap } from './any-map';\n\nexport class TraceMap implements SourceMap {\n  declare version: SourceMapV3['version'];\n  declare file: SourceMapV3['file'];\n  declare names: SourceMapV3['names'];\n  declare sourceRoot: SourceMapV3['sourceRoot'];\n  declare sources: SourceMapV3['sources'];\n  declare sourcesContent: SourceMapV3['sourcesContent'];\n\n  declare resolvedSources: string[];\n  private declare _encoded: string | undefined;\n\n  private declare _decoded: SourceMapSegment[][] | undefined;\n  private declare _decodedMemo: MemoState;\n\n  private declare _bySources: Source[] | undefined;\n  private declare _bySourceMemos: MemoState[] | undefined;\n\n  constructor(map: SourceMapInput, mapUrl?: string | null) {\n    const isString = typeof map === 'string';\n\n    if (!isString && (map as unknown as { _decodedMemo: any })._decodedMemo) return map as TraceMap;\n\n    const parsed = (isString ? JSON.parse(map) : map) as DecodedSourceMap | EncodedSourceMap;\n\n    const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;\n    this.version = version;\n    this.file = file;\n    this.names = names || [];\n    this.sourceRoot = sourceRoot;\n    this.sources = sources;\n    this.sourcesContent = sourcesContent;\n\n    const from = resolve(sourceRoot || '', stripFilename(mapUrl));\n    this.resolvedSources = sources.map((s) => resolve(s || '', from));\n\n    const { mappings } = parsed;\n    if (typeof mappings === 'string') {\n      this._encoded = mappings;\n      this._decoded = undefined;\n    } else {\n      this._encoded = undefined;\n      this._decoded = maybeSort(mappings, isString);\n    }\n\n    this._decodedMemo = memoizedState();\n    this._bySources = undefined;\n    this._bySourceMemos = undefined;\n  }\n\n  static {\n    encodedMappings = (map) => {\n      return (map._encoded ??= encode(map._decoded!));\n    };\n\n    decodedMappings = (map) => {\n      return (map._decoded ||= decode(map._encoded!));\n    };\n\n    traceSegment = (map, line, column) => {\n      const decoded = decodedMappings(map);\n\n      // It's common for parent source maps to have pointers to lines that have no\n      // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n      if (line >= decoded.length) return null;\n\n      const segments = decoded[line];\n      const index = traceSegmentInternal(\n        segments,\n        map._decodedMemo,\n        line,\n        column,\n        GREATEST_LOWER_BOUND,\n      );\n\n      return index === -1 ? null : segments[index];\n    };\n\n    originalPositionFor = (map, { line, column, bias }) => {\n      line--;\n      if (line < 0) throw new Error(LINE_GTR_ZERO);\n      if (column < 0) throw new Error(COL_GTR_EQ_ZERO);\n\n      const decoded = decodedMappings(map);\n\n      // It's common for parent source maps to have pointers to lines that have no\n      // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n      if (line >= decoded.length) return OMapping(null, null, null, null);\n\n      const segments = decoded[line];\n      const index = traceSegmentInternal(\n        segments,\n        map._decodedMemo,\n        line,\n        column,\n        bias || GREATEST_LOWER_BOUND,\n      );\n\n      if (index === -1) return OMapping(null, null, null, null);\n\n      const segment = segments[index];\n      if (segment.length === 1) return OMapping(null, null, null, null);\n\n      const { names, resolvedSources } = map;\n      return OMapping(\n        resolvedSources[segment[SOURCES_INDEX]],\n        segment[SOURCE_LINE] + 1,\n        segment[SOURCE_COLUMN],\n        segment.length === 5 ? names[segment[NAMES_INDEX]] : null,\n      );\n    };\n\n    allGeneratedPositionsFor = (map, { source, line, column, bias }) => {\n      // SourceMapConsumer uses LEAST_UPPER_BOUND for some reason, so we follow suit.\n      return generatedPosition(map, source, line, column, bias || LEAST_UPPER_BOUND, true);\n    };\n\n    generatedPositionFor = (map, { source, line, column, bias }) => {\n      return generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, false);\n    };\n\n    eachMapping = (map, cb) => {\n      const decoded = decodedMappings(map);\n      const { names, resolvedSources } = map;\n\n      for (let i = 0; i < decoded.length; i++) {\n        const line = decoded[i];\n        for (let j = 0; j < line.length; j++) {\n          const seg = line[j];\n\n          const generatedLine = i + 1;\n          const generatedColumn = seg[0];\n          let source = null;\n          let originalLine = null;\n          let originalColumn = null;\n          let name = null;\n          if (seg.length !== 1) {\n            source = resolvedSources[seg[1]];\n            originalLine = seg[2] + 1;\n            originalColumn = seg[3];\n          }\n          if (seg.length === 5) name = names[seg[4]];\n\n          cb({\n            generatedLine,\n            generatedColumn,\n            source,\n            originalLine,\n            originalColumn,\n            name,\n          } as EachMapping);\n        }\n      }\n    };\n\n    sourceContentFor = (map, source) => {\n      const { sources, resolvedSources, sourcesContent } = map;\n      if (sourcesContent == null) return null;\n\n      let index = sources.indexOf(source);\n      if (index === -1) index = resolvedSources.indexOf(source);\n\n      return index === -1 ? null : sourcesContent[index];\n    };\n\n    presortedDecodedMap = (map, mapUrl) => {\n      const tracer = new TraceMap(clone(map, []), mapUrl);\n      tracer._decoded = map.mappings;\n      return tracer;\n    };\n\n    decodedMap = (map) => {\n      return clone(map, decodedMappings(map));\n    };\n\n    encodedMap = (map) => {\n      return clone(map, encodedMappings(map));\n    };\n\n    function generatedPosition(\n      map: TraceMap,\n      source: string,\n      line: number,\n      column: number,\n      bias: Bias,\n      all: false,\n    ): GeneratedMapping | InvalidGeneratedMapping;\n    function generatedPosition(\n      map: TraceMap,\n      source: string,\n      line: number,\n      column: number,\n      bias: Bias,\n      all: true,\n    ): GeneratedMapping[];\n    function generatedPosition(\n      map: TraceMap,\n      source: string,\n      line: number,\n      column: number,\n      bias: Bias,\n      all: boolean,\n    ): GeneratedMapping | InvalidGeneratedMapping | GeneratedMapping[] {\n      line--;\n      if (line < 0) throw new Error(LINE_GTR_ZERO);\n      if (column < 0) throw new Error(COL_GTR_EQ_ZERO);\n\n      const { sources, resolvedSources } = map;\n      let sourceIndex = sources.indexOf(source);\n      if (sourceIndex === -1) sourceIndex = resolvedSources.indexOf(source);\n      if (sourceIndex === -1) return all ? [] : GMapping(null, null);\n\n      const generated = (map._bySources ||= buildBySources(\n        decodedMappings(map),\n        (map._bySourceMemos = sources.map(memoizedState)),\n      ));\n\n      const segments = generated[sourceIndex][line];\n      if (segments == null) return all ? [] : GMapping(null, null);\n\n      const memo = map._bySourceMemos![sourceIndex];\n\n      if (all) return sliceGeneratedPositions(segments, memo, line, column, bias);\n\n      const index = traceSegmentInternal(segments, memo, line, column, bias);\n      if (index === -1) return GMapping(null, null);\n\n      const segment = segments[index];\n      return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);\n    }\n  }\n}\n\nfunction clone<T extends string | readonly SourceMapSegment[][]>(\n  map: TraceMap | DecodedSourceMap | EncodedSourceMap,\n  mappings: T,\n): T extends string ? EncodedSourceMap : DecodedSourceMap {\n  return {\n    version: map.version,\n    file: map.file,\n    names: map.names,\n    sourceRoot: map.sourceRoot,\n    sources: map.sources,\n    sourcesContent: map.sourcesContent,\n    mappings,\n  } as any;\n}\n\nfunction OMapping(source: null, line: null, column: null, name: null): InvalidOriginalMapping;\nfunction OMapping(\n  source: string,\n  line: number,\n  column: number,\n  name: string | null,\n): OriginalMapping;\nfunction OMapping(\n  source: string | null,\n  line: number | null,\n  column: number | null,\n  name: string | null,\n): OriginalMapping | InvalidOriginalMapping {\n  return { source, line, column, name } as any;\n}\n\nfunction GMapping(line: null, column: null): InvalidGeneratedMapping;\nfunction GMapping(line: number, column: number): GeneratedMapping;\nfunction GMapping(\n  line: number | null,\n  column: number | null,\n): GeneratedMapping | InvalidGeneratedMapping {\n  return { line, column } as any;\n}\n\nfunction traceSegmentInternal(\n  segments: SourceMapSegment[],\n  memo: MemoState,\n  line: number,\n  column: number,\n  bias: Bias,\n): number;\nfunction traceSegmentInternal(\n  segments: ReverseSegment[],\n  memo: MemoState,\n  line: number,\n  column: number,\n  bias: Bias,\n): number;\nfunction traceSegmentInternal(\n  segments: SourceMapSegment[] | ReverseSegment[],\n  memo: MemoState,\n  line: number,\n  column: number,\n  bias: Bias,\n): number {\n  let index = memoizedBinarySearch(segments, column, memo, line);\n  if (bsFound) {\n    index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);\n  } else if (bias === LEAST_UPPER_BOUND) index++;\n\n  if (index === -1 || index === segments.length) return -1;\n  return index;\n}\n\nfunction sliceGeneratedPositions(\n  segments: ReverseSegment[],\n  memo: MemoState,\n  line: number,\n  column: number,\n  bias: Bias,\n): GeneratedMapping[] {\n  let min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);\n\n  // We ignored the bias when tracing the segment so that we're guarnateed to find the first (in\n  // insertion order) segment that matched. Even if we did respect the bias when tracing, we would\n  // still need to call `lowerBound()` to find the first segment, which is slower than just looking\n  // for the GREATEST_LOWER_BOUND to begin with. The only difference that matters for us is when the\n  // binary search didn't match, in which case GREATEST_LOWER_BOUND just needs to increment to\n  // match LEAST_UPPER_BOUND.\n  if (!bsFound && bias === LEAST_UPPER_BOUND) min++;\n\n  if (min === -1 || min === segments.length) return [];\n\n  // We may have found the segment that started at an earlier column. If this is the case, then we\n  // need to slice all generated segments that match _that_ column, because all such segments span\n  // to our desired column.\n  const matchedColumn = bsFound ? column : segments[min][COLUMN];\n\n  // The binary search is not guaranteed to find the lower bound when a match wasn't found.\n  if (!bsFound) min = lowerBound(segments, matchedColumn, min);\n  const max = upperBound(segments, matchedColumn, min);\n\n  const result = [];\n  for (; min <= max; min++) {\n    const segment = segments[min];\n    result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));\n  }\n  return result;\n}\n","// Matches the scheme of a URL, eg \"http://\"\nconst schemeRegex = /^[\\w+.-]+:\\/\\//;\n/**\n * Matches the parts of a URL:\n * 1. Scheme, including \":\", guaranteed.\n * 2. User/password, including \"@\", optional.\n * 3. Host, guaranteed.\n * 4. Port, including \":\", optional.\n * 5. Path, including \"/\", optional.\n * 6. Query, including \"?\", optional.\n * 7. Hash, including \"#\", optional.\n */\nconst urlRegex = /^([\\w+.-]+:)\\/\\/([^@/#?]*@)?([^:/#?]*)(:\\d+)?(\\/[^#?]*)?(\\?[^#]*)?(#.*)?/;\n/**\n * File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start\n * with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).\n *\n * 1. Host, optional.\n * 2. Path, which may include \"/\", guaranteed.\n * 3. Query, including \"?\", optional.\n * 4. Hash, including \"#\", optional.\n */\nconst fileRegex = /^file:(?:\\/\\/((?![a-z]:)[^/#?]*)?)?(\\/?[^#?]*)(\\?[^#]*)?(#.*)?/i;\nvar UrlType;\n(function (UrlType) {\n    UrlType[UrlType[\"Empty\"] = 1] = \"Empty\";\n    UrlType[UrlType[\"Hash\"] = 2] = \"Hash\";\n    UrlType[UrlType[\"Query\"] = 3] = \"Query\";\n    UrlType[UrlType[\"RelativePath\"] = 4] = \"RelativePath\";\n    UrlType[UrlType[\"AbsolutePath\"] = 5] = \"AbsolutePath\";\n    UrlType[UrlType[\"SchemeRelative\"] = 6] = \"SchemeRelative\";\n    UrlType[UrlType[\"Absolute\"] = 7] = \"Absolute\";\n})(UrlType || (UrlType = {}));\nfunction isAbsoluteUrl(input) {\n    return schemeRegex.test(input);\n}\nfunction isSchemeRelativeUrl(input) {\n    return input.startsWith('//');\n}\nfunction isAbsolutePath(input) {\n    return input.startsWith('/');\n}\nfunction isFileUrl(input) {\n    return input.startsWith('file:');\n}\nfunction isRelative(input) {\n    return /^[.?#]/.test(input);\n}\nfunction parseAbsoluteUrl(input) {\n    const match = urlRegex.exec(input);\n    return makeUrl(match[1], match[2] || '', match[3], match[4] || '', match[5] || '/', match[6] || '', match[7] || '');\n}\nfunction parseFileUrl(input) {\n    const match = fileRegex.exec(input);\n    const path = match[2];\n    return makeUrl('file:', '', match[1] || '', '', isAbsolutePath(path) ? path : '/' + path, match[3] || '', match[4] || '');\n}\nfunction makeUrl(scheme, user, host, port, path, query, hash) {\n    return {\n        scheme,\n        user,\n        host,\n        port,\n        path,\n        query,\n        hash,\n        type: UrlType.Absolute,\n    };\n}\nfunction parseUrl(input) {\n    if (isSchemeRelativeUrl(input)) {\n        const url = parseAbsoluteUrl('http:' + input);\n        url.scheme = '';\n        url.type = UrlType.SchemeRelative;\n        return url;\n    }\n    if (isAbsolutePath(input)) {\n        const url = parseAbsoluteUrl('http://foo.com' + input);\n        url.scheme = '';\n        url.host = '';\n        url.type = UrlType.AbsolutePath;\n        return url;\n    }\n    if (isFileUrl(input))\n        return parseFileUrl(input);\n    if (isAbsoluteUrl(input))\n        return parseAbsoluteUrl(input);\n    const url = parseAbsoluteUrl('http://foo.com/' + input);\n    url.scheme = '';\n    url.host = '';\n    url.type = input\n        ? input.startsWith('?')\n            ? UrlType.Query\n            : input.startsWith('#')\n                ? UrlType.Hash\n                : UrlType.RelativePath\n        : UrlType.Empty;\n    return url;\n}\nfunction stripPathFilename(path) {\n    // If a path ends with a parent directory \"..\", then it's a relative path with excess parent\n    // paths. It's not a file, so we can't strip it.\n    if (path.endsWith('/..'))\n        return path;\n    const index = path.lastIndexOf('/');\n    return path.slice(0, index + 1);\n}\nfunction mergePaths(url, base) {\n    normalizePath(base, base.type);\n    // If the path is just a \"/\", then it was an empty path to begin with (remember, we're a relative\n    // path).\n    if (url.path === '/') {\n        url.path = base.path;\n    }\n    else {\n        // Resolution happens relative to the base path's directory, not the file.\n        url.path = stripPathFilename(base.path) + url.path;\n    }\n}\n/**\n * The path can have empty directories \"//\", unneeded parents \"foo/..\", or current directory\n * \"foo/.\". We need to normalize to a standard representation.\n */\nfunction normalizePath(url, type) {\n    const rel = type <= UrlType.RelativePath;\n    const pieces = url.path.split('/');\n    // We need to preserve the first piece always, so that we output a leading slash. The item at\n    // pieces[0] is an empty string.\n    let pointer = 1;\n    // Positive is the number of real directories we've output, used for popping a parent directory.\n    // Eg, \"foo/bar/..\" will have a positive 2, and we can decrement to be left with just \"foo\".\n    let positive = 0;\n    // We need to keep a trailing slash if we encounter an empty directory (eg, splitting \"foo/\" will\n    // generate `[\"foo\", \"\"]` pieces). And, if we pop a parent directory. But once we encounter a\n    // real directory, we won't need to append, unless the other conditions happen again.\n    let addTrailingSlash = false;\n    for (let i = 1; i < pieces.length; i++) {\n        const piece = pieces[i];\n        // An empty directory, could be a trailing slash, or just a double \"//\" in the path.\n        if (!piece) {\n            addTrailingSlash = true;\n            continue;\n        }\n        // If we encounter a real directory, then we don't need to append anymore.\n        addTrailingSlash = false;\n        // A current directory, which we can always drop.\n        if (piece === '.')\n            continue;\n        // A parent directory, we need to see if there are any real directories we can pop. Else, we\n        // have an excess of parents, and we'll need to keep the \"..\".\n        if (piece === '..') {\n            if (positive) {\n                addTrailingSlash = true;\n                positive--;\n                pointer--;\n            }\n            else if (rel) {\n                // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute\n                // URL, protocol relative URL, or an absolute path, we don't need to keep excess.\n                pieces[pointer++] = piece;\n            }\n            continue;\n        }\n        // We've encountered a real directory. Move it to the next insertion pointer, which accounts for\n        // any popped or dropped directories.\n        pieces[pointer++] = piece;\n        positive++;\n    }\n    let path = '';\n    for (let i = 1; i < pointer; i++) {\n        path += '/' + pieces[i];\n    }\n    if (!path || (addTrailingSlash && !path.endsWith('/..'))) {\n        path += '/';\n    }\n    url.path = path;\n}\n/**\n * Attempts to resolve `input` URL/path relative to `base`.\n */\nfunction resolve(input, base) {\n    if (!input && !base)\n        return '';\n    const url = parseUrl(input);\n    let inputType = url.type;\n    if (base && inputType !== UrlType.Absolute) {\n        const baseUrl = parseUrl(base);\n        const baseType = baseUrl.type;\n        switch (inputType) {\n            case UrlType.Empty:\n                url.hash = baseUrl.hash;\n            // fall through\n            case UrlType.Hash:\n                url.query = baseUrl.query;\n            // fall through\n            case UrlType.Query:\n            case UrlType.RelativePath:\n                mergePaths(url, baseUrl);\n            // fall through\n            case UrlType.AbsolutePath:\n                // The host, user, and port are joined, you can't copy one without the others.\n                url.user = baseUrl.user;\n                url.host = baseUrl.host;\n                url.port = baseUrl.port;\n            // fall through\n            case UrlType.SchemeRelative:\n                // The input doesn't have a schema at least, so we need to copy at least that over.\n                url.scheme = baseUrl.scheme;\n        }\n        if (baseType > inputType)\n            inputType = baseType;\n    }\n    normalizePath(url, inputType);\n    const queryHash = url.query + url.hash;\n    switch (inputType) {\n        // This is impossible, because of the empty checks at the start of the function.\n        // case UrlType.Empty:\n        case UrlType.Hash:\n        case UrlType.Query:\n            return queryHash;\n        case UrlType.RelativePath: {\n            // The first char is always a \"/\", and we need it to be relative.\n            const path = url.path.slice(1);\n            if (!path)\n                return queryHash || '.';\n            if (isRelative(base || input) && !isRelative(path)) {\n                // If base started with a leading \".\", or there is no base and input started with a \".\",\n                // then we need to ensure that the relative path starts with a \".\". We don't know if\n                // relative starts with a \"..\", though, so check before prepending.\n                return './' + path + queryHash;\n            }\n            return path + queryHash;\n        }\n        case UrlType.AbsolutePath:\n            return url.path + queryHash;\n        default:\n            return url.scheme + '//' + url.user + url.host + url.port + url.path + queryHash;\n    }\n}\n\nexport { resolve as default };\n//# sourceMappingURL=resolve-uri.mjs.map\n","// Matches the scheme of a URL, eg \"http://\"\nconst schemeRegex = /^[\\w+.-]+:\\/\\//;\n\n/**\n * Matches the parts of a URL:\n * 1. Scheme, including \":\", guaranteed.\n * 2. User/password, including \"@\", optional.\n * 3. Host, guaranteed.\n * 4. Port, including \":\", optional.\n * 5. Path, including \"/\", optional.\n * 6. Query, including \"?\", optional.\n * 7. Hash, including \"#\", optional.\n */\nconst urlRegex = /^([\\w+.-]+:)\\/\\/([^@/#?]*@)?([^:/#?]*)(:\\d+)?(\\/[^#?]*)?(\\?[^#]*)?(#.*)?/;\n\n/**\n * File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start\n * with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).\n *\n * 1. Host, optional.\n * 2. Path, which may include \"/\", guaranteed.\n * 3. Query, including \"?\", optional.\n * 4. Hash, including \"#\", optional.\n */\nconst fileRegex = /^file:(?:\\/\\/((?![a-z]:)[^/#?]*)?)?(\\/?[^#?]*)(\\?[^#]*)?(#.*)?/i;\n\ntype Url = {\n  scheme: string;\n  user: string;\n  host: string;\n  port: string;\n  path: string;\n  query: string;\n  hash: string;\n  type: UrlType;\n};\n\nenum UrlType {\n  Empty = 1,\n  Hash = 2,\n  Query = 3,\n  RelativePath = 4,\n  AbsolutePath = 5,\n  SchemeRelative = 6,\n  Absolute = 7,\n}\n\nfunction isAbsoluteUrl(input: string): boolean {\n  return schemeRegex.test(input);\n}\n\nfunction isSchemeRelativeUrl(input: string): boolean {\n  return input.startsWith('//');\n}\n\nfunction isAbsolutePath(input: string): boolean {\n  return input.startsWith('/');\n}\n\nfunction isFileUrl(input: string): boolean {\n  return input.startsWith('file:');\n}\n\nfunction isRelative(input: string): boolean {\n  return /^[.?#]/.test(input);\n}\n\nfunction parseAbsoluteUrl(input: string): Url {\n  const match = urlRegex.exec(input)!;\n  return makeUrl(\n    match[1],\n    match[2] || '',\n    match[3],\n    match[4] || '',\n    match[5] || '/',\n    match[6] || '',\n    match[7] || '',\n  );\n}\n\nfunction parseFileUrl(input: string): Url {\n  const match = fileRegex.exec(input)!;\n  const path = match[2];\n  return makeUrl(\n    'file:',\n    '',\n    match[1] || '',\n    '',\n    isAbsolutePath(path) ? path : '/' + path,\n    match[3] || '',\n    match[4] || '',\n  );\n}\n\nfunction makeUrl(\n  scheme: string,\n  user: string,\n  host: string,\n  port: string,\n  path: string,\n  query: string,\n  hash: string,\n): Url {\n  return {\n    scheme,\n    user,\n    host,\n    port,\n    path,\n    query,\n    hash,\n    type: UrlType.Absolute,\n  };\n}\n\nfunction parseUrl(input: string): Url {\n  if (isSchemeRelativeUrl(input)) {\n    const url = parseAbsoluteUrl('http:' + input);\n    url.scheme = '';\n    url.type = UrlType.SchemeRelative;\n    return url;\n  }\n\n  if (isAbsolutePath(input)) {\n    const url = parseAbsoluteUrl('http://foo.com' + input);\n    url.scheme = '';\n    url.host = '';\n    url.type = UrlType.AbsolutePath;\n    return url;\n  }\n\n  if (isFileUrl(input)) return parseFileUrl(input);\n\n  if (isAbsoluteUrl(input)) return parseAbsoluteUrl(input);\n\n  const url = parseAbsoluteUrl('http://foo.com/' + input);\n  url.scheme = '';\n  url.host = '';\n  url.type = input\n    ? input.startsWith('?')\n      ? UrlType.Query\n      : input.startsWith('#')\n      ? UrlType.Hash\n      : UrlType.RelativePath\n    : UrlType.Empty;\n  return url;\n}\n\nfunction stripPathFilename(path: string): string {\n  // If a path ends with a parent directory \"..\", then it's a relative path with excess parent\n  // paths. It's not a file, so we can't strip it.\n  if (path.endsWith('/..')) return path;\n  const index = path.lastIndexOf('/');\n  return path.slice(0, index + 1);\n}\n\nfunction mergePaths(url: Url, base: Url) {\n  normalizePath(base, base.type);\n\n  // If the path is just a \"/\", then it was an empty path to begin with (remember, we're a relative\n  // path).\n  if (url.path === '/') {\n    url.path = base.path;\n  } else {\n    // Resolution happens relative to the base path's directory, not the file.\n    url.path = stripPathFilename(base.path) + url.path;\n  }\n}\n\n/**\n * The path can have empty directories \"//\", unneeded parents \"foo/..\", or current directory\n * \"foo/.\". We need to normalize to a standard representation.\n */\nfunction normalizePath(url: Url, type: UrlType) {\n  const rel = type <= UrlType.RelativePath;\n  const pieces = url.path.split('/');\n\n  // We need to preserve the first piece always, so that we output a leading slash. The item at\n  // pieces[0] is an empty string.\n  let pointer = 1;\n\n  // Positive is the number of real directories we've output, used for popping a parent directory.\n  // Eg, \"foo/bar/..\" will have a positive 2, and we can decrement to be left with just \"foo\".\n  let positive = 0;\n\n  // We need to keep a trailing slash if we encounter an empty directory (eg, splitting \"foo/\" will\n  // generate `[\"foo\", \"\"]` pieces). And, if we pop a parent directory. But once we encounter a\n  // real directory, we won't need to append, unless the other conditions happen again.\n  let addTrailingSlash = false;\n\n  for (let i = 1; i < pieces.length; i++) {\n    const piece = pieces[i];\n\n    // An empty directory, could be a trailing slash, or just a double \"//\" in the path.\n    if (!piece) {\n      addTrailingSlash = true;\n      continue;\n    }\n\n    // If we encounter a real directory, then we don't need to append anymore.\n    addTrailingSlash = false;\n\n    // A current directory, which we can always drop.\n    if (piece === '.') continue;\n\n    // A parent directory, we need to see if there are any real directories we can pop. Else, we\n    // have an excess of parents, and we'll need to keep the \"..\".\n    if (piece === '..') {\n      if (positive) {\n        addTrailingSlash = true;\n        positive--;\n        pointer--;\n      } else if (rel) {\n        // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute\n        // URL, protocol relative URL, or an absolute path, we don't need to keep excess.\n        pieces[pointer++] = piece;\n      }\n      continue;\n    }\n\n    // We've encountered a real directory. Move it to the next insertion pointer, which accounts for\n    // any popped or dropped directories.\n    pieces[pointer++] = piece;\n    positive++;\n  }\n\n  let path = '';\n  for (let i = 1; i < pointer; i++) {\n    path += '/' + pieces[i];\n  }\n  if (!path || (addTrailingSlash && !path.endsWith('/..'))) {\n    path += '/';\n  }\n  url.path = path;\n}\n\n/**\n * Attempts to resolve `input` URL/path relative to `base`.\n */\nexport default function resolve(input: string, base: string | undefined): string {\n  if (!input && !base) return '';\n\n  const url = parseUrl(input);\n  let inputType = url.type;\n\n  if (base && inputType !== UrlType.Absolute) {\n    const baseUrl = parseUrl(base);\n    const baseType = baseUrl.type;\n\n    switch (inputType) {\n      case UrlType.Empty:\n        url.hash = baseUrl.hash;\n      // fall through\n\n      case UrlType.Hash:\n        url.query = baseUrl.query;\n      // fall through\n\n      case UrlType.Query:\n      case UrlType.RelativePath:\n        mergePaths(url, baseUrl);\n      // fall through\n\n      case UrlType.AbsolutePath:\n        // The host, user, and port are joined, you can't copy one without the others.\n        url.user = baseUrl.user;\n        url.host = baseUrl.host;\n        url.port = baseUrl.port;\n      // fall through\n\n      case UrlType.SchemeRelative:\n        // The input doesn't have a schema at least, so we need to copy at least that over.\n        url.scheme = baseUrl.scheme;\n    }\n    if (baseType > inputType) inputType = baseType;\n  }\n\n  normalizePath(url, inputType);\n\n  const queryHash = url.query + url.hash;\n  switch (inputType) {\n    // This is impossible, because of the empty checks at the start of the function.\n    // case UrlType.Empty:\n\n    case UrlType.Hash:\n    case UrlType.Query:\n      return queryHash;\n\n    case UrlType.RelativePath: {\n      // The first char is always a \"/\", and we need it to be relative.\n      const path = url.path.slice(1);\n\n      if (!path) return queryHash || '.';\n\n      if (isRelative(base || input) && !isRelative(path)) {\n        // If base started with a leading \".\", or there is no base and input started with a \".\",\n        // then we need to ensure that the relative path starts with a \".\". We don't know if\n        // relative starts with a \"..\", though, so check before prepending.\n        return './' + path + queryHash;\n      }\n\n      return path + queryHash;\n    }\n\n    case UrlType.AbsolutePath:\n      return url.path + queryHash;\n\n    default:\n      return url.scheme + '//' + url.user + url.host + url.port + url.path + queryHash;\n  }\n}\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _buffer = require(\"./buffer.js\");\nvar n = require(\"./node/index.js\");\nvar _t = require(\"@babel/types\");\nvar generatorFunctions = require(\"./generators/index.js\");\nconst {\n  isFunction,\n  isStatement,\n  isClassBody,\n  isTSInterfaceBody,\n  isTSEnumDeclaration\n} = _t;\nconst SCIENTIFIC_NOTATION = /e/i;\nconst ZERO_DECIMAL_INTEGER = /\\.0+$/;\nconst NON_DECIMAL_LITERAL = /^0[box]/;\nconst PURE_ANNOTATION_RE = /^\\s*[@#]__PURE__\\s*$/;\nconst HAS_NEWLINE = /[\\n\\r\\u2028\\u2029]/;\nconst HAS_BlOCK_COMMENT_END = /\\*\\//;\nconst {\n  needsParens\n} = n;\nclass Printer {\n  constructor(format, map) {\n    this.inForStatementInitCounter = 0;\n    this._printStack = [];\n    this._indent = 0;\n    this._indentChar = 0;\n    this._indentRepeat = 0;\n    this._insideAux = false;\n    this._parenPushNewlineState = null;\n    this._noLineTerminator = false;\n    this._printAuxAfterOnNextUserNode = false;\n    this._printedComments = new Set();\n    this._endsWithInteger = false;\n    this._endsWithWord = false;\n    this._lastCommentLine = 0;\n    this._endsWithInnerRaw = false;\n    this._indentInnerComments = true;\n    this.format = format;\n    this._buf = new _buffer.default(map);\n    this._indentChar = format.indent.style.charCodeAt(0);\n    this._indentRepeat = format.indent.style.length;\n    this._inputMap = map == null ? void 0 : map._inputMap;\n  }\n  generate(ast) {\n    this.print(ast);\n    this._maybeAddAuxComment();\n    return this._buf.get();\n  }\n  indent() {\n    if (this.format.compact || this.format.concise) return;\n    this._indent++;\n  }\n  dedent() {\n    if (this.format.compact || this.format.concise) return;\n    this._indent--;\n  }\n  semicolon(force = false) {\n    this._maybeAddAuxComment();\n    if (force) {\n      this._appendChar(59);\n    } else {\n      this._queue(59);\n    }\n    this._noLineTerminator = false;\n  }\n  rightBrace(node) {\n    if (this.format.minified) {\n      this._buf.removeLastSemicolon();\n    }\n    this.sourceWithOffset(\"end\", node.loc, -1);\n    this.tokenChar(125);\n  }\n  rightParens(node) {\n    this.sourceWithOffset(\"end\", node.loc, -1);\n    this.tokenChar(41);\n  }\n  space(force = false) {\n    if (this.format.compact) return;\n    if (force) {\n      this._space();\n    } else if (this._buf.hasContent()) {\n      const lastCp = this.getLastChar();\n      if (lastCp !== 32 && lastCp !== 10) {\n        this._space();\n      }\n    }\n  }\n  word(str, noLineTerminatorAfter = false) {\n    this._maybePrintInnerComments();\n    if (this._endsWithWord || str.charCodeAt(0) === 47 && this.endsWith(47)) {\n      this._space();\n    }\n    this._maybeAddAuxComment();\n    this._append(str, false);\n    this._endsWithWord = true;\n    this._noLineTerminator = noLineTerminatorAfter;\n  }\n  number(str) {\n    this.word(str);\n    this._endsWithInteger = Number.isInteger(+str) && !NON_DECIMAL_LITERAL.test(str) && !SCIENTIFIC_NOTATION.test(str) && !ZERO_DECIMAL_INTEGER.test(str) && str.charCodeAt(str.length - 1) !== 46;\n  }\n  token(str, maybeNewline = false) {\n    this._maybePrintInnerComments();\n    const lastChar = this.getLastChar();\n    const strFirst = str.charCodeAt(0);\n    if (lastChar === 33 && (str === \"--\" || strFirst === 61) || strFirst === 43 && lastChar === 43 || strFirst === 45 && lastChar === 45 || strFirst === 46 && this._endsWithInteger) {\n      this._space();\n    }\n    this._maybeAddAuxComment();\n    this._append(str, maybeNewline);\n    this._noLineTerminator = false;\n  }\n  tokenChar(char) {\n    this._maybePrintInnerComments();\n    const lastChar = this.getLastChar();\n    if (char === 43 && lastChar === 43 || char === 45 && lastChar === 45 || char === 46 && this._endsWithInteger) {\n      this._space();\n    }\n    this._maybeAddAuxComment();\n    this._appendChar(char);\n    this._noLineTerminator = false;\n  }\n  newline(i = 1, force) {\n    if (i <= 0) return;\n    if (!force) {\n      if (this.format.retainLines || this.format.compact) return;\n      if (this.format.concise) {\n        this.space();\n        return;\n      }\n    }\n    if (i > 2) i = 2;\n    i -= this._buf.getNewlineCount();\n    for (let j = 0; j < i; j++) {\n      this._newline();\n    }\n    return;\n  }\n  endsWith(char) {\n    return this.getLastChar() === char;\n  }\n  getLastChar() {\n    return this._buf.getLastChar();\n  }\n  endsWithCharAndNewline() {\n    return this._buf.endsWithCharAndNewline();\n  }\n  removeTrailingNewline() {\n    this._buf.removeTrailingNewline();\n  }\n  exactSource(loc, cb) {\n    if (!loc) {\n      cb();\n      return;\n    }\n    this._catchUp(\"start\", loc);\n    this._buf.exactSource(loc, cb);\n  }\n  source(prop, loc) {\n    if (!loc) return;\n    this._catchUp(prop, loc);\n    this._buf.source(prop, loc);\n  }\n  sourceWithOffset(prop, loc, columnOffset) {\n    if (!loc) return;\n    this._catchUp(prop, loc);\n    this._buf.sourceWithOffset(prop, loc, columnOffset);\n  }\n  withSource(prop, loc, cb) {\n    if (!loc) {\n      cb();\n      return;\n    }\n    this._catchUp(prop, loc);\n    this._buf.withSource(prop, loc, cb);\n  }\n  sourceIdentifierName(identifierName, pos) {\n    if (!this._buf._canMarkIdName) return;\n    const sourcePosition = this._buf._sourcePosition;\n    sourcePosition.identifierNamePos = pos;\n    sourcePosition.identifierName = identifierName;\n  }\n  _space() {\n    this._queue(32);\n  }\n  _newline() {\n    this._queue(10);\n  }\n  _append(str, maybeNewline) {\n    this._maybeAddParen(str);\n    this._maybeIndent(str.charCodeAt(0));\n    this._buf.append(str, maybeNewline);\n    this._endsWithWord = false;\n    this._endsWithInteger = false;\n  }\n  _appendChar(char) {\n    this._maybeAddParenChar(char);\n    this._maybeIndent(char);\n    this._buf.appendChar(char);\n    this._endsWithWord = false;\n    this._endsWithInteger = false;\n  }\n  _queue(char) {\n    this._maybeAddParenChar(char);\n    this._maybeIndent(char);\n    this._buf.queue(char);\n    this._endsWithWord = false;\n    this._endsWithInteger = false;\n  }\n  _maybeIndent(firstChar) {\n    if (this._indent && firstChar !== 10 && this.endsWith(10)) {\n      this._buf.queueIndentation(this._indentChar, this._getIndent());\n    }\n  }\n  _shouldIndent(firstChar) {\n    if (this._indent && firstChar !== 10 && this.endsWith(10)) {\n      return true;\n    }\n  }\n  _maybeAddParenChar(char) {\n    const parenPushNewlineState = this._parenPushNewlineState;\n    if (!parenPushNewlineState) return;\n    if (char === 32) {\n      return;\n    }\n    if (char !== 10) {\n      this._parenPushNewlineState = null;\n      return;\n    }\n    this.tokenChar(40);\n    this.indent();\n    parenPushNewlineState.printed = true;\n  }\n  _maybeAddParen(str) {\n    const parenPushNewlineState = this._parenPushNewlineState;\n    if (!parenPushNewlineState) return;\n    const len = str.length;\n    let i;\n    for (i = 0; i < len && str.charCodeAt(i) === 32; i++) continue;\n    if (i === len) {\n      return;\n    }\n    const cha = str.charCodeAt(i);\n    if (cha !== 10) {\n      if (cha !== 47 || i + 1 === len) {\n        this._parenPushNewlineState = null;\n        return;\n      }\n      const chaPost = str.charCodeAt(i + 1);\n      if (chaPost === 42) {\n        if (PURE_ANNOTATION_RE.test(str.slice(i + 2, len - 2))) {\n          return;\n        }\n      } else if (chaPost !== 47) {\n        this._parenPushNewlineState = null;\n        return;\n      }\n    }\n    this.tokenChar(40);\n    this.indent();\n    parenPushNewlineState.printed = true;\n  }\n  catchUp(line) {\n    if (!this.format.retainLines) return;\n    const count = line - this._buf.getCurrentLine();\n    for (let i = 0; i < count; i++) {\n      this._newline();\n    }\n  }\n  _catchUp(prop, loc) {\n    var _loc$prop;\n    if (!this.format.retainLines) return;\n    const line = loc == null || (_loc$prop = loc[prop]) == null ? void 0 : _loc$prop.line;\n    if (line != null) {\n      const count = line - this._buf.getCurrentLine();\n      for (let i = 0; i < count; i++) {\n        this._newline();\n      }\n    }\n  }\n  _getIndent() {\n    return this._indentRepeat * this._indent;\n  }\n  printTerminatorless(node, parent, isLabel) {\n    if (isLabel) {\n      this._noLineTerminator = true;\n      this.print(node, parent);\n    } else {\n      const terminatorState = {\n        printed: false\n      };\n      this._parenPushNewlineState = terminatorState;\n      this.print(node, parent);\n      if (terminatorState.printed) {\n        this.dedent();\n        this.newline();\n        this.tokenChar(41);\n      }\n    }\n  }\n  print(node, parent, noLineTerminatorAfter, trailingCommentsLineOffset, forceParens) {\n    var _node$extra;\n    if (!node) return;\n    this._endsWithInnerRaw = false;\n    const nodeType = node.type;\n    const format = this.format;\n    const oldConcise = format.concise;\n    if (node._compact) {\n      format.concise = true;\n    }\n    const printMethod = this[nodeType];\n    if (printMethod === undefined) {\n      throw new ReferenceError(`unknown node of type ${JSON.stringify(nodeType)} with constructor ${JSON.stringify(node.constructor.name)}`);\n    }\n    this._printStack.push(node);\n    const oldInAux = this._insideAux;\n    this._insideAux = node.loc == undefined;\n    this._maybeAddAuxComment(this._insideAux && !oldInAux);\n    const shouldPrintParens = forceParens || format.retainFunctionParens && nodeType === \"FunctionExpression\" && ((_node$extra = node.extra) == null ? void 0 : _node$extra.parenthesized) || needsParens(node, parent, this._printStack);\n    if (shouldPrintParens) {\n      this.tokenChar(40);\n      this._endsWithInnerRaw = false;\n    }\n    this._lastCommentLine = 0;\n    this._printLeadingComments(node, parent);\n    const loc = nodeType === \"Program\" || nodeType === \"File\" ? null : node.loc;\n    this.exactSource(loc, printMethod.bind(this, node, parent));\n    if (shouldPrintParens) {\n      this._printTrailingComments(node, parent);\n      this.tokenChar(41);\n      this._noLineTerminator = noLineTerminatorAfter;\n    } else if (noLineTerminatorAfter && !this._noLineTerminator) {\n      this._noLineTerminator = true;\n      this._printTrailingComments(node, parent);\n    } else {\n      this._printTrailingComments(node, parent, trailingCommentsLineOffset);\n    }\n    this._printStack.pop();\n    format.concise = oldConcise;\n    this._insideAux = oldInAux;\n    this._endsWithInnerRaw = false;\n  }\n  _maybeAddAuxComment(enteredPositionlessNode) {\n    if (enteredPositionlessNode) this._printAuxBeforeComment();\n    if (!this._insideAux) this._printAuxAfterComment();\n  }\n  _printAuxBeforeComment() {\n    if (this._printAuxAfterOnNextUserNode) return;\n    this._printAuxAfterOnNextUserNode = true;\n    const comment = this.format.auxiliaryCommentBefore;\n    if (comment) {\n      this._printComment({\n        type: \"CommentBlock\",\n        value: comment\n      }, 0);\n    }\n  }\n  _printAuxAfterComment() {\n    if (!this._printAuxAfterOnNextUserNode) return;\n    this._printAuxAfterOnNextUserNode = false;\n    const comment = this.format.auxiliaryCommentAfter;\n    if (comment) {\n      this._printComment({\n        type: \"CommentBlock\",\n        value: comment\n      }, 0);\n    }\n  }\n  getPossibleRaw(node) {\n    const extra = node.extra;\n    if ((extra == null ? void 0 : extra.raw) != null && extra.rawValue != null && node.value === extra.rawValue) {\n      return extra.raw;\n    }\n  }\n  printJoin(nodes, parent, opts = {}) {\n    if (!(nodes != null && nodes.length)) return;\n    let {\n      indent\n    } = opts;\n    if (indent == null && this.format.retainLines) {\n      var _nodes$0$loc;\n      const startLine = (_nodes$0$loc = nodes[0].loc) == null ? void 0 : _nodes$0$loc.start.line;\n      if (startLine != null && startLine !== this._buf.getCurrentLine()) {\n        indent = true;\n      }\n    }\n    if (indent) this.indent();\n    const newlineOpts = {\n      addNewlines: opts.addNewlines,\n      nextNodeStartLine: 0\n    };\n    const separator = opts.separator ? opts.separator.bind(this) : null;\n    const len = nodes.length;\n    for (let i = 0; i < len; i++) {\n      const node = nodes[i];\n      if (!node) continue;\n      if (opts.statement) this._printNewline(i === 0, newlineOpts);\n      this.print(node, parent, undefined, opts.trailingCommentsLineOffset || 0);\n      opts.iterator == null ? void 0 : opts.iterator(node, i);\n      if (i < len - 1) separator == null ? void 0 : separator();\n      if (opts.statement) {\n        if (i + 1 === len) {\n          this.newline(1);\n        } else {\n          var _nextNode$loc;\n          const nextNode = nodes[i + 1];\n          newlineOpts.nextNodeStartLine = ((_nextNode$loc = nextNode.loc) == null ? void 0 : _nextNode$loc.start.line) || 0;\n          this._printNewline(true, newlineOpts);\n        }\n      }\n    }\n    if (indent) this.dedent();\n  }\n  printAndIndentOnComments(node, parent) {\n    const indent = node.leadingComments && node.leadingComments.length > 0;\n    if (indent) this.indent();\n    this.print(node, parent);\n    if (indent) this.dedent();\n  }\n  printBlock(parent) {\n    const node = parent.body;\n    if (node.type !== \"EmptyStatement\") {\n      this.space();\n    }\n    this.print(node, parent);\n  }\n  _printTrailingComments(node, parent, lineOffset) {\n    const {\n      innerComments,\n      trailingComments\n    } = node;\n    if (innerComments != null && innerComments.length) {\n      this._printComments(2, innerComments, node, parent, lineOffset);\n    }\n    if (trailingComments != null && trailingComments.length) {\n      this._printComments(2, trailingComments, node, parent, lineOffset);\n    }\n  }\n  _printLeadingComments(node, parent) {\n    const comments = node.leadingComments;\n    if (!(comments != null && comments.length)) return;\n    this._printComments(0, comments, node, parent);\n  }\n  _maybePrintInnerComments() {\n    if (this._endsWithInnerRaw) this.printInnerComments();\n    this._endsWithInnerRaw = true;\n    this._indentInnerComments = true;\n  }\n  printInnerComments() {\n    const node = this._printStack[this._printStack.length - 1];\n    const comments = node.innerComments;\n    if (!(comments != null && comments.length)) return;\n    const hasSpace = this.endsWith(32);\n    const indent = this._indentInnerComments;\n    const printedCommentsCount = this._printedComments.size;\n    if (indent) this.indent();\n    this._printComments(1, comments, node);\n    if (hasSpace && printedCommentsCount !== this._printedComments.size) {\n      this.space();\n    }\n    if (indent) this.dedent();\n  }\n  noIndentInnerCommentsHere() {\n    this._indentInnerComments = false;\n  }\n  printSequence(nodes, parent, opts = {}) {\n    var _opts$indent;\n    opts.statement = true;\n    (_opts$indent = opts.indent) != null ? _opts$indent : opts.indent = false;\n    this.printJoin(nodes, parent, opts);\n  }\n  printList(items, parent, opts = {}) {\n    if (opts.separator == null) {\n      opts.separator = commaSeparator;\n    }\n    this.printJoin(items, parent, opts);\n  }\n  _printNewline(newLine, opts) {\n    const format = this.format;\n    if (format.retainLines || format.compact) return;\n    if (format.concise) {\n      this.space();\n      return;\n    }\n    if (!newLine) {\n      return;\n    }\n    const startLine = opts.nextNodeStartLine;\n    const lastCommentLine = this._lastCommentLine;\n    if (startLine > 0 && lastCommentLine > 0) {\n      const offset = startLine - lastCommentLine;\n      if (offset >= 0) {\n        this.newline(offset || 1);\n        return;\n      }\n    }\n    if (this._buf.hasContent()) {\n      this.newline(1);\n    }\n  }\n  _shouldPrintComment(comment) {\n    if (comment.ignore) return 0;\n    if (this._printedComments.has(comment)) return 0;\n    if (this._noLineTerminator && (HAS_NEWLINE.test(comment.value) || HAS_BlOCK_COMMENT_END.test(comment.value))) {\n      return 2;\n    }\n    this._printedComments.add(comment);\n    if (!this.format.shouldPrintComment(comment.value)) {\n      return 0;\n    }\n    return 1;\n  }\n  _printComment(comment, skipNewLines) {\n    const noLineTerminator = this._noLineTerminator;\n    const isBlockComment = comment.type === \"CommentBlock\";\n    const printNewLines = isBlockComment && skipNewLines !== 1 && !this._noLineTerminator;\n    if (printNewLines && this._buf.hasContent() && skipNewLines !== 2) {\n      this.newline(1);\n    }\n    const lastCharCode = this.getLastChar();\n    if (lastCharCode !== 91 && lastCharCode !== 123) {\n      this.space();\n    }\n    let val;\n    if (isBlockComment) {\n      val = `/*${comment.value}*/`;\n      if (this.format.indent.adjustMultilineComment) {\n        var _comment$loc;\n        const offset = (_comment$loc = comment.loc) == null ? void 0 : _comment$loc.start.column;\n        if (offset) {\n          const newlineRegex = new RegExp(\"\\\\n\\\\s{1,\" + offset + \"}\", \"g\");\n          val = val.replace(newlineRegex, \"\\n\");\n        }\n        let indentSize = this.format.retainLines ? 0 : this._buf.getCurrentColumn();\n        if (this._shouldIndent(47) || this.format.retainLines) {\n          indentSize += this._getIndent();\n        }\n        val = val.replace(/\\n(?!$)/g, `\\n${\" \".repeat(indentSize)}`);\n      }\n    } else if (!noLineTerminator) {\n      val = `//${comment.value}`;\n    } else {\n      val = `/*${comment.value}*/`;\n    }\n    if (this.endsWith(47)) this._space();\n    this.source(\"start\", comment.loc);\n    this._append(val, isBlockComment);\n    if (!isBlockComment && !noLineTerminator) {\n      this.newline(1, true);\n    }\n    if (printNewLines && skipNewLines !== 3) {\n      this.newline(1);\n    }\n  }\n  _printComments(type, comments, node, parent, lineOffset = 0) {\n    const nodeLoc = node.loc;\n    const len = comments.length;\n    let hasLoc = !!nodeLoc;\n    const nodeStartLine = hasLoc ? nodeLoc.start.line : 0;\n    const nodeEndLine = hasLoc ? nodeLoc.end.line : 0;\n    let lastLine = 0;\n    let leadingCommentNewline = 0;\n    const maybeNewline = this._noLineTerminator ? function () {} : this.newline.bind(this);\n    for (let i = 0; i < len; i++) {\n      const comment = comments[i];\n      const shouldPrint = this._shouldPrintComment(comment);\n      if (shouldPrint === 2) {\n        hasLoc = false;\n        break;\n      }\n      if (hasLoc && comment.loc && shouldPrint === 1) {\n        const commentStartLine = comment.loc.start.line;\n        const commentEndLine = comment.loc.end.line;\n        if (type === 0) {\n          let offset = 0;\n          if (i === 0) {\n            if (this._buf.hasContent() && (comment.type === \"CommentLine\" || commentStartLine != commentEndLine)) {\n              offset = leadingCommentNewline = 1;\n            }\n          } else {\n            offset = commentStartLine - lastLine;\n          }\n          lastLine = commentEndLine;\n          maybeNewline(offset);\n          this._printComment(comment, 1);\n          if (i + 1 === len) {\n            maybeNewline(Math.max(nodeStartLine - lastLine, leadingCommentNewline));\n            lastLine = nodeStartLine;\n          }\n        } else if (type === 1) {\n          const offset = commentStartLine - (i === 0 ? nodeStartLine : lastLine);\n          lastLine = commentEndLine;\n          maybeNewline(offset);\n          this._printComment(comment, 1);\n          if (i + 1 === len) {\n            maybeNewline(Math.min(1, nodeEndLine - lastLine));\n            lastLine = nodeEndLine;\n          }\n        } else {\n          const offset = commentStartLine - (i === 0 ? nodeEndLine - lineOffset : lastLine);\n          lastLine = commentEndLine;\n          maybeNewline(offset);\n          this._printComment(comment, 1);\n        }\n      } else {\n        hasLoc = false;\n        if (shouldPrint !== 1) {\n          continue;\n        }\n        if (len === 1) {\n          const singleLine = comment.loc ? comment.loc.start.line === comment.loc.end.line : !HAS_NEWLINE.test(comment.value);\n          const shouldSkipNewline = singleLine && !isStatement(node) && !isClassBody(parent) && !isTSInterfaceBody(parent) && !isTSEnumDeclaration(parent);\n          if (type === 0) {\n            this._printComment(comment, shouldSkipNewline && node.type !== \"ObjectExpression\" || singleLine && isFunction(parent, {\n              body: node\n            }) ? 1 : 0);\n          } else if (shouldSkipNewline && type === 2) {\n            this._printComment(comment, 1);\n          } else {\n            this._printComment(comment, 0);\n          }\n        } else if (type === 1 && !(node.type === \"ObjectExpression\" && node.properties.length > 1) && node.type !== \"ClassBody\" && node.type !== \"TSInterfaceBody\") {\n          this._printComment(comment, i === 0 ? 2 : i === len - 1 ? 3 : 0);\n        } else {\n          this._printComment(comment, 0);\n        }\n      }\n    }\n    if (type === 2 && hasLoc && lastLine) {\n      this._lastCommentLine = lastLine;\n    }\n  }\n}\nObject.assign(Printer.prototype, generatorFunctions);\n{\n  Printer.prototype.Noop = function Noop() {};\n}\nvar _default = Printer;\nexports.default = _default;\nfunction commaSeparator() {\n  this.tokenChar(44);\n  this.space();\n}\n\n//# sourceMappingURL=printer.js.map\n","import Buffer, { type Pos } from \"./buffer.ts\";\nimport type { Loc } from \"./buffer.ts\";\nimport * as n from \"./node/index.ts\";\nimport type * as t from \"@babel/types\";\nimport {\n  isFunction,\n  isStatement,\n  isClassBody,\n  isTSInterfaceBody,\n  isTSEnumDeclaration,\n} from \"@babel/types\";\nimport type {\n  RecordAndTuplePluginOptions,\n  PipelineOperatorPluginOptions,\n} from \"@babel/parser\";\nimport type { Opts as jsescOptions } from \"jsesc\";\n\nimport * as generatorFunctions from \"./generators/index.ts\";\nimport type SourceMap from \"./source-map.ts\";\nimport * as charCodes from \"charcodes\";\nimport type { TraceMap } from \"@jridgewell/trace-mapping\";\n\nconst SCIENTIFIC_NOTATION = /e/i;\nconst ZERO_DECIMAL_INTEGER = /\\.0+$/;\nconst NON_DECIMAL_LITERAL = /^0[box]/;\nconst PURE_ANNOTATION_RE = /^\\s*[@#]__PURE__\\s*$/;\nconst HAS_NEWLINE = /[\\n\\r\\u2028\\u2029]/;\nconst HAS_BlOCK_COMMENT_END = /\\*\\//;\n\nconst { needsParens } = n;\n\nconst enum COMMENT_TYPE {\n  LEADING,\n  INNER,\n  TRAILING,\n}\n\nconst enum COMMENT_SKIP_NEWLINE {\n  DEFAULT,\n  ALL,\n  LEADING,\n  TRAILING,\n}\n\nconst enum PRINT_COMMENT_HINT {\n  SKIP,\n  ALLOW,\n  DEFER,\n}\n\nexport type Format = {\n  shouldPrintComment: (comment: string) => boolean;\n  retainLines: boolean;\n  retainFunctionParens: boolean;\n  comments: boolean;\n  auxiliaryCommentBefore: string;\n  auxiliaryCommentAfter: string;\n  compact: boolean | \"auto\";\n  minified: boolean;\n  concise: boolean;\n  indent: {\n    adjustMultilineComment: boolean;\n    style: string;\n  };\n  recordAndTupleSyntaxType: RecordAndTuplePluginOptions[\"syntaxType\"];\n  jsescOption: jsescOptions;\n  /**\n   * @deprecated Removed in Babel 8, use `jsescOption` instead\n   */\n  jsonCompatibleStrings?: boolean;\n  /**\n   * For use with the Hack-style pipe operator.\n   * Changes what token is used for pipe bodies topic references.\n   */\n  topicToken?: PipelineOperatorPluginOptions[\"topicToken\"];\n  /**\n   * @deprecated Removed in Babel 8\n   */\n  decoratorsBeforeExport?: boolean;\n  /**\n   * The import attributes syntax style:\n   * - \"with\"        : `import { a } from \"b\" with { type: \"json\" };`\n   * - \"assert\"      : `import { a } from \"b\" assert { type: \"json\" };`\n   * - \"with-legacy\" : `import { a } from \"b\" with type: \"json\";`\n   */\n  importAttributesKeyword?: \"with\" | \"assert\" | \"with-legacy\";\n};\n\ninterface AddNewlinesOptions {\n  addNewlines(leading: boolean, node: t.Node): number;\n  nextNodeStartLine: number;\n}\n\ninterface PrintSequenceOptions extends Partial<AddNewlinesOptions> {\n  statement?: boolean;\n  indent?: boolean;\n  trailingCommentsLineOffset?: number;\n}\n\ninterface PrintListOptions {\n  separator?: (this: Printer) => void;\n  iterator?: (node: t.Node, index: number) => void;\n  statement?: boolean;\n  indent?: boolean;\n}\n\nexport type PrintJoinOptions = PrintListOptions & PrintSequenceOptions;\nclass Printer {\n  constructor(format: Format, map: SourceMap) {\n    this.format = format;\n    this._buf = new Buffer(map);\n\n    this._indentChar = format.indent.style.charCodeAt(0);\n    this._indentRepeat = format.indent.style.length;\n\n    this._inputMap = map?._inputMap;\n  }\n  declare _inputMap: TraceMap;\n\n  declare format: Format;\n  inForStatementInitCounter: number = 0;\n\n  declare _buf: Buffer;\n  _printStack: Array<t.Node> = [];\n  _indent: number = 0;\n  _indentChar: number = 0;\n  _indentRepeat: number = 0;\n  _insideAux: boolean = false;\n  _parenPushNewlineState: { printed: boolean } | null = null;\n  _noLineTerminator: boolean = false;\n  _printAuxAfterOnNextUserNode: boolean = false;\n  _printedComments = new Set<t.Comment>();\n  _endsWithInteger = false;\n  _endsWithWord = false;\n  _lastCommentLine = 0;\n  _endsWithInnerRaw: boolean = false;\n  _indentInnerComments: boolean = true;\n\n  generate(ast: t.Node) {\n    this.print(ast);\n    this._maybeAddAuxComment();\n\n    return this._buf.get();\n  }\n\n  /**\n   * Increment indent size.\n   */\n\n  indent(): void {\n    if (this.format.compact || this.format.concise) return;\n\n    this._indent++;\n  }\n\n  /**\n   * Decrement indent size.\n   */\n\n  dedent(): void {\n    if (this.format.compact || this.format.concise) return;\n\n    this._indent--;\n  }\n\n  /**\n   * Add a semicolon to the buffer.\n   */\n\n  semicolon(force: boolean = false): void {\n    this._maybeAddAuxComment();\n    if (force) {\n      this._appendChar(charCodes.semicolon);\n    } else {\n      this._queue(charCodes.semicolon);\n    }\n    this._noLineTerminator = false;\n  }\n\n  /**\n   * Add a right brace to the buffer.\n   */\n\n  rightBrace(node: t.Node): void {\n    if (this.format.minified) {\n      this._buf.removeLastSemicolon();\n    }\n    this.sourceWithOffset(\"end\", node.loc, -1);\n    this.token(\"}\");\n  }\n\n  rightParens(node: t.Node): void {\n    this.sourceWithOffset(\"end\", node.loc, -1);\n    this.token(\")\");\n  }\n\n  /**\n   * Add a space to the buffer unless it is compact.\n   */\n\n  space(force: boolean = false): void {\n    if (this.format.compact) return;\n\n    if (force) {\n      this._space();\n    } else if (this._buf.hasContent()) {\n      const lastCp = this.getLastChar();\n      if (lastCp !== charCodes.space && lastCp !== charCodes.lineFeed) {\n        this._space();\n      }\n    }\n  }\n\n  /**\n   * Writes a token that can't be safely parsed without taking whitespace into account.\n   */\n\n  word(str: string, noLineTerminatorAfter: boolean = false): void {\n    this._maybePrintInnerComments();\n\n    // prevent concatenating words and creating // comment out of division and regex\n    if (\n      this._endsWithWord ||\n      (str.charCodeAt(0) === charCodes.slash && this.endsWith(charCodes.slash))\n    ) {\n      this._space();\n    }\n\n    this._maybeAddAuxComment();\n    this._append(str, false);\n\n    this._endsWithWord = true;\n    this._noLineTerminator = noLineTerminatorAfter;\n  }\n\n  /**\n   * Writes a number token so that we can validate if it is an integer.\n   */\n\n  number(str: string): void {\n    this.word(str);\n\n    // Integer tokens need special handling because they cannot have '.'s inserted\n    // immediately after them.\n    this._endsWithInteger =\n      Number.isInteger(+str) &&\n      !NON_DECIMAL_LITERAL.test(str) &&\n      !SCIENTIFIC_NOTATION.test(str) &&\n      !ZERO_DECIMAL_INTEGER.test(str) &&\n      str.charCodeAt(str.length - 1) !== charCodes.dot;\n  }\n\n  /**\n   * Writes a simple token.\n   */\n  token(str: string, maybeNewline = false): void {\n    this._maybePrintInnerComments();\n\n    const lastChar = this.getLastChar();\n    const strFirst = str.charCodeAt(0);\n    if (\n      (lastChar === charCodes.exclamationMark &&\n        // space is mandatory to avoid outputting <!--\n        // http://javascript.spec.whatwg.org/#comment-syntax\n        (str === \"--\" ||\n          // Needs spaces to avoid changing a! == 0 to a!== 0\n          strFirst === charCodes.equalsTo)) ||\n      // Need spaces for operators of the same kind to avoid: `a+++b`\n      (strFirst === charCodes.plusSign && lastChar === charCodes.plusSign) ||\n      (strFirst === charCodes.dash && lastChar === charCodes.dash) ||\n      // Needs spaces to avoid changing '34' to '34.', which would still be a valid number.\n      (strFirst === charCodes.dot && this._endsWithInteger)\n    ) {\n      this._space();\n    }\n\n    this._maybeAddAuxComment();\n    this._append(str, maybeNewline);\n    this._noLineTerminator = false;\n  }\n\n  tokenChar(char: number): void {\n    this._maybePrintInnerComments();\n\n    const lastChar = this.getLastChar();\n    if (\n      // Need spaces for operators of the same kind to avoid: `a+++b`\n      (char === charCodes.plusSign && lastChar === charCodes.plusSign) ||\n      (char === charCodes.dash && lastChar === charCodes.dash) ||\n      // Needs spaces to avoid changing '34' to '34.', which would still be a valid number.\n      (char === charCodes.dot && this._endsWithInteger)\n    ) {\n      this._space();\n    }\n\n    this._maybeAddAuxComment();\n    this._appendChar(char);\n    this._noLineTerminator = false;\n  }\n\n  /**\n   * Add a newline (or many newlines), maintaining formatting.\n   * This function checks the number of newlines in the queue and subtracts them.\n   * It currently has some limitations.\n   * @see {Buffer#getNewlineCount}\n   */\n  newline(i: number = 1, force?: boolean): void {\n    if (i <= 0) return;\n\n    if (!force) {\n      if (this.format.retainLines || this.format.compact) return;\n\n      if (this.format.concise) {\n        this.space();\n        return;\n      }\n    }\n\n    if (i > 2) i = 2; // Max two lines\n\n    i -= this._buf.getNewlineCount();\n\n    for (let j = 0; j < i; j++) {\n      this._newline();\n    }\n\n    return;\n  }\n\n  endsWith(char: number): boolean {\n    return this.getLastChar() === char;\n  }\n\n  getLastChar(): number {\n    return this._buf.getLastChar();\n  }\n\n  endsWithCharAndNewline(): number {\n    return this._buf.endsWithCharAndNewline();\n  }\n\n  removeTrailingNewline(): void {\n    this._buf.removeTrailingNewline();\n  }\n\n  exactSource(loc: Loc | undefined, cb: () => void) {\n    if (!loc) {\n      cb();\n      return;\n    }\n\n    this._catchUp(\"start\", loc);\n\n    this._buf.exactSource(loc, cb);\n  }\n\n  source(prop: \"start\" | \"end\", loc: Loc | undefined): void {\n    if (!loc) return;\n\n    this._catchUp(prop, loc);\n\n    this._buf.source(prop, loc);\n  }\n\n  sourceWithOffset(\n    prop: \"start\" | \"end\",\n    loc: Loc | undefined,\n    columnOffset: number,\n  ): void {\n    if (!loc) return;\n\n    this._catchUp(prop, loc);\n\n    this._buf.sourceWithOffset(prop, loc, columnOffset);\n  }\n\n  withSource(\n    prop: \"start\" | \"end\",\n    loc: Loc | undefined,\n    cb: () => void,\n  ): void {\n    if (!loc) {\n      cb();\n      return;\n    }\n\n    this._catchUp(prop, loc);\n\n    this._buf.withSource(prop, loc, cb);\n  }\n\n  sourceIdentifierName(identifierName: string, pos?: Pos): void {\n    if (!this._buf._canMarkIdName) return;\n\n    const sourcePosition = this._buf._sourcePosition;\n    sourcePosition.identifierNamePos = pos;\n    sourcePosition.identifierName = identifierName;\n  }\n\n  _space(): void {\n    this._queue(charCodes.space);\n  }\n\n  _newline(): void {\n    this._queue(charCodes.lineFeed);\n  }\n\n  _append(str: string, maybeNewline: boolean): void {\n    this._maybeAddParen(str);\n    this._maybeIndent(str.charCodeAt(0));\n\n    this._buf.append(str, maybeNewline);\n\n    this._endsWithWord = false;\n    this._endsWithInteger = false;\n  }\n\n  _appendChar(char: number): void {\n    this._maybeAddParenChar(char);\n    this._maybeIndent(char);\n\n    this._buf.appendChar(char);\n\n    this._endsWithWord = false;\n    this._endsWithInteger = false;\n  }\n\n  _queue(char: number) {\n    this._maybeAddParenChar(char);\n    this._maybeIndent(char);\n\n    this._buf.queue(char);\n\n    this._endsWithWord = false;\n    this._endsWithInteger = false;\n  }\n\n  _maybeIndent(firstChar: number): void {\n    // we've got a newline before us so prepend on the indentation\n    if (\n      this._indent &&\n      firstChar !== charCodes.lineFeed &&\n      this.endsWith(charCodes.lineFeed)\n    ) {\n      this._buf.queueIndentation(this._indentChar, this._getIndent());\n    }\n  }\n\n  _shouldIndent(firstChar: number) {\n    // we've got a newline before us so prepend on the indentation\n    if (\n      this._indent &&\n      firstChar !== charCodes.lineFeed &&\n      this.endsWith(charCodes.lineFeed)\n    ) {\n      return true;\n    }\n  }\n\n  _maybeAddParenChar(char: number): void {\n    // see startTerminatorless() instance method\n    const parenPushNewlineState = this._parenPushNewlineState;\n    if (!parenPushNewlineState) return;\n\n    // This function does two things:\n    // - If needed, prints a parenthesis\n    // - If the currently printed string removes the need for the paren,\n    //   it resets the _parenPushNewlineState field.\n    //   Almost everything removes the need for a paren, except for\n    //   comments and whitespaces.\n\n    if (char === charCodes.space) {\n      // Whitespaces only, the parentheses might still be needed.\n      return;\n    }\n\n    // Check for newline or comment.\n    if (char !== charCodes.lineFeed) {\n      this._parenPushNewlineState = null;\n      return;\n    }\n\n    this.token(\"(\");\n    this.indent();\n    parenPushNewlineState.printed = true;\n  }\n\n  _maybeAddParen(str: string): void {\n    // see startTerminatorless() instance method\n    const parenPushNewlineState = this._parenPushNewlineState;\n    if (!parenPushNewlineState) return;\n\n    // This function does two things:\n    // - If needed, prints a parenthesis\n    // - If the currently printed string removes the need for the paren,\n    //   it resets the _parenPushNewlineState field.\n    //   Almost everything removes the need for a paren, except for\n    //   comments and whitespaces.\n\n    const len = str.length;\n\n    let i;\n    for (i = 0; i < len && str.charCodeAt(i) === charCodes.space; i++) continue;\n    if (i === len) {\n      // Whitespaces only, the parentheses might still be needed.\n      return;\n    }\n\n    // Check for newline or comment.\n    const cha = str.charCodeAt(i);\n    if (cha !== charCodes.lineFeed) {\n      if (\n        // This is not a comment (it doesn't start with /)\n        cha !== charCodes.slash ||\n        // This is not a comment (it's a / operator)\n        i + 1 === len\n      ) {\n        // After a normal token, the parentheses aren't needed anymore\n        this._parenPushNewlineState = null;\n        return;\n      }\n\n      const chaPost = str.charCodeAt(i + 1);\n\n      if (chaPost === charCodes.asterisk) {\n        // This is a block comment\n\n        if (PURE_ANNOTATION_RE.test(str.slice(i + 2, len - 2))) {\n          // We avoid printing newlines after #__PURE__ comments (we treat\n          // then as unary operators), but we must keep the old\n          // parenPushNewlineState because, if a newline was forbidden, it is\n          // still forbidden after the comment.\n          return;\n        }\n\n        // NOTE: code flow continues from here to after these if/elses\n      } else if (chaPost !== charCodes.slash) {\n        // This is neither a block comment, nor a line comment.\n        // After a normal token, the parentheses aren't needed anymore\n        this._parenPushNewlineState = null;\n        return;\n      }\n    }\n\n    this.token(\"(\");\n    this.indent();\n    parenPushNewlineState.printed = true;\n  }\n\n  catchUp(line: number) {\n    if (!this.format.retainLines) return;\n\n    // catch up to this nodes newline if we're behind\n    const count = line - this._buf.getCurrentLine();\n\n    for (let i = 0; i < count; i++) {\n      this._newline();\n    }\n  }\n\n  _catchUp(prop: \"start\" | \"end\", loc?: Loc) {\n    if (!this.format.retainLines) return;\n\n    // catch up to this nodes newline if we're behind\n    const line = loc?.[prop]?.line;\n    if (line != null) {\n      const count = line - this._buf.getCurrentLine();\n\n      for (let i = 0; i < count; i++) {\n        this._newline();\n      }\n    }\n  }\n\n  /**\n   * Get the current indent.\n   */\n\n  _getIndent(): number {\n    return this._indentRepeat * this._indent;\n  }\n\n  printTerminatorless(node: t.Node, parent: t.Node, isLabel: boolean) {\n    /**\n     * Set some state that will be modified if a newline has been inserted before any\n     * non-space characters.\n     *\n     * This is to prevent breaking semantics for terminatorless separator nodes. eg:\n     *\n     *   return foo;\n     *\n     * returns `foo`. But if we do:\n     *\n     *   return\n     *   foo;\n     *\n     *  `undefined` will be returned and not `foo` due to the terminator.\n     */\n    if (isLabel) {\n      this._noLineTerminator = true;\n      this.print(node, parent);\n    } else {\n      const terminatorState = {\n        printed: false,\n      };\n      this._parenPushNewlineState = terminatorState;\n      this.print(node, parent);\n      /**\n       * Print an ending parentheses if a starting one has been printed.\n       */\n      if (terminatorState.printed) {\n        this.dedent();\n        this.newline();\n        this.token(\")\");\n      }\n    }\n  }\n\n  print(\n    node: t.Node | null,\n    parent?: t.Node,\n    noLineTerminatorAfter?: boolean,\n    // trailingCommentsLineOffset also used to check if called from printJoin\n    // it will be ignored if `noLineTerminatorAfter||this._noLineTerminator`\n    trailingCommentsLineOffset?: number,\n    forceParens?: boolean,\n  ) {\n    if (!node) return;\n\n    this._endsWithInnerRaw = false;\n\n    const nodeType = node.type;\n    const format = this.format;\n\n    const oldConcise = format.concise;\n    if (\n      // @ts-expect-error document _compact AST properties\n      node._compact\n    ) {\n      format.concise = true;\n    }\n\n    const printMethod =\n      this[\n        nodeType as Exclude<\n          t.Node[\"type\"],\n          // removed\n          | \"Noop\"\n          // renamed\n          | t.DeprecatedAliases[\"type\"]\n        >\n      ];\n    if (printMethod === undefined) {\n      throw new ReferenceError(\n        `unknown node of type ${JSON.stringify(\n          nodeType,\n        )} with constructor ${JSON.stringify(node.constructor.name)}`,\n      );\n    }\n\n    this._printStack.push(node);\n\n    const oldInAux = this._insideAux;\n    this._insideAux = node.loc == undefined;\n    this._maybeAddAuxComment(this._insideAux && !oldInAux);\n\n    const shouldPrintParens =\n      forceParens ||\n      (format.retainFunctionParens &&\n        nodeType === \"FunctionExpression\" &&\n        node.extra?.parenthesized) ||\n      needsParens(node, parent, this._printStack);\n\n    if (shouldPrintParens) {\n      this.token(\"(\");\n      this._endsWithInnerRaw = false;\n    }\n\n    this._lastCommentLine = 0;\n\n    this._printLeadingComments(node, parent);\n\n    const loc = nodeType === \"Program\" || nodeType === \"File\" ? null : node.loc;\n\n    this.exactSource(loc, printMethod.bind(this, node, parent));\n\n    if (shouldPrintParens) {\n      this._printTrailingComments(node, parent);\n      this.token(\")\");\n      this._noLineTerminator = noLineTerminatorAfter;\n    } else if (noLineTerminatorAfter && !this._noLineTerminator) {\n      this._noLineTerminator = true;\n      this._printTrailingComments(node, parent);\n    } else {\n      this._printTrailingComments(node, parent, trailingCommentsLineOffset);\n    }\n\n    // end\n    this._printStack.pop();\n\n    format.concise = oldConcise;\n    this._insideAux = oldInAux;\n\n    this._endsWithInnerRaw = false;\n  }\n\n  _maybeAddAuxComment(enteredPositionlessNode?: boolean) {\n    if (enteredPositionlessNode) this._printAuxBeforeComment();\n    if (!this._insideAux) this._printAuxAfterComment();\n  }\n\n  _printAuxBeforeComment() {\n    if (this._printAuxAfterOnNextUserNode) return;\n    this._printAuxAfterOnNextUserNode = true;\n\n    const comment = this.format.auxiliaryCommentBefore;\n    if (comment) {\n      this._printComment(\n        {\n          type: \"CommentBlock\",\n          value: comment,\n        },\n        COMMENT_SKIP_NEWLINE.DEFAULT,\n      );\n    }\n  }\n\n  _printAuxAfterComment() {\n    if (!this._printAuxAfterOnNextUserNode) return;\n    this._printAuxAfterOnNextUserNode = false;\n\n    const comment = this.format.auxiliaryCommentAfter;\n    if (comment) {\n      this._printComment(\n        {\n          type: \"CommentBlock\",\n          value: comment,\n        },\n        COMMENT_SKIP_NEWLINE.DEFAULT,\n      );\n    }\n  }\n\n  getPossibleRaw(\n    node:\n      | t.StringLiteral\n      | t.NumericLiteral\n      | t.BigIntLiteral\n      | t.DecimalLiteral\n      | t.DirectiveLiteral\n      | t.JSXText,\n  ): string | undefined {\n    const extra = node.extra;\n    if (\n      extra?.raw != null &&\n      extra.rawValue != null &&\n      node.value === extra.rawValue\n    ) {\n      // @ts-expect-error: The extra.raw of these AST node types must be a string\n      return extra.raw;\n    }\n  }\n\n  printJoin(\n    nodes: Array<t.Node> | undefined | null,\n    parent: t.Node,\n    opts: PrintJoinOptions = {},\n  ) {\n    if (!nodes?.length) return;\n\n    let { indent } = opts;\n\n    if (indent == null && this.format.retainLines) {\n      const startLine = nodes[0].loc?.start.line;\n      if (startLine != null && startLine !== this._buf.getCurrentLine()) {\n        indent = true;\n      }\n    }\n\n    if (indent) this.indent();\n\n    const newlineOpts: AddNewlinesOptions = {\n      addNewlines: opts.addNewlines,\n      nextNodeStartLine: 0,\n    };\n\n    const separator = opts.separator ? opts.separator.bind(this) : null;\n\n    const len = nodes.length;\n    for (let i = 0; i < len; i++) {\n      const node = nodes[i];\n      if (!node) continue;\n\n      if (opts.statement) this._printNewline(i === 0, newlineOpts);\n\n      this.print(node, parent, undefined, opts.trailingCommentsLineOffset || 0);\n\n      opts.iterator?.(node, i);\n\n      if (i < len - 1) separator?.();\n\n      if (opts.statement) {\n        if (i + 1 === len) {\n          this.newline(1);\n        } else {\n          const nextNode = nodes[i + 1];\n          newlineOpts.nextNodeStartLine = nextNode.loc?.start.line || 0;\n\n          this._printNewline(true, newlineOpts);\n        }\n      }\n    }\n\n    if (indent) this.dedent();\n  }\n\n  printAndIndentOnComments(node: t.Node, parent: t.Node) {\n    const indent = node.leadingComments && node.leadingComments.length > 0;\n    if (indent) this.indent();\n    this.print(node, parent);\n    if (indent) this.dedent();\n  }\n\n  printBlock(parent: Extract<t.Node, { body: t.Statement }>) {\n    const node = parent.body;\n\n    if (node.type !== \"EmptyStatement\") {\n      this.space();\n    }\n\n    this.print(node, parent);\n  }\n\n  _printTrailingComments(node: t.Node, parent?: t.Node, lineOffset?: number) {\n    const { innerComments, trailingComments } = node;\n    // We print inner comments here, so that if for some reason they couldn't\n    // be printed in earlier locations they are still printed *somewhere*,\n    // even if at the end of the node.\n    if (innerComments?.length) {\n      this._printComments(\n        COMMENT_TYPE.TRAILING,\n        innerComments,\n        node,\n        parent,\n        lineOffset,\n      );\n    }\n    if (trailingComments?.length) {\n      this._printComments(\n        COMMENT_TYPE.TRAILING,\n        trailingComments,\n        node,\n        parent,\n        lineOffset,\n      );\n    }\n  }\n\n  _printLeadingComments(node: t.Node, parent: t.Node) {\n    const comments = node.leadingComments;\n    if (!comments?.length) return;\n    this._printComments(COMMENT_TYPE.LEADING, comments, node, parent);\n  }\n\n  _maybePrintInnerComments() {\n    if (this._endsWithInnerRaw) this.printInnerComments();\n    this._endsWithInnerRaw = true;\n    this._indentInnerComments = true;\n  }\n\n  printInnerComments() {\n    const node = this._printStack[this._printStack.length - 1];\n    const comments = node.innerComments;\n    if (!comments?.length) return;\n\n    const hasSpace = this.endsWith(charCodes.space);\n    const indent = this._indentInnerComments;\n    const printedCommentsCount = this._printedComments.size;\n    if (indent) this.indent();\n    this._printComments(COMMENT_TYPE.INNER, comments, node);\n    if (hasSpace && printedCommentsCount !== this._printedComments.size) {\n      this.space();\n    }\n    if (indent) this.dedent();\n  }\n\n  noIndentInnerCommentsHere() {\n    this._indentInnerComments = false;\n  }\n\n  printSequence(\n    nodes: t.Node[],\n    parent: t.Node,\n    opts: PrintSequenceOptions = {},\n  ) {\n    opts.statement = true;\n    opts.indent ??= false;\n    this.printJoin(nodes, parent, opts);\n  }\n\n  printList(items: t.Node[], parent: t.Node, opts: PrintListOptions = {}) {\n    if (opts.separator == null) {\n      opts.separator = commaSeparator;\n    }\n\n    this.printJoin(items, parent, opts);\n  }\n\n  _printNewline(newLine: boolean, opts: AddNewlinesOptions) {\n    const format = this.format;\n\n    // Fast path since 'this.newline' does nothing when not tracking lines.\n    if (format.retainLines || format.compact) return;\n\n    // Fast path for concise since 'this.newline' just inserts a space when\n    // concise formatting is in use.\n    if (format.concise) {\n      this.space();\n      return;\n    }\n\n    if (!newLine) {\n      return;\n    }\n\n    const startLine = opts.nextNodeStartLine;\n    const lastCommentLine = this._lastCommentLine;\n    if (startLine > 0 && lastCommentLine > 0) {\n      const offset = startLine - lastCommentLine;\n      if (offset >= 0) {\n        this.newline(offset || 1);\n        return;\n      }\n    }\n\n    // don't add newlines at the beginning of the file\n    if (this._buf.hasContent()) {\n      // Here is the logic of the original line wrapping according to the node layout, we are not using it now.\n      // We currently add at most one newline to each node in the list, ignoring `opts.addNewlines`.\n\n      // let lines = 0;\n      // if (!leading) lines++; // always include at least a single line after\n      // if (opts.addNewlines) lines += opts.addNewlines(leading, node) || 0;\n\n      // const needs = leading ? needsWhitespaceBefore : needsWhitespaceAfter;\n      // if (needs(node, parent)) lines++;\n\n      // this.newline(Math.min(2, lines));\n\n      this.newline(1);\n    }\n  }\n\n  // Returns `PRINT_COMMENT_HINT.DEFER` if the comment cannot be printed in this position due to\n  // line terminators, signaling that the print comments loop can stop and\n  // resume printing comments at the next possible position. This happens when\n  // printing inner comments, since if we have an inner comment with a multiline\n  // there is at least one inner position where line terminators are allowed.\n  _shouldPrintComment(comment: t.Comment): PRINT_COMMENT_HINT {\n    // Some plugins (such as flow-strip-types) use this to mark comments as removed using the AST-root 'comments' property,\n    // where they can't manually mutate the AST node comment lists.\n    if (comment.ignore) return PRINT_COMMENT_HINT.SKIP;\n\n    if (this._printedComments.has(comment)) return PRINT_COMMENT_HINT.SKIP;\n\n    if (\n      this._noLineTerminator &&\n      (HAS_NEWLINE.test(comment.value) ||\n        HAS_BlOCK_COMMENT_END.test(comment.value))\n    ) {\n      return PRINT_COMMENT_HINT.DEFER;\n    }\n\n    this._printedComments.add(comment);\n\n    if (!this.format.shouldPrintComment(comment.value)) {\n      return PRINT_COMMENT_HINT.SKIP;\n    }\n\n    return PRINT_COMMENT_HINT.ALLOW;\n  }\n\n  _printComment(comment: t.Comment, skipNewLines: COMMENT_SKIP_NEWLINE) {\n    const noLineTerminator = this._noLineTerminator;\n    const isBlockComment = comment.type === \"CommentBlock\";\n\n    // Add a newline before and after a block comment, unless explicitly\n    // disallowed\n    const printNewLines =\n      isBlockComment &&\n      skipNewLines !== COMMENT_SKIP_NEWLINE.ALL &&\n      !this._noLineTerminator;\n\n    if (\n      printNewLines &&\n      this._buf.hasContent() &&\n      skipNewLines !== COMMENT_SKIP_NEWLINE.LEADING\n    ) {\n      this.newline(1);\n    }\n\n    const lastCharCode = this.getLastChar();\n    if (\n      lastCharCode !== charCodes.leftSquareBracket &&\n      lastCharCode !== charCodes.leftCurlyBrace\n    ) {\n      this.space();\n    }\n\n    let val;\n    if (isBlockComment) {\n      val = `/*${comment.value}*/`;\n      if (this.format.indent.adjustMultilineComment) {\n        const offset = comment.loc?.start.column;\n        if (offset) {\n          const newlineRegex = new RegExp(\"\\\\n\\\\s{1,\" + offset + \"}\", \"g\");\n          val = val.replace(newlineRegex, \"\\n\");\n        }\n\n        let indentSize = this.format.retainLines\n          ? 0\n          : this._buf.getCurrentColumn();\n\n        if (this._shouldIndent(charCodes.slash) || this.format.retainLines) {\n          indentSize += this._getIndent();\n        }\n\n        val = val.replace(/\\n(?!$)/g, `\\n${\" \".repeat(indentSize)}`);\n      }\n    } else if (!noLineTerminator) {\n      val = `//${comment.value}`;\n    } else {\n      // It was a single-line comment, so it's guaranteed to not\n      // contain newlines and it can be safely printed as a block\n      // comment.\n      val = `/*${comment.value}*/`;\n    }\n\n    // Avoid creating //* comments\n    if (this.endsWith(charCodes.slash)) this._space();\n\n    this.source(\"start\", comment.loc);\n    this._append(val, isBlockComment);\n\n    if (!isBlockComment && !noLineTerminator) {\n      this.newline(1, true);\n    }\n\n    if (printNewLines && skipNewLines !== COMMENT_SKIP_NEWLINE.TRAILING) {\n      this.newline(1);\n    }\n  }\n\n  _printComments(\n    type: COMMENT_TYPE,\n    comments: readonly t.Comment[],\n    node: t.Node,\n    parent?: t.Node,\n    lineOffset: number = 0,\n  ) {\n    const nodeLoc = node.loc;\n    const len = comments.length;\n    let hasLoc = !!nodeLoc;\n    const nodeStartLine = hasLoc ? nodeLoc.start.line : 0;\n    const nodeEndLine = hasLoc ? nodeLoc.end.line : 0;\n    let lastLine = 0;\n    let leadingCommentNewline = 0;\n\n    const maybeNewline = this._noLineTerminator\n      ? function () {}\n      : this.newline.bind(this);\n\n    for (let i = 0; i < len; i++) {\n      const comment = comments[i];\n\n      const shouldPrint = this._shouldPrintComment(comment);\n      if (shouldPrint === PRINT_COMMENT_HINT.DEFER) {\n        hasLoc = false;\n        break;\n      }\n      if (hasLoc && comment.loc && shouldPrint === PRINT_COMMENT_HINT.ALLOW) {\n        const commentStartLine = comment.loc.start.line;\n        const commentEndLine = comment.loc.end.line;\n        if (type === COMMENT_TYPE.LEADING) {\n          let offset = 0;\n          if (i === 0) {\n            // Because currently we cannot handle blank lines before leading comments,\n            // we always wrap before and after multi-line comments.\n            if (\n              this._buf.hasContent() &&\n              (comment.type === \"CommentLine\" ||\n                commentStartLine != commentEndLine)\n            ) {\n              offset = leadingCommentNewline = 1;\n            }\n          } else {\n            offset = commentStartLine - lastLine;\n          }\n          lastLine = commentEndLine;\n\n          maybeNewline(offset);\n          this._printComment(comment, COMMENT_SKIP_NEWLINE.ALL);\n\n          if (i + 1 === len) {\n            maybeNewline(\n              Math.max(nodeStartLine - lastLine, leadingCommentNewline),\n            );\n            lastLine = nodeStartLine;\n          }\n        } else if (type === COMMENT_TYPE.INNER) {\n          const offset =\n            commentStartLine - (i === 0 ? nodeStartLine : lastLine);\n          lastLine = commentEndLine;\n\n          maybeNewline(offset);\n          this._printComment(comment, COMMENT_SKIP_NEWLINE.ALL);\n\n          if (i + 1 === len) {\n            maybeNewline(Math.min(1, nodeEndLine - lastLine)); // TODO: Improve here when inner comments processing is stronger\n            lastLine = nodeEndLine;\n          }\n        } else {\n          const offset =\n            commentStartLine - (i === 0 ? nodeEndLine - lineOffset : lastLine);\n          lastLine = commentEndLine;\n\n          maybeNewline(offset);\n          this._printComment(comment, COMMENT_SKIP_NEWLINE.ALL);\n        }\n      } else {\n        hasLoc = false;\n        if (shouldPrint !== PRINT_COMMENT_HINT.ALLOW) {\n          continue;\n        }\n\n        if (len === 1) {\n          const singleLine = comment.loc\n            ? comment.loc.start.line === comment.loc.end.line\n            : !HAS_NEWLINE.test(comment.value);\n\n          const shouldSkipNewline =\n            singleLine &&\n            !isStatement(node) &&\n            !isClassBody(parent) &&\n            !isTSInterfaceBody(parent) &&\n            !isTSEnumDeclaration(parent);\n\n          if (type === COMMENT_TYPE.LEADING) {\n            this._printComment(\n              comment,\n              (shouldSkipNewline && node.type !== \"ObjectExpression\") ||\n                (singleLine && isFunction(parent, { body: node }))\n                ? COMMENT_SKIP_NEWLINE.ALL\n                : COMMENT_SKIP_NEWLINE.DEFAULT,\n            );\n          } else if (shouldSkipNewline && type === COMMENT_TYPE.TRAILING) {\n            this._printComment(comment, COMMENT_SKIP_NEWLINE.ALL);\n          } else {\n            this._printComment(comment, COMMENT_SKIP_NEWLINE.DEFAULT);\n          }\n        } else if (\n          type === COMMENT_TYPE.INNER &&\n          !(node.type === \"ObjectExpression\" && node.properties.length > 1) &&\n          node.type !== \"ClassBody\" &&\n          node.type !== \"TSInterfaceBody\"\n        ) {\n          // class X {\n          //   /*:: a: number*/\n          //   /*:: b: ?string*/\n          // }\n\n          this._printComment(\n            comment,\n            i === 0\n              ? COMMENT_SKIP_NEWLINE.LEADING\n              : i === len - 1\n              ? COMMENT_SKIP_NEWLINE.TRAILING\n              : COMMENT_SKIP_NEWLINE.DEFAULT,\n          );\n        } else {\n          this._printComment(comment, COMMENT_SKIP_NEWLINE.DEFAULT);\n        }\n      }\n    }\n\n    if (type === COMMENT_TYPE.TRAILING && hasLoc && lastLine) {\n      this._lastCommentLine = lastLine;\n    }\n  }\n}\n\n// Expose the node type functions and helpers on the prototype for easy usage.\nObject.assign(Printer.prototype, generatorFunctions);\n\nif (!process.env.BABEL_8_BREAKING) {\n  // @ts-ignore(Babel 7 vs Babel 8) Babel 7 has Noop print method\n  Printer.prototype.Noop = function Noop(this: Printer) {};\n}\n\ntype GeneratorFunctions = typeof generatorFunctions;\ninterface Printer extends GeneratorFunctions {}\nexport default Printer;\n\nfunction commaSeparator(this: Printer) {\n  this.token(\",\");\n  this.space();\n}\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nclass Buffer {\n  constructor(map) {\n    this._map = null;\n    this._buf = \"\";\n    this._str = \"\";\n    this._appendCount = 0;\n    this._last = 0;\n    this._queue = [];\n    this._queueCursor = 0;\n    this._canMarkIdName = true;\n    this._position = {\n      line: 1,\n      column: 0\n    };\n    this._sourcePosition = {\n      identifierName: undefined,\n      identifierNamePos: undefined,\n      line: undefined,\n      column: undefined,\n      filename: undefined\n    };\n    this._map = map;\n    this._allocQueue();\n  }\n  _allocQueue() {\n    const queue = this._queue;\n    for (let i = 0; i < 16; i++) {\n      queue.push({\n        char: 0,\n        repeat: 1,\n        line: undefined,\n        column: undefined,\n        identifierName: undefined,\n        identifierNamePos: undefined,\n        filename: \"\"\n      });\n    }\n  }\n  _pushQueue(char, repeat, line, column, filename) {\n    const cursor = this._queueCursor;\n    if (cursor === this._queue.length) {\n      this._allocQueue();\n    }\n    const item = this._queue[cursor];\n    item.char = char;\n    item.repeat = repeat;\n    item.line = line;\n    item.column = column;\n    item.filename = filename;\n    this._queueCursor++;\n  }\n  _popQueue() {\n    if (this._queueCursor === 0) {\n      throw new Error(\"Cannot pop from empty queue\");\n    }\n    return this._queue[--this._queueCursor];\n  }\n  get() {\n    this._flush();\n    const map = this._map;\n    const result = {\n      code: (this._buf + this._str).trimRight(),\n      decodedMap: map == null ? void 0 : map.getDecoded(),\n      get __mergedMap() {\n        return this.map;\n      },\n      get map() {\n        const resultMap = map ? map.get() : null;\n        result.map = resultMap;\n        return resultMap;\n      },\n      set map(value) {\n        Object.defineProperty(result, \"map\", {\n          value,\n          writable: true\n        });\n      },\n      get rawMappings() {\n        const mappings = map == null ? void 0 : map.getRawMappings();\n        result.rawMappings = mappings;\n        return mappings;\n      },\n      set rawMappings(value) {\n        Object.defineProperty(result, \"rawMappings\", {\n          value,\n          writable: true\n        });\n      }\n    };\n    return result;\n  }\n  append(str, maybeNewline) {\n    this._flush();\n    this._append(str, this._sourcePosition, maybeNewline);\n  }\n  appendChar(char) {\n    this._flush();\n    this._appendChar(char, 1, this._sourcePosition);\n  }\n  queue(char) {\n    if (char === 10) {\n      while (this._queueCursor !== 0) {\n        const char = this._queue[this._queueCursor - 1].char;\n        if (char !== 32 && char !== 9) {\n          break;\n        }\n        this._queueCursor--;\n      }\n    }\n    const sourcePosition = this._sourcePosition;\n    this._pushQueue(char, 1, sourcePosition.line, sourcePosition.column, sourcePosition.filename);\n  }\n  queueIndentation(char, repeat) {\n    this._pushQueue(char, repeat, undefined, undefined, undefined);\n  }\n  _flush() {\n    const queueCursor = this._queueCursor;\n    const queue = this._queue;\n    for (let i = 0; i < queueCursor; i++) {\n      const item = queue[i];\n      this._appendChar(item.char, item.repeat, item);\n    }\n    this._queueCursor = 0;\n  }\n  _appendChar(char, repeat, sourcePos) {\n    this._last = char;\n    this._str += repeat > 1 ? String.fromCharCode(char).repeat(repeat) : String.fromCharCode(char);\n    if (char !== 10) {\n      this._mark(sourcePos.line, sourcePos.column, sourcePos.identifierName, sourcePos.identifierNamePos, sourcePos.filename);\n      this._position.column += repeat;\n    } else {\n      this._position.line++;\n      this._position.column = 0;\n    }\n    if (this._canMarkIdName) {\n      sourcePos.identifierName = undefined;\n      sourcePos.identifierNamePos = undefined;\n    }\n  }\n  _append(str, sourcePos, maybeNewline) {\n    const len = str.length;\n    const position = this._position;\n    this._last = str.charCodeAt(len - 1);\n    if (++this._appendCount > 4096) {\n      +this._str;\n      this._buf += this._str;\n      this._str = str;\n      this._appendCount = 0;\n    } else {\n      this._str += str;\n    }\n    if (!maybeNewline && !this._map) {\n      position.column += len;\n      return;\n    }\n    const {\n      column,\n      identifierName,\n      identifierNamePos,\n      filename\n    } = sourcePos;\n    let line = sourcePos.line;\n    if ((identifierName != null || identifierNamePos != null) && this._canMarkIdName) {\n      sourcePos.identifierName = undefined;\n      sourcePos.identifierNamePos = undefined;\n    }\n    let i = str.indexOf(\"\\n\");\n    let last = 0;\n    if (i !== 0) {\n      this._mark(line, column, identifierName, identifierNamePos, filename);\n    }\n    while (i !== -1) {\n      position.line++;\n      position.column = 0;\n      last = i + 1;\n      if (last < len && line !== undefined) {\n        this._mark(++line, 0, null, null, filename);\n      }\n      i = str.indexOf(\"\\n\", last);\n    }\n    position.column += len - last;\n  }\n  _mark(line, column, identifierName, identifierNamePos, filename) {\n    var _this$_map;\n    (_this$_map = this._map) == null ? void 0 : _this$_map.mark(this._position, line, column, identifierName, identifierNamePos, filename);\n  }\n  removeTrailingNewline() {\n    const queueCursor = this._queueCursor;\n    if (queueCursor !== 0 && this._queue[queueCursor - 1].char === 10) {\n      this._queueCursor--;\n    }\n  }\n  removeLastSemicolon() {\n    const queueCursor = this._queueCursor;\n    if (queueCursor !== 0 && this._queue[queueCursor - 1].char === 59) {\n      this._queueCursor--;\n    }\n  }\n  getLastChar() {\n    const queueCursor = this._queueCursor;\n    return queueCursor !== 0 ? this._queue[queueCursor - 1].char : this._last;\n  }\n  getNewlineCount() {\n    const queueCursor = this._queueCursor;\n    let count = 0;\n    if (queueCursor === 0) return this._last === 10 ? 1 : 0;\n    for (let i = queueCursor - 1; i >= 0; i--) {\n      if (this._queue[i].char !== 10) {\n        break;\n      }\n      count++;\n    }\n    return count === queueCursor && this._last === 10 ? count + 1 : count;\n  }\n  endsWithCharAndNewline() {\n    const queue = this._queue;\n    const queueCursor = this._queueCursor;\n    if (queueCursor !== 0) {\n      const lastCp = queue[queueCursor - 1].char;\n      if (lastCp !== 10) return;\n      if (queueCursor > 1) {\n        return queue[queueCursor - 2].char;\n      } else {\n        return this._last;\n      }\n    }\n  }\n  hasContent() {\n    return this._queueCursor !== 0 || !!this._last;\n  }\n  exactSource(loc, cb) {\n    if (!this._map) {\n      cb();\n      return;\n    }\n    this.source(\"start\", loc);\n    const identifierName = loc.identifierName;\n    const sourcePos = this._sourcePosition;\n    if (identifierName) {\n      this._canMarkIdName = false;\n      sourcePos.identifierName = identifierName;\n    }\n    cb();\n    if (identifierName) {\n      this._canMarkIdName = true;\n      sourcePos.identifierName = undefined;\n      sourcePos.identifierNamePos = undefined;\n    }\n    this.source(\"end\", loc);\n  }\n  source(prop, loc) {\n    if (!this._map) return;\n    this._normalizePosition(prop, loc, 0);\n  }\n  sourceWithOffset(prop, loc, columnOffset) {\n    if (!this._map) return;\n    this._normalizePosition(prop, loc, columnOffset);\n  }\n  withSource(prop, loc, cb) {\n    if (this._map) {\n      this.source(prop, loc);\n    }\n    cb();\n  }\n  _normalizePosition(prop, loc, columnOffset) {\n    const pos = loc[prop];\n    const target = this._sourcePosition;\n    if (pos) {\n      target.line = pos.line;\n      target.column = Math.max(pos.column + columnOffset, 0);\n      target.filename = loc.filename;\n    }\n  }\n  getCurrentColumn() {\n    const queue = this._queue;\n    const queueCursor = this._queueCursor;\n    let lastIndex = -1;\n    let len = 0;\n    for (let i = 0; i < queueCursor; i++) {\n      const item = queue[i];\n      if (item.char === 10) {\n        lastIndex = len;\n      }\n      len += item.repeat;\n    }\n    return lastIndex === -1 ? this._position.column + len : len - 1 - lastIndex;\n  }\n  getCurrentLine() {\n    let count = 0;\n    const queue = this._queue;\n    for (let i = 0; i < this._queueCursor; i++) {\n      if (queue[i].char === 10) {\n        count++;\n      }\n    }\n    return this._position.line + count;\n  }\n}\nexports.default = Buffer;\n\n//# sourceMappingURL=buffer.js.map\n","import type SourceMap from \"./source-map.ts\";\nimport * as charcodes from \"charcodes\";\n\nexport type Pos = {\n  line: number;\n  column: number;\n};\nexport type Loc = {\n  start?: Pos;\n  end?: Pos;\n  filename?: string;\n};\ntype SourcePos = {\n  line: number | undefined;\n  column: number | undefined;\n  identifierName: string | undefined;\n  filename: string | undefined;\n};\ntype InternalSourcePos = SourcePos & { identifierNamePos: Pos };\n\ntype QueueItem = {\n  char: number;\n  repeat: number;\n  line: number | undefined;\n  column: number | undefined;\n  identifierName: undefined; // Not used, it always undefined.\n  identifierNamePos: undefined; // Not used, it always undefined.\n  filename: string | undefined;\n};\n\nexport default class Buffer {\n  constructor(map?: SourceMap | null) {\n    this._map = map;\n\n    this._allocQueue();\n  }\n\n  _map: SourceMap = null;\n  _buf = \"\";\n  _str = \"\";\n  _appendCount = 0;\n  _last = 0;\n  _queue: QueueItem[] = [];\n  _queueCursor = 0;\n  _canMarkIdName = true;\n\n  _position = {\n    line: 1,\n    column: 0,\n  };\n  _sourcePosition: InternalSourcePos = {\n    identifierName: undefined,\n    identifierNamePos: undefined,\n    line: undefined,\n    column: undefined,\n    filename: undefined,\n  };\n\n  _allocQueue() {\n    const queue = this._queue;\n\n    for (let i = 0; i < 16; i++) {\n      queue.push({\n        char: 0,\n        repeat: 1,\n        line: undefined,\n        column: undefined,\n        identifierName: undefined,\n        identifierNamePos: undefined,\n        filename: \"\",\n      });\n    }\n  }\n\n  _pushQueue(\n    char: number,\n    repeat: number,\n    line: number | undefined,\n    column: number | undefined,\n    filename: string | undefined,\n  ) {\n    const cursor = this._queueCursor;\n    if (cursor === this._queue.length) {\n      this._allocQueue();\n    }\n    const item = this._queue[cursor];\n    item.char = char;\n    item.repeat = repeat;\n    item.line = line;\n    item.column = column;\n    item.filename = filename;\n\n    this._queueCursor++;\n  }\n\n  _popQueue(): QueueItem {\n    if (this._queueCursor === 0) {\n      throw new Error(\"Cannot pop from empty queue\");\n    }\n    return this._queue[--this._queueCursor];\n  }\n\n  /**\n   * Get the final string output from the buffer, along with the sourcemap if one exists.\n   */\n\n  get() {\n    this._flush();\n\n    const map = this._map;\n    const result = {\n      // Whatever trim is used here should not execute a regex against the\n      // source string since it may be arbitrarily large after all transformations\n      code: (this._buf + this._str).trimRight(),\n      // Decoded sourcemap is free to generate.\n      decodedMap: map?.getDecoded(),\n      // Used as a marker for backwards compatibility. We moved input map merging\n      // into the generator. We cannot merge the input map a second time, so the\n      // presence of this field tells us we've already done the work.\n      get __mergedMap() {\n        return this.map;\n      },\n      // Encoding the sourcemap is moderately CPU expensive.\n      get map() {\n        const resultMap = map ? map.get() : null;\n        result.map = resultMap;\n        return resultMap;\n      },\n      set map(value) {\n        Object.defineProperty(result, \"map\", { value, writable: true });\n      },\n      // Retrieving the raw mappings is very memory intensive.\n      get rawMappings() {\n        const mappings = map?.getRawMappings();\n        result.rawMappings = mappings;\n        return mappings;\n      },\n      set rawMappings(value) {\n        Object.defineProperty(result, \"rawMappings\", { value, writable: true });\n      },\n    };\n\n    return result;\n  }\n\n  /**\n   * Add a string to the buffer that cannot be reverted.\n   */\n\n  append(str: string, maybeNewline: boolean): void {\n    this._flush();\n\n    this._append(str, this._sourcePosition, maybeNewline);\n  }\n\n  appendChar(char: number): void {\n    this._flush();\n    this._appendChar(char, 1, this._sourcePosition);\n  }\n\n  /**\n   * Add a string to the buffer than can be reverted.\n   */\n  queue(char: number): void {\n    // Drop trailing spaces when a newline is inserted.\n    if (char === charcodes.lineFeed) {\n      while (this._queueCursor !== 0) {\n        const char = this._queue[this._queueCursor - 1].char;\n        if (char !== charcodes.space && char !== charcodes.tab) {\n          break;\n        }\n\n        this._queueCursor--;\n      }\n    }\n\n    const sourcePosition = this._sourcePosition;\n    this._pushQueue(\n      char,\n      1,\n      sourcePosition.line,\n      sourcePosition.column,\n      sourcePosition.filename,\n    );\n  }\n\n  /**\n   * Same as queue, but this indentation will never have a sourcemap marker.\n   */\n  queueIndentation(char: number, repeat: number): void {\n    this._pushQueue(char, repeat, undefined, undefined, undefined);\n  }\n\n  _flush(): void {\n    const queueCursor = this._queueCursor;\n    const queue = this._queue;\n    for (let i = 0; i < queueCursor; i++) {\n      const item: QueueItem = queue[i];\n      this._appendChar(item.char, item.repeat, item);\n    }\n    this._queueCursor = 0;\n  }\n\n  _appendChar(\n    char: number,\n    repeat: number,\n    sourcePos: InternalSourcePos,\n  ): void {\n    this._last = char;\n\n    this._str +=\n      repeat > 1\n        ? String.fromCharCode(char).repeat(repeat)\n        : String.fromCharCode(char);\n\n    if (char !== charcodes.lineFeed) {\n      this._mark(\n        sourcePos.line,\n        sourcePos.column,\n        sourcePos.identifierName,\n        sourcePos.identifierNamePos,\n        sourcePos.filename,\n      );\n      this._position.column += repeat;\n    } else {\n      this._position.line++;\n      this._position.column = 0;\n    }\n\n    if (this._canMarkIdName) {\n      sourcePos.identifierName = undefined;\n      sourcePos.identifierNamePos = undefined;\n    }\n  }\n\n  _append(\n    str: string,\n    sourcePos: InternalSourcePos,\n    maybeNewline: boolean,\n  ): void {\n    const len = str.length;\n    const position = this._position;\n\n    this._last = str.charCodeAt(len - 1);\n\n    if (++this._appendCount > 4096) {\n      +this._str; // Unexplainable huge performance boost. Ref: https://github.com/davidmarkclements/flatstr License: MIT\n      this._buf += this._str;\n      this._str = str;\n      this._appendCount = 0;\n    } else {\n      this._str += str;\n    }\n\n    if (!maybeNewline && !this._map) {\n      position.column += len;\n      return;\n    }\n\n    const { column, identifierName, identifierNamePos, filename } = sourcePos;\n    let line = sourcePos.line;\n\n    if (\n      (identifierName != null || identifierNamePos != null) &&\n      this._canMarkIdName\n    ) {\n      sourcePos.identifierName = undefined;\n      sourcePos.identifierNamePos = undefined;\n    }\n\n    // Search for newline chars. We search only for `\\n`, since both `\\r` and\n    // `\\r\\n` are normalized to `\\n` during parse. We exclude `\\u2028` and\n    // `\\u2029` for performance reasons, they're so uncommon that it's probably\n    // ok. It's also unclear how other sourcemap utilities handle them...\n    let i = str.indexOf(\"\\n\");\n    let last = 0;\n\n    // If the string starts with a newline char, then adding a mark is redundant.\n    // This catches both \"no newlines\" and \"newline after several chars\".\n    if (i !== 0) {\n      this._mark(line, column, identifierName, identifierNamePos, filename);\n    }\n\n    // Now, find each remaining newline char in the string.\n    while (i !== -1) {\n      position.line++;\n      position.column = 0;\n      last = i + 1;\n\n      // We mark the start of each line, which happens directly after this newline char\n      // unless this is the last char.\n      // When manually adding multi-line content (such as a comment), `line` will be `undefined`.\n      if (last < len && line !== undefined) {\n        this._mark(++line, 0, null, null, filename);\n      }\n      i = str.indexOf(\"\\n\", last);\n    }\n    position.column += len - last;\n  }\n\n  _mark(\n    line: number | undefined,\n    column: number | undefined,\n    identifierName: string | undefined,\n    identifierNamePos: Pos | undefined,\n    filename: string | undefined,\n  ): void {\n    this._map?.mark(\n      this._position,\n      line,\n      column,\n      identifierName,\n      identifierNamePos,\n      filename,\n    );\n  }\n\n  removeTrailingNewline(): void {\n    const queueCursor = this._queueCursor;\n    if (\n      queueCursor !== 0 &&\n      this._queue[queueCursor - 1].char === charcodes.lineFeed\n    ) {\n      this._queueCursor--;\n    }\n  }\n\n  removeLastSemicolon(): void {\n    const queueCursor = this._queueCursor;\n    if (\n      queueCursor !== 0 &&\n      this._queue[queueCursor - 1].char === charcodes.semicolon\n    ) {\n      this._queueCursor--;\n    }\n  }\n\n  getLastChar(): number {\n    const queueCursor = this._queueCursor;\n    return queueCursor !== 0 ? this._queue[queueCursor - 1].char : this._last;\n  }\n\n  /**\n   * This will only detect at most 1 newline after a call to `flush()`,\n   * but this has not been found so far, and an accurate count can be achieved if needed later.\n   */\n  getNewlineCount(): number {\n    const queueCursor = this._queueCursor;\n    let count = 0;\n    if (queueCursor === 0) return this._last === charcodes.lineFeed ? 1 : 0;\n    for (let i = queueCursor - 1; i >= 0; i--) {\n      if (this._queue[i].char !== charcodes.lineFeed) {\n        break;\n      }\n      count++;\n    }\n    return count === queueCursor && this._last === charcodes.lineFeed\n      ? count + 1\n      : count;\n  }\n\n  /**\n   * check if current _last + queue ends with newline, return the character before newline\n   *\n   * @param {*} ch\n   * @memberof Buffer\n   */\n  endsWithCharAndNewline(): number {\n    const queue = this._queue;\n    const queueCursor = this._queueCursor;\n    if (queueCursor !== 0) {\n      // every element in queue is one-length whitespace string\n      const lastCp = queue[queueCursor - 1].char;\n      if (lastCp !== charcodes.lineFeed) return;\n      if (queueCursor > 1) {\n        return queue[queueCursor - 2].char;\n      } else {\n        return this._last;\n      }\n    }\n    // We assume that everything being matched is at most a single token plus some whitespace,\n    // which everything currently is, but otherwise we'd have to expand _last or check _buf.\n  }\n\n  hasContent(): boolean {\n    return this._queueCursor !== 0 || !!this._last;\n  }\n\n  /**\n   * Certain sourcemap usecases expect mappings to be more accurate than\n   * Babel's generic sourcemap handling allows. For now, we special-case\n   * identifiers to allow for the primary cases to work.\n   * The goal of this line is to ensure that the map output from Babel will\n   * have an exact range on identifiers in the output code. Without this\n   * line, Babel would potentially include some number of trailing tokens\n   * that are printed after the identifier, but before another location has\n   * been assigned.\n   * This allows tooling like Rollup and Webpack to more accurately perform\n   * their own transformations. Most importantly, this allows the import/export\n   * transformations performed by those tools to loose less information when\n   * applying their own transformations on top of the code and map results\n   * generated by Babel itself.\n   *\n   * The primary example of this is the snippet:\n   *\n   *   import mod from \"mod\";\n   *   mod();\n   *\n   * With this line, there will be one mapping range over \"mod\" and another\n   * over \"();\", where previously it would have been a single mapping.\n   */\n  exactSource(loc: Loc | undefined, cb: () => void) {\n    if (!this._map) {\n      cb();\n      return;\n    }\n\n    this.source(\"start\", loc);\n    // @ts-expect-error identifierName is not defined\n    const identifierName = loc.identifierName;\n    const sourcePos = this._sourcePosition;\n    if (identifierName) {\n      this._canMarkIdName = false;\n      sourcePos.identifierName = identifierName;\n    }\n    cb();\n\n    if (identifierName) {\n      this._canMarkIdName = true;\n      sourcePos.identifierName = undefined;\n      sourcePos.identifierNamePos = undefined;\n    }\n    this.source(\"end\", loc);\n  }\n\n  /**\n   * Sets a given position as the current source location so generated code after this call\n   * will be given this position in the sourcemap.\n   */\n\n  source(prop: \"start\" | \"end\", loc: Loc | undefined): void {\n    if (!this._map) return;\n\n    // Since this is called extremely often, we reuse the same _sourcePosition\n    // object for the whole lifetime of the buffer.\n    this._normalizePosition(prop, loc, 0);\n  }\n\n  sourceWithOffset(\n    prop: \"start\" | \"end\",\n    loc: Loc | undefined,\n    columnOffset: number,\n  ): void {\n    if (!this._map) return;\n\n    this._normalizePosition(prop, loc, columnOffset);\n  }\n\n  /**\n   * Call a callback with a specific source location\n   */\n\n  withSource(prop: \"start\" | \"end\", loc: Loc, cb: () => void): void {\n    if (this._map) {\n      this.source(prop, loc);\n    }\n\n    cb();\n  }\n\n  _normalizePosition(prop: \"start\" | \"end\", loc: Loc, columnOffset: number) {\n    const pos = loc[prop];\n    const target = this._sourcePosition;\n\n    if (pos) {\n      target.line = pos.line;\n      // TODO: Fix https://github.com/babel/babel/issues/15712 in downstream\n      target.column = Math.max(pos.column + columnOffset, 0);\n      target.filename = loc.filename;\n    }\n  }\n\n  getCurrentColumn(): number {\n    const queue = this._queue;\n    const queueCursor = this._queueCursor;\n\n    let lastIndex = -1;\n    let len = 0;\n    for (let i = 0; i < queueCursor; i++) {\n      const item = queue[i];\n      if (item.char === charcodes.lineFeed) {\n        lastIndex = len;\n      }\n      len += item.repeat;\n    }\n\n    return lastIndex === -1 ? this._position.column + len : len - 1 - lastIndex;\n  }\n\n  getCurrentLine(): number {\n    let count = 0;\n\n    const queue = this._queue;\n    for (let i = 0; i < this._queueCursor; i++) {\n      if (queue[i].char === charcodes.lineFeed) {\n        count++;\n      }\n    }\n\n    return this._position.line + count;\n  }\n}\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.needsParens = needsParens;\nexports.needsWhitespace = needsWhitespace;\nexports.needsWhitespaceAfter = needsWhitespaceAfter;\nexports.needsWhitespaceBefore = needsWhitespaceBefore;\nvar whitespace = require(\"./whitespace.js\");\nvar parens = require(\"./parentheses.js\");\nvar _t = require(\"@babel/types\");\nconst {\n  FLIPPED_ALIAS_KEYS,\n  isCallExpression,\n  isExpressionStatement,\n  isMemberExpression,\n  isNewExpression\n} = _t;\nfunction expandAliases(obj) {\n  const newObj = {};\n  function add(type, func) {\n    const fn = newObj[type];\n    newObj[type] = fn ? function (node, parent, stack) {\n      const result = fn(node, parent, stack);\n      return result == null ? func(node, parent, stack) : result;\n    } : func;\n  }\n  for (const type of Object.keys(obj)) {\n    const aliases = FLIPPED_ALIAS_KEYS[type];\n    if (aliases) {\n      for (const alias of aliases) {\n        add(alias, obj[type]);\n      }\n    } else {\n      add(type, obj[type]);\n    }\n  }\n  return newObj;\n}\nconst expandedParens = expandAliases(parens);\nconst expandedWhitespaceNodes = expandAliases(whitespace.nodes);\nfunction find(obj, node, parent, printStack) {\n  const fn = obj[node.type];\n  return fn ? fn(node, parent, printStack) : null;\n}\nfunction isOrHasCallExpression(node) {\n  if (isCallExpression(node)) {\n    return true;\n  }\n  return isMemberExpression(node) && isOrHasCallExpression(node.object);\n}\nfunction needsWhitespace(node, parent, type) {\n  if (!node) return false;\n  if (isExpressionStatement(node)) {\n    node = node.expression;\n  }\n  const flag = find(expandedWhitespaceNodes, node, parent);\n  if (typeof flag === \"number\") {\n    return (flag & type) !== 0;\n  }\n  return false;\n}\nfunction needsWhitespaceBefore(node, parent) {\n  return needsWhitespace(node, parent, 1);\n}\nfunction needsWhitespaceAfter(node, parent) {\n  return needsWhitespace(node, parent, 2);\n}\nfunction needsParens(node, parent, printStack) {\n  if (!parent) return false;\n  if (isNewExpression(parent) && parent.callee === node) {\n    if (isOrHasCallExpression(node)) return true;\n  }\n  return find(expandedParens, node, parent, printStack);\n}\n\n//# sourceMappingURL=index.js.map\n","import * as whitespace from \"./whitespace.ts\";\nimport * as parens from \"./parentheses.ts\";\nimport {\n  FLIPPED_ALIAS_KEYS,\n  isCallExpression,\n  isExpressionStatement,\n  isMemberExpression,\n  isNewExpression,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\nimport type { WhitespaceFlag } from \"./whitespace.ts\";\n\nexport type NodeHandlers<R> = {\n  [K in string]?: (\n    node: K extends t.Node[\"type\"] ? Extract<t.Node, { type: K }> : t.Node,\n    // todo:\n    // node: K extends keyof typeof t\n    //   ? Extract<typeof t[K], { type: \"string\" }>\n    //   : t.Node,\n    parent: t.Node,\n    stack: t.Node[],\n  ) => R;\n};\n\nfunction expandAliases<R>(obj: NodeHandlers<R>) {\n  const newObj: NodeHandlers<R> = {};\n\n  function add(\n    type: string,\n    func: (node: t.Node, parent: t.Node, stack: t.Node[]) => R,\n  ) {\n    const fn = newObj[type];\n    newObj[type] = fn\n      ? function (node, parent, stack) {\n          const result = fn(node, parent, stack);\n\n          return result == null ? func(node, parent, stack) : result;\n        }\n      : func;\n  }\n\n  for (const type of Object.keys(obj)) {\n    const aliases = FLIPPED_ALIAS_KEYS[type];\n    if (aliases) {\n      for (const alias of aliases) {\n        add(alias, obj[type]);\n      }\n    } else {\n      add(type, obj[type]);\n    }\n  }\n\n  return newObj;\n}\n\n// Rather than using `t.is` on each object property, we pre-expand any type aliases\n// into concrete types so that the 'find' call below can be as fast as possible.\nconst expandedParens = expandAliases(parens);\nconst expandedWhitespaceNodes = expandAliases(whitespace.nodes);\n\nfunction find<R>(\n  obj: NodeHandlers<R>,\n  node: t.Node,\n  parent: t.Node,\n  printStack?: t.Node[],\n): R | null {\n  const fn = obj[node.type];\n  return fn ? fn(node, parent, printStack) : null;\n}\n\nfunction isOrHasCallExpression(node: t.Node): boolean {\n  if (isCallExpression(node)) {\n    return true;\n  }\n\n  return isMemberExpression(node) && isOrHasCallExpression(node.object);\n}\n\nexport function needsWhitespace(\n  node: t.Node,\n  parent: t.Node,\n  type: WhitespaceFlag,\n): boolean {\n  if (!node) return false;\n\n  if (isExpressionStatement(node)) {\n    node = node.expression;\n  }\n\n  const flag = find(expandedWhitespaceNodes, node, parent);\n\n  if (typeof flag === \"number\") {\n    return (flag & type) !== 0;\n  }\n\n  return false;\n}\n\nexport function needsWhitespaceBefore(node: t.Node, parent: t.Node) {\n  return needsWhitespace(node, parent, 1);\n}\n\nexport function needsWhitespaceAfter(node: t.Node, parent: t.Node) {\n  return needsWhitespace(node, parent, 2);\n}\n\nexport function needsParens(\n  node: t.Node,\n  parent: t.Node,\n  printStack?: t.Node[],\n) {\n  if (!parent) return false;\n\n  if (isNewExpression(parent) && parent.callee === node) {\n    if (isOrHasCallExpression(node)) return true;\n  }\n\n  return find(expandedParens, node, parent, printStack);\n}\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.nodes = void 0;\nvar _t = require(\"@babel/types\");\nconst {\n  FLIPPED_ALIAS_KEYS,\n  isArrayExpression,\n  isAssignmentExpression,\n  isBinary,\n  isBlockStatement,\n  isCallExpression,\n  isFunction,\n  isIdentifier,\n  isLiteral,\n  isMemberExpression,\n  isObjectExpression,\n  isOptionalCallExpression,\n  isOptionalMemberExpression,\n  isStringLiteral\n} = _t;\nfunction crawlInternal(node, state) {\n  if (!node) return state;\n  if (isMemberExpression(node) || isOptionalMemberExpression(node)) {\n    crawlInternal(node.object, state);\n    if (node.computed) crawlInternal(node.property, state);\n  } else if (isBinary(node) || isAssignmentExpression(node)) {\n    crawlInternal(node.left, state);\n    crawlInternal(node.right, state);\n  } else if (isCallExpression(node) || isOptionalCallExpression(node)) {\n    state.hasCall = true;\n    crawlInternal(node.callee, state);\n  } else if (isFunction(node)) {\n    state.hasFunction = true;\n  } else if (isIdentifier(node)) {\n    state.hasHelper = state.hasHelper || node.callee && isHelper(node.callee);\n  }\n  return state;\n}\nfunction crawl(node) {\n  return crawlInternal(node, {\n    hasCall: false,\n    hasFunction: false,\n    hasHelper: false\n  });\n}\nfunction isHelper(node) {\n  if (!node) return false;\n  if (isMemberExpression(node)) {\n    return isHelper(node.object) || isHelper(node.property);\n  } else if (isIdentifier(node)) {\n    return node.name === \"require\" || node.name.charCodeAt(0) === 95;\n  } else if (isCallExpression(node)) {\n    return isHelper(node.callee);\n  } else if (isBinary(node) || isAssignmentExpression(node)) {\n    return isIdentifier(node.left) && isHelper(node.left) || isHelper(node.right);\n  } else {\n    return false;\n  }\n}\nfunction isType(node) {\n  return isLiteral(node) || isObjectExpression(node) || isArrayExpression(node) || isIdentifier(node) || isMemberExpression(node);\n}\nconst nodes = {\n  AssignmentExpression(node) {\n    const state = crawl(node.right);\n    if (state.hasCall && state.hasHelper || state.hasFunction) {\n      return state.hasFunction ? 1 | 2 : 2;\n    }\n  },\n  SwitchCase(node, parent) {\n    return (!!node.consequent.length || parent.cases[0] === node ? 1 : 0) | (!node.consequent.length && parent.cases[parent.cases.length - 1] === node ? 2 : 0);\n  },\n  LogicalExpression(node) {\n    if (isFunction(node.left) || isFunction(node.right)) {\n      return 2;\n    }\n  },\n  Literal(node) {\n    if (isStringLiteral(node) && node.value === \"use strict\") {\n      return 2;\n    }\n  },\n  CallExpression(node) {\n    if (isFunction(node.callee) || isHelper(node)) {\n      return 1 | 2;\n    }\n  },\n  OptionalCallExpression(node) {\n    if (isFunction(node.callee)) {\n      return 1 | 2;\n    }\n  },\n  VariableDeclaration(node) {\n    for (let i = 0; i < node.declarations.length; i++) {\n      const declar = node.declarations[i];\n      let enabled = isHelper(declar.id) && !isType(declar.init);\n      if (!enabled && declar.init) {\n        const state = crawl(declar.init);\n        enabled = isHelper(declar.init) && state.hasCall || state.hasFunction;\n      }\n      if (enabled) {\n        return 1 | 2;\n      }\n    }\n  },\n  IfStatement(node) {\n    if (isBlockStatement(node.consequent)) {\n      return 1 | 2;\n    }\n  }\n};\nexports.nodes = nodes;\nnodes.ObjectProperty = nodes.ObjectTypeProperty = nodes.ObjectMethod = function (node, parent) {\n  if (parent.properties[0] === node) {\n    return 1;\n  }\n};\nnodes.ObjectTypeCallProperty = function (node, parent) {\n  var _parent$properties;\n  if (parent.callProperties[0] === node && !((_parent$properties = parent.properties) != null && _parent$properties.length)) {\n    return 1;\n  }\n};\nnodes.ObjectTypeIndexer = function (node, parent) {\n  var _parent$properties2, _parent$callPropertie;\n  if (parent.indexers[0] === node && !((_parent$properties2 = parent.properties) != null && _parent$properties2.length) && !((_parent$callPropertie = parent.callProperties) != null && _parent$callPropertie.length)) {\n    return 1;\n  }\n};\nnodes.ObjectTypeInternalSlot = function (node, parent) {\n  var _parent$properties3, _parent$callPropertie2, _parent$indexers;\n  if (parent.internalSlots[0] === node && !((_parent$properties3 = parent.properties) != null && _parent$properties3.length) && !((_parent$callPropertie2 = parent.callProperties) != null && _parent$callPropertie2.length) && !((_parent$indexers = parent.indexers) != null && _parent$indexers.length)) {\n    return 1;\n  }\n};\n[[\"Function\", true], [\"Class\", true], [\"Loop\", true], [\"LabeledStatement\", true], [\"SwitchStatement\", true], [\"TryStatement\", true]].forEach(function ([type, amounts]) {\n  [type].concat(FLIPPED_ALIAS_KEYS[type] || []).forEach(function (type) {\n    const ret = amounts ? 1 | 2 : 0;\n    nodes[type] = () => ret;\n  });\n});\n\n//# sourceMappingURL=whitespace.js.map\n","import {\n  FLIPPED_ALIAS_KEYS,\n  isArrayExpression,\n  isAssignmentExpression,\n  isBinary,\n  isBlockStatement,\n  isCallExpression,\n  isFunction,\n  isIdentifier,\n  isLiteral,\n  isMemberExpression,\n  isObjectExpression,\n  isOptionalCallExpression,\n  isOptionalMemberExpression,\n  isStringLiteral,\n} from \"@babel/types\";\nimport * as charCodes from \"charcodes\";\n\nimport type { NodeHandlers } from \"./index.ts\";\n\nimport type * as t from \"@babel/types\";\n\nconst enum WhitespaceFlag {\n  before = 1 << 0,\n  after = 1 << 1,\n}\n\nexport type { WhitespaceFlag };\n\nfunction crawlInternal(\n  node: t.Node,\n  state: { hasCall: boolean; hasFunction: boolean; hasHelper: boolean },\n) {\n  if (!node) return state;\n\n  if (isMemberExpression(node) || isOptionalMemberExpression(node)) {\n    crawlInternal(node.object, state);\n    if (node.computed) crawlInternal(node.property, state);\n  } else if (isBinary(node) || isAssignmentExpression(node)) {\n    crawlInternal(node.left, state);\n    crawlInternal(node.right, state);\n  } else if (isCallExpression(node) || isOptionalCallExpression(node)) {\n    state.hasCall = true;\n    crawlInternal(node.callee, state);\n  } else if (isFunction(node)) {\n    state.hasFunction = true;\n  } else if (isIdentifier(node)) {\n    state.hasHelper =\n      // @ts-expect-error todo(flow->ts): node.callee is not really expected here\n      state.hasHelper || (node.callee && isHelper(node.callee));\n  }\n\n  return state;\n}\n\n/**\n * Crawl a node to test if it contains a CallExpression, a Function, or a Helper.\n *\n * @example\n * crawl(node)\n * // { hasCall: false, hasFunction: true, hasHelper: false }\n */\n\nfunction crawl(node: t.Node) {\n  return crawlInternal(node, {\n    hasCall: false,\n    hasFunction: false,\n    hasHelper: false,\n  });\n}\n\n/**\n * Test if a node is or has a helper.\n */\n\nfunction isHelper(node: t.Node): boolean {\n  if (!node) return false;\n\n  if (isMemberExpression(node)) {\n    return isHelper(node.object) || isHelper(node.property);\n  } else if (isIdentifier(node)) {\n    return (\n      node.name === \"require\" ||\n      node.name.charCodeAt(0) === charCodes.underscore\n    );\n  } else if (isCallExpression(node)) {\n    return isHelper(node.callee);\n  } else if (isBinary(node) || isAssignmentExpression(node)) {\n    return (\n      (isIdentifier(node.left) && isHelper(node.left)) || isHelper(node.right)\n    );\n  } else {\n    return false;\n  }\n}\n\nfunction isType(node: t.Node) {\n  return (\n    isLiteral(node) ||\n    isObjectExpression(node) ||\n    isArrayExpression(node) ||\n    isIdentifier(node) ||\n    isMemberExpression(node)\n  );\n}\n\n/**\n * Tests for node types that need whitespace.\n */\n\nexport const nodes: NodeHandlers<WhitespaceFlag> = {\n  /**\n   * Test if AssignmentExpression needs whitespace.\n   */\n\n  AssignmentExpression(node: t.AssignmentExpression): WhitespaceFlag {\n    const state = crawl(node.right);\n    if ((state.hasCall && state.hasHelper) || state.hasFunction) {\n      return state.hasFunction\n        ? WhitespaceFlag.before | WhitespaceFlag.after\n        : WhitespaceFlag.after;\n    }\n  },\n\n  /**\n   * Test if SwitchCase needs whitespace.\n   */\n\n  SwitchCase(node: t.SwitchCase, parent: t.SwitchStatement): WhitespaceFlag {\n    return (\n      (!!node.consequent.length || parent.cases[0] === node\n        ? WhitespaceFlag.before\n        : 0) |\n      (!node.consequent.length && parent.cases[parent.cases.length - 1] === node\n        ? WhitespaceFlag.after\n        : 0)\n    );\n  },\n\n  /**\n   * Test if LogicalExpression needs whitespace.\n   */\n\n  LogicalExpression(node: t.LogicalExpression): WhitespaceFlag {\n    if (isFunction(node.left) || isFunction(node.right)) {\n      return WhitespaceFlag.after;\n    }\n  },\n\n  /**\n   * Test if Literal needs whitespace.\n   */\n\n  Literal(node: t.Literal): WhitespaceFlag {\n    if (isStringLiteral(node) && node.value === \"use strict\") {\n      return WhitespaceFlag.after;\n    }\n  },\n\n  /**\n   * Test if CallExpressionish needs whitespace.\n   */\n\n  CallExpression(node: t.CallExpression): WhitespaceFlag {\n    if (isFunction(node.callee) || isHelper(node)) {\n      return WhitespaceFlag.before | WhitespaceFlag.after;\n    }\n  },\n\n  OptionalCallExpression(node: t.OptionalCallExpression): WhitespaceFlag {\n    if (isFunction(node.callee)) {\n      return WhitespaceFlag.before | WhitespaceFlag.after;\n    }\n  },\n\n  /**\n   * Test if VariableDeclaration needs whitespace.\n   */\n\n  VariableDeclaration(node: t.VariableDeclaration): WhitespaceFlag {\n    for (let i = 0; i < node.declarations.length; i++) {\n      const declar = node.declarations[i];\n\n      let enabled = isHelper(declar.id) && !isType(declar.init);\n      if (!enabled && declar.init) {\n        const state = crawl(declar.init);\n        enabled = (isHelper(declar.init) && state.hasCall) || state.hasFunction;\n      }\n\n      if (enabled) {\n        return WhitespaceFlag.before | WhitespaceFlag.after;\n      }\n    }\n  },\n\n  /**\n   * Test if IfStatement needs whitespace.\n   */\n\n  IfStatement(node: t.IfStatement): WhitespaceFlag {\n    if (isBlockStatement(node.consequent)) {\n      return WhitespaceFlag.before | WhitespaceFlag.after;\n    }\n  },\n};\n\n/**\n * Test if Property needs whitespace.\n */\n\nnodes.ObjectProperty =\n  nodes.ObjectTypeProperty =\n  nodes.ObjectMethod =\n    function (\n      node: t.ObjectProperty | t.ObjectTypeProperty | t.ObjectMethod,\n      parent: t.ObjectExpression,\n    ): WhitespaceFlag {\n      if (parent.properties[0] === node) {\n        return WhitespaceFlag.before;\n      }\n    };\n\nnodes.ObjectTypeCallProperty = function (\n  node: t.ObjectTypeCallProperty,\n  parent: t.ObjectTypeAnnotation,\n): WhitespaceFlag {\n  if (parent.callProperties[0] === node && !parent.properties?.length) {\n    return WhitespaceFlag.before;\n  }\n};\n\nnodes.ObjectTypeIndexer = function (\n  node: t.ObjectTypeIndexer,\n  parent: t.ObjectTypeAnnotation,\n): WhitespaceFlag {\n  if (\n    parent.indexers[0] === node &&\n    !parent.properties?.length &&\n    !parent.callProperties?.length\n  ) {\n    return WhitespaceFlag.before;\n  }\n};\n\nnodes.ObjectTypeInternalSlot = function (\n  node: t.ObjectTypeInternalSlot,\n  parent: t.ObjectTypeAnnotation,\n): WhitespaceFlag {\n  if (\n    parent.internalSlots[0] === node &&\n    !parent.properties?.length &&\n    !parent.callProperties?.length &&\n    !parent.indexers?.length\n  ) {\n    return WhitespaceFlag.before;\n  }\n};\n\n/**\n * Add whitespace tests for nodes and their aliases.\n */\n\n(\n  [\n    [\"Function\", true],\n    [\"Class\", true],\n    [\"Loop\", true],\n    [\"LabeledStatement\", true],\n    [\"SwitchStatement\", true],\n    [\"TryStatement\", true],\n  ] as const\n).forEach(function ([type, amounts]) {\n  [type as string]\n    .concat(FLIPPED_ALIAS_KEYS[type] || [])\n    .forEach(function (type) {\n      const ret = amounts ? WhitespaceFlag.before | WhitespaceFlag.after : 0;\n      nodes[type] = () => ret;\n    });\n});\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ArrowFunctionExpression = ArrowFunctionExpression;\nexports.AssignmentExpression = AssignmentExpression;\nexports.Binary = Binary;\nexports.BinaryExpression = BinaryExpression;\nexports.ClassExpression = ClassExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.DoExpression = DoExpression;\nexports.FunctionExpression = FunctionExpression;\nexports.FunctionTypeAnnotation = FunctionTypeAnnotation;\nexports.Identifier = Identifier;\nexports.LogicalExpression = LogicalExpression;\nexports.NullableTypeAnnotation = NullableTypeAnnotation;\nexports.ObjectExpression = ObjectExpression;\nexports.OptionalIndexedAccessType = OptionalIndexedAccessType;\nexports.OptionalCallExpression = exports.OptionalMemberExpression = OptionalMemberExpression;\nexports.SequenceExpression = SequenceExpression;\nexports.TSTypeAssertion = exports.TSSatisfiesExpression = exports.TSAsExpression = TSAsExpression;\nexports.TSInferType = TSInferType;\nexports.TSInstantiationExpression = TSInstantiationExpression;\nexports.TSIntersectionType = exports.TSUnionType = TSUnionType;\nexports.UnaryLike = UnaryLike;\nexports.IntersectionTypeAnnotation = exports.UnionTypeAnnotation = UnionTypeAnnotation;\nexports.UpdateExpression = UpdateExpression;\nexports.AwaitExpression = exports.YieldExpression = YieldExpression;\nvar _t = require(\"@babel/types\");\nconst {\n  isArrayTypeAnnotation,\n  isArrowFunctionExpression,\n  isAssignmentExpression,\n  isAwaitExpression,\n  isBinary,\n  isBinaryExpression,\n  isUpdateExpression,\n  isCallExpression,\n  isClass,\n  isClassExpression,\n  isConditional,\n  isConditionalExpression,\n  isExportDeclaration,\n  isExportDefaultDeclaration,\n  isExpressionStatement,\n  isFor,\n  isForInStatement,\n  isForOfStatement,\n  isForStatement,\n  isFunctionExpression,\n  isIfStatement,\n  isIndexedAccessType,\n  isIntersectionTypeAnnotation,\n  isLogicalExpression,\n  isMemberExpression,\n  isNewExpression,\n  isNullableTypeAnnotation,\n  isObjectPattern,\n  isOptionalCallExpression,\n  isOptionalMemberExpression,\n  isReturnStatement,\n  isSequenceExpression,\n  isSwitchStatement,\n  isTSArrayType,\n  isTSAsExpression,\n  isTSInstantiationExpression,\n  isTSIntersectionType,\n  isTSNonNullExpression,\n  isTSOptionalType,\n  isTSRestType,\n  isTSTypeAssertion,\n  isTSUnionType,\n  isTaggedTemplateExpression,\n  isThrowStatement,\n  isTypeAnnotation,\n  isUnaryLike,\n  isUnionTypeAnnotation,\n  isVariableDeclarator,\n  isWhileStatement,\n  isYieldExpression,\n  isTSSatisfiesExpression\n} = _t;\nconst PRECEDENCE = {\n  \"||\": 0,\n  \"??\": 0,\n  \"|>\": 0,\n  \"&&\": 1,\n  \"|\": 2,\n  \"^\": 3,\n  \"&\": 4,\n  \"==\": 5,\n  \"===\": 5,\n  \"!=\": 5,\n  \"!==\": 5,\n  \"<\": 6,\n  \">\": 6,\n  \"<=\": 6,\n  \">=\": 6,\n  in: 6,\n  instanceof: 6,\n  \">>\": 7,\n  \"<<\": 7,\n  \">>>\": 7,\n  \"+\": 8,\n  \"-\": 8,\n  \"*\": 9,\n  \"/\": 9,\n  \"%\": 9,\n  \"**\": 10\n};\nfunction isTSTypeExpression(node) {\n  return isTSAsExpression(node) || isTSSatisfiesExpression(node) || isTSTypeAssertion(node);\n}\nconst isClassExtendsClause = (node, parent) => isClass(parent, {\n  superClass: node\n});\nconst hasPostfixPart = (node, parent) => (isMemberExpression(parent) || isOptionalMemberExpression(parent)) && parent.object === node || (isCallExpression(parent) || isOptionalCallExpression(parent) || isNewExpression(parent)) && parent.callee === node || isTaggedTemplateExpression(parent) && parent.tag === node || isTSNonNullExpression(parent);\nfunction NullableTypeAnnotation(node, parent) {\n  return isArrayTypeAnnotation(parent);\n}\nfunction FunctionTypeAnnotation(node, parent, printStack) {\n  if (printStack.length < 3) return;\n  return isUnionTypeAnnotation(parent) || isIntersectionTypeAnnotation(parent) || isArrayTypeAnnotation(parent) || isTypeAnnotation(parent) && isArrowFunctionExpression(printStack[printStack.length - 3]);\n}\nfunction UpdateExpression(node, parent) {\n  return hasPostfixPart(node, parent) || isClassExtendsClause(node, parent);\n}\nfunction ObjectExpression(node, parent, printStack) {\n  return isFirstInContext(printStack, 1 | 2);\n}\nfunction DoExpression(node, parent, printStack) {\n  return !node.async && isFirstInContext(printStack, 1);\n}\nfunction Binary(node, parent) {\n  if (node.operator === \"**\" && isBinaryExpression(parent, {\n    operator: \"**\"\n  })) {\n    return parent.left === node;\n  }\n  if (isClassExtendsClause(node, parent)) {\n    return true;\n  }\n  if (hasPostfixPart(node, parent) || isUnaryLike(parent) || isAwaitExpression(parent)) {\n    return true;\n  }\n  if (isBinary(parent)) {\n    const parentOp = parent.operator;\n    const parentPos = PRECEDENCE[parentOp];\n    const nodeOp = node.operator;\n    const nodePos = PRECEDENCE[nodeOp];\n    if (parentPos === nodePos && parent.right === node && !isLogicalExpression(parent) || parentPos > nodePos) {\n      return true;\n    }\n  }\n}\nfunction UnionTypeAnnotation(node, parent) {\n  return isArrayTypeAnnotation(parent) || isNullableTypeAnnotation(parent) || isIntersectionTypeAnnotation(parent) || isUnionTypeAnnotation(parent);\n}\nfunction OptionalIndexedAccessType(node, parent) {\n  return isIndexedAccessType(parent, {\n    objectType: node\n  });\n}\nfunction TSAsExpression() {\n  return true;\n}\nfunction TSUnionType(node, parent) {\n  return isTSArrayType(parent) || isTSOptionalType(parent) || isTSIntersectionType(parent) || isTSUnionType(parent) || isTSRestType(parent);\n}\nfunction TSInferType(node, parent) {\n  return isTSArrayType(parent) || isTSOptionalType(parent);\n}\nfunction TSInstantiationExpression(node, parent) {\n  return (isCallExpression(parent) || isOptionalCallExpression(parent) || isNewExpression(parent) || isTSInstantiationExpression(parent)) && !!parent.typeParameters;\n}\nfunction BinaryExpression(node, parent) {\n  return node.operator === \"in\" && (isVariableDeclarator(parent) || isFor(parent));\n}\nfunction SequenceExpression(node, parent) {\n  if (isForStatement(parent) || isThrowStatement(parent) || isReturnStatement(parent) || isIfStatement(parent) && parent.test === node || isWhileStatement(parent) && parent.test === node || isForInStatement(parent) && parent.right === node || isSwitchStatement(parent) && parent.discriminant === node || isExpressionStatement(parent) && parent.expression === node) {\n    return false;\n  }\n  return true;\n}\nfunction YieldExpression(node, parent) {\n  return isBinary(parent) || isUnaryLike(parent) || hasPostfixPart(node, parent) || isAwaitExpression(parent) && isYieldExpression(node) || isConditionalExpression(parent) && node === parent.test || isClassExtendsClause(node, parent);\n}\nfunction ClassExpression(node, parent, printStack) {\n  return isFirstInContext(printStack, 1 | 4);\n}\nfunction UnaryLike(node, parent) {\n  return hasPostfixPart(node, parent) || isBinaryExpression(parent, {\n    operator: \"**\",\n    left: node\n  }) || isClassExtendsClause(node, parent);\n}\nfunction FunctionExpression(node, parent, printStack) {\n  return isFirstInContext(printStack, 1 | 4);\n}\nfunction ArrowFunctionExpression(node, parent) {\n  return isExportDeclaration(parent) || ConditionalExpression(node, parent);\n}\nfunction ConditionalExpression(node, parent) {\n  if (isUnaryLike(parent) || isBinary(parent) || isConditionalExpression(parent, {\n    test: node\n  }) || isAwaitExpression(parent) || isTSTypeExpression(parent)) {\n    return true;\n  }\n  return UnaryLike(node, parent);\n}\nfunction OptionalMemberExpression(node, parent) {\n  return isCallExpression(parent, {\n    callee: node\n  }) || isMemberExpression(parent, {\n    object: node\n  });\n}\nfunction AssignmentExpression(node, parent) {\n  if (isObjectPattern(node.left)) {\n    return true;\n  } else {\n    return ConditionalExpression(node, parent);\n  }\n}\nfunction LogicalExpression(node, parent) {\n  if (isTSTypeExpression(parent)) return true;\n  switch (node.operator) {\n    case \"||\":\n      if (!isLogicalExpression(parent)) return false;\n      return parent.operator === \"??\" || parent.operator === \"&&\";\n    case \"&&\":\n      return isLogicalExpression(parent, {\n        operator: \"??\"\n      });\n    case \"??\":\n      return isLogicalExpression(parent) && parent.operator !== \"??\";\n  }\n}\nfunction Identifier(node, parent, printStack) {\n  var _node$extra;\n  if ((_node$extra = node.extra) != null && _node$extra.parenthesized && isAssignmentExpression(parent, {\n    left: node\n  }) && (isFunctionExpression(parent.right) || isClassExpression(parent.right)) && parent.right.id == null) {\n    return true;\n  }\n  if (node.name === \"let\") {\n    const isFollowedByBracket = isMemberExpression(parent, {\n      object: node,\n      computed: true\n    }) || isOptionalMemberExpression(parent, {\n      object: node,\n      computed: true,\n      optional: false\n    });\n    return isFirstInContext(printStack, isFollowedByBracket ? 1 | 8 | 16 | 32 : 32);\n  }\n  return node.name === \"async\" && isForOfStatement(parent) && node === parent.left;\n}\nfunction isFirstInContext(printStack, checkParam) {\n  const expressionStatement = checkParam & 1;\n  const arrowBody = checkParam & 2;\n  const exportDefault = checkParam & 4;\n  const forHead = checkParam & 8;\n  const forInHead = checkParam & 16;\n  const forOfHead = checkParam & 32;\n  let i = printStack.length - 1;\n  if (i <= 0) return;\n  let node = printStack[i];\n  i--;\n  let parent = printStack[i];\n  while (i >= 0) {\n    if (expressionStatement && isExpressionStatement(parent, {\n      expression: node\n    }) || exportDefault && isExportDefaultDeclaration(parent, {\n      declaration: node\n    }) || arrowBody && isArrowFunctionExpression(parent, {\n      body: node\n    }) || forHead && isForStatement(parent, {\n      init: node\n    }) || forInHead && isForInStatement(parent, {\n      left: node\n    }) || forOfHead && isForOfStatement(parent, {\n      left: node\n    })) {\n      return true;\n    }\n    if (i > 0 && (hasPostfixPart(node, parent) && !isNewExpression(parent) || isSequenceExpression(parent) && parent.expressions[0] === node || isUpdateExpression(parent) && !parent.prefix || isConditional(parent, {\n      test: node\n    }) || isBinary(parent, {\n      left: node\n    }) || isAssignmentExpression(parent, {\n      left: node\n    }))) {\n      node = parent;\n      i--;\n      parent = printStack[i];\n    } else {\n      return false;\n    }\n  }\n  return false;\n}\n\n//# sourceMappingURL=parentheses.js.map\n","import {\n  isArrayTypeAnnotation,\n  isArrowFunctionExpression,\n  isAssignmentExpression,\n  isAwaitExpression,\n  isBinary,\n  isBinaryExpression,\n  isUpdateExpression,\n  isCallExpression,\n  isClass,\n  isClassExpression,\n  isConditional,\n  isConditionalExpression,\n  isExportDeclaration,\n  isExportDefaultDeclaration,\n  isExpressionStatement,\n  isFor,\n  isForInStatement,\n  isForOfStatement,\n  isForStatement,\n  isFunctionExpression,\n  isIfStatement,\n  isIndexedAccessType,\n  isIntersectionTypeAnnotation,\n  isLogicalExpression,\n  isMemberExpression,\n  isNewExpression,\n  isNullableTypeAnnotation,\n  isObjectPattern,\n  isOptionalCallExpression,\n  isOptionalMemberExpression,\n  isReturnStatement,\n  isSequenceExpression,\n  isSwitchStatement,\n  isTSArrayType,\n  isTSAsExpression,\n  isTSInstantiationExpression,\n  isTSIntersectionType,\n  isTSNonNullExpression,\n  isTSOptionalType,\n  isTSRestType,\n  isTSTypeAssertion,\n  isTSUnionType,\n  isTaggedTemplateExpression,\n  isThrowStatement,\n  isTypeAnnotation,\n  isUnaryLike,\n  isUnionTypeAnnotation,\n  isVariableDeclarator,\n  isWhileStatement,\n  isYieldExpression,\n  isTSSatisfiesExpression,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nconst PRECEDENCE = {\n  \"||\": 0,\n  \"??\": 0,\n  \"|>\": 0,\n  \"&&\": 1,\n  \"|\": 2,\n  \"^\": 3,\n  \"&\": 4,\n  \"==\": 5,\n  \"===\": 5,\n  \"!=\": 5,\n  \"!==\": 5,\n  \"<\": 6,\n  \">\": 6,\n  \"<=\": 6,\n  \">=\": 6,\n  in: 6,\n  instanceof: 6,\n  \">>\": 7,\n  \"<<\": 7,\n  \">>>\": 7,\n  \"+\": 8,\n  \"-\": 8,\n  \"*\": 9,\n  \"/\": 9,\n  \"%\": 9,\n  \"**\": 10,\n};\n\nconst enum CheckParam {\n  expressionStatement = 1 << 0,\n  arrowBody = 1 << 1,\n  exportDefault = 1 << 2,\n  forHead = 1 << 3,\n  forInHead = 1 << 4,\n  forOfHead = 1 << 5,\n}\n\nfunction isTSTypeExpression(node: t.Node) {\n  return (\n    isTSAsExpression(node) ||\n    isTSSatisfiesExpression(node) ||\n    isTSTypeAssertion(node)\n  );\n}\n\nconst isClassExtendsClause = (\n  node: t.Node,\n  parent: t.Node,\n): parent is t.Class => isClass(parent, { superClass: node });\n\nconst hasPostfixPart = (node: t.Node, parent: t.Node) =>\n  ((isMemberExpression(parent) || isOptionalMemberExpression(parent)) &&\n    parent.object === node) ||\n  ((isCallExpression(parent) ||\n    isOptionalCallExpression(parent) ||\n    isNewExpression(parent)) &&\n    parent.callee === node) ||\n  (isTaggedTemplateExpression(parent) && parent.tag === node) ||\n  isTSNonNullExpression(parent);\n\nexport function NullableTypeAnnotation(\n  node: t.NullableTypeAnnotation,\n  parent: t.Node,\n): boolean {\n  return isArrayTypeAnnotation(parent);\n}\n\nexport function FunctionTypeAnnotation(\n  node: t.FunctionTypeAnnotation,\n  parent: t.Node,\n  printStack: Array<t.Node>,\n): boolean {\n  if (printStack.length < 3) return;\n\n  return (\n    // (() => A) | (() => B)\n    isUnionTypeAnnotation(parent) ||\n    // (() => A) & (() => B)\n    isIntersectionTypeAnnotation(parent) ||\n    // (() => A)[]\n    isArrayTypeAnnotation(parent) ||\n    // <T>(A: T): (T => T[]) => B => [A, B]\n    (isTypeAnnotation(parent) &&\n      // Check grandparent\n      isArrowFunctionExpression(printStack[printStack.length - 3]))\n  );\n}\n\nexport function UpdateExpression(\n  node: t.UpdateExpression,\n  parent: t.Node,\n): boolean {\n  return hasPostfixPart(node, parent) || isClassExtendsClause(node, parent);\n}\n\nexport function ObjectExpression(\n  node: t.ObjectExpression,\n  parent: t.Node,\n  printStack: Array<t.Node>,\n): boolean {\n  return isFirstInContext(\n    printStack,\n    CheckParam.expressionStatement | CheckParam.arrowBody,\n  );\n}\n\nexport function DoExpression(\n  node: t.DoExpression,\n  parent: t.Node,\n  printStack: Array<t.Node>,\n): boolean {\n  // `async do` can start an expression statement\n  return (\n    !node.async && isFirstInContext(printStack, CheckParam.expressionStatement)\n  );\n}\n\nexport function Binary(node: t.BinaryExpression, parent: t.Node): boolean {\n  if (\n    node.operator === \"**\" &&\n    isBinaryExpression(parent, { operator: \"**\" })\n  ) {\n    return parent.left === node;\n  }\n\n  if (isClassExtendsClause(node, parent)) {\n    return true;\n  }\n\n  if (\n    hasPostfixPart(node, parent) ||\n    isUnaryLike(parent) ||\n    isAwaitExpression(parent)\n  ) {\n    return true;\n  }\n\n  if (isBinary(parent)) {\n    const parentOp = parent.operator;\n    const parentPos = PRECEDENCE[parentOp];\n\n    const nodeOp = node.operator;\n    const nodePos = PRECEDENCE[nodeOp];\n\n    if (\n      // Logical expressions with the same precedence don't need parens.\n      (parentPos === nodePos &&\n        parent.right === node &&\n        !isLogicalExpression(parent)) ||\n      parentPos > nodePos\n    ) {\n      return true;\n    }\n  }\n}\n\nexport function UnionTypeAnnotation(\n  node: t.UnionTypeAnnotation,\n  parent: t.Node,\n): boolean {\n  return (\n    isArrayTypeAnnotation(parent) ||\n    isNullableTypeAnnotation(parent) ||\n    isIntersectionTypeAnnotation(parent) ||\n    isUnionTypeAnnotation(parent)\n  );\n}\n\nexport { UnionTypeAnnotation as IntersectionTypeAnnotation };\n\nexport function OptionalIndexedAccessType(\n  node: t.OptionalIndexedAccessType,\n  parent: t.Node,\n): boolean {\n  return isIndexedAccessType(parent, { objectType: node });\n}\n\nexport function TSAsExpression() {\n  return true;\n}\n\nexport {\n  TSAsExpression as TSSatisfiesExpression,\n  TSAsExpression as TSTypeAssertion,\n};\n\nexport function TSUnionType(node: t.TSUnionType, parent: t.Node): boolean {\n  return (\n    isTSArrayType(parent) ||\n    isTSOptionalType(parent) ||\n    isTSIntersectionType(parent) ||\n    isTSUnionType(parent) ||\n    isTSRestType(parent)\n  );\n}\n\nexport { TSUnionType as TSIntersectionType };\n\nexport function TSInferType(node: t.TSInferType, parent: t.Node): boolean {\n  return isTSArrayType(parent) || isTSOptionalType(parent);\n}\n\nexport function TSInstantiationExpression(\n  node: t.TSInstantiationExpression,\n  parent: t.Node,\n) {\n  return (\n    (isCallExpression(parent) ||\n      isOptionalCallExpression(parent) ||\n      isNewExpression(parent) ||\n      isTSInstantiationExpression(parent)) &&\n    !!parent.typeParameters\n  );\n}\n\nexport function BinaryExpression(\n  node: t.BinaryExpression,\n  parent: t.Node,\n): boolean {\n  // let i = (1 in []);\n  // for ((1 in []);;);\n  return (\n    node.operator === \"in\" && (isVariableDeclarator(parent) || isFor(parent))\n  );\n}\n\nexport function SequenceExpression(\n  node: t.SequenceExpression,\n  parent: t.Node,\n): boolean {\n  if (\n    // Although parentheses wouldn't hurt around sequence\n    // expressions in the head of for loops, traditional style\n    // dictates that e.g. i++, j++ should not be wrapped with\n    // parentheses.\n    isForStatement(parent) ||\n    isThrowStatement(parent) ||\n    isReturnStatement(parent) ||\n    (isIfStatement(parent) && parent.test === node) ||\n    (isWhileStatement(parent) && parent.test === node) ||\n    (isForInStatement(parent) && parent.right === node) ||\n    (isSwitchStatement(parent) && parent.discriminant === node) ||\n    (isExpressionStatement(parent) && parent.expression === node)\n  ) {\n    return false;\n  }\n\n  // Otherwise err on the side of overparenthesization, adding\n  // explicit exceptions above if this proves overzealous.\n  return true;\n}\n\nexport function YieldExpression(\n  node: t.YieldExpression,\n  parent: t.Node,\n): boolean {\n  return (\n    isBinary(parent) ||\n    isUnaryLike(parent) ||\n    hasPostfixPart(node, parent) ||\n    (isAwaitExpression(parent) && isYieldExpression(node)) ||\n    (isConditionalExpression(parent) && node === parent.test) ||\n    isClassExtendsClause(node, parent)\n  );\n}\n\nexport { YieldExpression as AwaitExpression };\n\nexport function ClassExpression(\n  node: t.ClassExpression,\n  parent: t.Node,\n  printStack: Array<t.Node>,\n): boolean {\n  return isFirstInContext(\n    printStack,\n    CheckParam.expressionStatement | CheckParam.exportDefault,\n  );\n}\n\nexport function UnaryLike(\n  node:\n    | t.UnaryLike\n    | t.ArrowFunctionExpression\n    | t.ConditionalExpression\n    | t.AssignmentExpression,\n  parent: t.Node,\n): boolean {\n  return (\n    hasPostfixPart(node, parent) ||\n    isBinaryExpression(parent, { operator: \"**\", left: node }) ||\n    isClassExtendsClause(node, parent)\n  );\n}\n\nexport function FunctionExpression(\n  node: t.FunctionExpression,\n  parent: t.Node,\n  printStack: Array<t.Node>,\n): boolean {\n  return isFirstInContext(\n    printStack,\n    CheckParam.expressionStatement | CheckParam.exportDefault,\n  );\n}\n\nexport function ArrowFunctionExpression(\n  node: t.ArrowFunctionExpression,\n  parent: t.Node,\n): boolean {\n  return isExportDeclaration(parent) || ConditionalExpression(node, parent);\n}\n\nexport function ConditionalExpression(\n  node:\n    | t.ConditionalExpression\n    | t.ArrowFunctionExpression\n    | t.AssignmentExpression,\n  parent?: t.Node,\n): boolean {\n  if (\n    isUnaryLike(parent) ||\n    isBinary(parent) ||\n    isConditionalExpression(parent, { test: node }) ||\n    isAwaitExpression(parent) ||\n    isTSTypeExpression(parent)\n  ) {\n    return true;\n  }\n\n  return UnaryLike(node, parent);\n}\n\nexport function OptionalMemberExpression(\n  node: t.OptionalMemberExpression,\n  parent: t.Node,\n): boolean {\n  return (\n    isCallExpression(parent, { callee: node }) ||\n    isMemberExpression(parent, { object: node })\n  );\n}\n\nexport { OptionalMemberExpression as OptionalCallExpression };\n\nexport function AssignmentExpression(\n  node: t.AssignmentExpression,\n  parent: t.Node,\n): boolean {\n  if (isObjectPattern(node.left)) {\n    return true;\n  } else {\n    return ConditionalExpression(node, parent);\n  }\n}\n\nexport function LogicalExpression(\n  node: t.LogicalExpression,\n  parent: t.Node,\n): boolean {\n  if (isTSTypeExpression(parent)) return true;\n  switch (node.operator) {\n    case \"||\":\n      if (!isLogicalExpression(parent)) return false;\n      return parent.operator === \"??\" || parent.operator === \"&&\";\n    case \"&&\":\n      return isLogicalExpression(parent, { operator: \"??\" });\n    case \"??\":\n      return isLogicalExpression(parent) && parent.operator !== \"??\";\n  }\n}\n\nexport function Identifier(\n  node: t.Identifier,\n  parent: t.Node,\n  printStack: Array<t.Node>,\n): boolean {\n  // 13.15.2 AssignmentExpression RS: Evaluation\n  // (fn) = function () {};\n  if (\n    node.extra?.parenthesized &&\n    isAssignmentExpression(parent, { left: node }) &&\n    (isFunctionExpression(parent.right) || isClassExpression(parent.right)) &&\n    parent.right.id == null\n  ) {\n    return true;\n  }\n  // Non-strict code allows the identifier `let`, but it cannot occur as-is in\n  // certain contexts to avoid ambiguity with contextual keyword `let`.\n  if (node.name === \"let\") {\n    // Some contexts only forbid `let [`, so check if the next token would\n    // be the left bracket of a computed member expression.\n    const isFollowedByBracket =\n      isMemberExpression(parent, {\n        object: node,\n        computed: true,\n      }) ||\n      isOptionalMemberExpression(parent, {\n        object: node,\n        computed: true,\n        optional: false,\n      });\n    return isFirstInContext(\n      printStack,\n      isFollowedByBracket\n        ? CheckParam.expressionStatement |\n            CheckParam.forHead |\n            CheckParam.forInHead |\n            CheckParam.forOfHead\n        : CheckParam.forOfHead,\n    );\n  }\n\n  // ECMAScript specifically forbids a for-of loop from starting with the\n  // token sequence `for (async of`, because it would be ambiguous with\n  // `for (async of => {};;)`, so we need to add extra parentheses.\n  //\n  // If the parent is a for-await-of loop (i.e. parent.await === true), the\n  // parentheses aren't strictly needed, but we add them anyway because\n  // some tools (including earlier Babel versions) can't parse\n  // `for await (async of [])` without them.\n  return (\n    node.name === \"async\" && isForOfStatement(parent) && node === parent.left\n  );\n}\n\n// Walk up the print stack to determine if our node can come first\n// in a particular context.\nfunction isFirstInContext(\n  printStack: Array<t.Node>,\n  checkParam: CheckParam,\n): boolean {\n  const expressionStatement = checkParam & CheckParam.expressionStatement;\n  const arrowBody = checkParam & CheckParam.arrowBody;\n  const exportDefault = checkParam & CheckParam.exportDefault;\n  const forHead = checkParam & CheckParam.forHead;\n  const forInHead = checkParam & CheckParam.forInHead;\n  const forOfHead = checkParam & CheckParam.forOfHead;\n\n  let i = printStack.length - 1;\n  if (i <= 0) return;\n  let node = printStack[i];\n  i--;\n  let parent = printStack[i];\n  while (i >= 0) {\n    if (\n      (expressionStatement &&\n        isExpressionStatement(parent, { expression: node })) ||\n      (exportDefault &&\n        isExportDefaultDeclaration(parent, { declaration: node })) ||\n      (arrowBody && isArrowFunctionExpression(parent, { body: node })) ||\n      (forHead && isForStatement(parent, { init: node })) ||\n      (forInHead && isForInStatement(parent, { left: node })) ||\n      (forOfHead && isForOfStatement(parent, { left: node }))\n    ) {\n      return true;\n    }\n\n    if (\n      i > 0 &&\n      ((hasPostfixPart(node, parent) && !isNewExpression(parent)) ||\n        (isSequenceExpression(parent) && parent.expressions[0] === node) ||\n        (isUpdateExpression(parent) && !parent.prefix) ||\n        isConditional(parent, { test: node }) ||\n        isBinary(parent, { left: node }) ||\n        isAssignmentExpression(parent, { left: node }))\n    ) {\n      node = parent;\n      i--;\n      parent = printStack[i];\n    } else {\n      return false;\n    }\n  }\n\n  return false;\n}\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _templateLiterals = require(\"./template-literals.js\");\nObject.keys(_templateLiterals).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _templateLiterals[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _templateLiterals[key];\n    }\n  });\n});\nvar _expressions = require(\"./expressions.js\");\nObject.keys(_expressions).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _expressions[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _expressions[key];\n    }\n  });\n});\nvar _statements = require(\"./statements.js\");\nObject.keys(_statements).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _statements[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _statements[key];\n    }\n  });\n});\nvar _classes = require(\"./classes.js\");\nObject.keys(_classes).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _classes[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _classes[key];\n    }\n  });\n});\nvar _methods = require(\"./methods.js\");\nObject.keys(_methods).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _methods[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _methods[key];\n    }\n  });\n});\nvar _modules = require(\"./modules.js\");\nObject.keys(_modules).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _modules[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _modules[key];\n    }\n  });\n});\nvar _types = require(\"./types.js\");\nObject.keys(_types).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _types[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _types[key];\n    }\n  });\n});\nvar _flow = require(\"./flow.js\");\nObject.keys(_flow).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _flow[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _flow[key];\n    }\n  });\n});\nvar _base = require(\"./base.js\");\nObject.keys(_base).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _base[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _base[key];\n    }\n  });\n});\nvar _jsx = require(\"./jsx.js\");\nObject.keys(_jsx).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _jsx[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _jsx[key];\n    }\n  });\n});\nvar _typescript = require(\"./typescript.js\");\nObject.keys(_typescript).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _typescript[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _typescript[key];\n    }\n  });\n});\n\n//# sourceMappingURL=index.js.map\n","export * from \"./template-literals.ts\";\nexport * from \"./expressions.ts\";\nexport * from \"./statements.ts\";\nexport * from \"./classes.ts\";\nexport * from \"./methods.ts\";\nexport * from \"./modules.ts\";\nexport * from \"./types.ts\";\nexport * from \"./flow.ts\";\nexport * from \"./base.ts\";\nexport * from \"./jsx.ts\";\nexport * from \"./typescript.ts\";\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TaggedTemplateExpression = TaggedTemplateExpression;\nexports.TemplateElement = TemplateElement;\nexports.TemplateLiteral = TemplateLiteral;\nfunction TaggedTemplateExpression(node) {\n  this.print(node.tag, node);\n  this.print(node.typeParameters, node);\n  this.print(node.quasi, node);\n}\nfunction TemplateElement(node, parent) {\n  const isFirst = parent.quasis[0] === node;\n  const isLast = parent.quasis[parent.quasis.length - 1] === node;\n  const value = (isFirst ? \"`\" : \"}\") + node.value.raw + (isLast ? \"`\" : \"${\");\n  this.token(value, true);\n}\nfunction TemplateLiteral(node) {\n  const quasis = node.quasis;\n  for (let i = 0; i < quasis.length; i++) {\n    this.print(quasis[i], node);\n    if (i + 1 < quasis.length) {\n      this.print(node.expressions[i], node);\n    }\n  }\n}\n\n//# sourceMappingURL=template-literals.js.map\n","import type Printer from \"../printer.ts\";\nimport type * as t from \"@babel/types\";\n\nexport function TaggedTemplateExpression(\n  this: Printer,\n  node: t.TaggedTemplateExpression,\n) {\n  this.print(node.tag, node);\n  this.print(node.typeParameters, node); // TS\n  this.print(node.quasi, node);\n}\n\nexport function TemplateElement(\n  this: Printer,\n  node: t.TemplateElement,\n  parent: t.TemplateLiteral,\n) {\n  const isFirst = parent.quasis[0] === node;\n  const isLast = parent.quasis[parent.quasis.length - 1] === node;\n\n  const value = (isFirst ? \"`\" : \"}\") + node.value.raw + (isLast ? \"`\" : \"${\");\n\n  this.token(value, true);\n}\n\nexport function TemplateLiteral(this: Printer, node: t.TemplateLiteral) {\n  const quasis = node.quasis;\n\n  for (let i = 0; i < quasis.length; i++) {\n    this.print(quasis[i], node);\n\n    if (i + 1 < quasis.length) {\n      this.print(node.expressions[i], node);\n    }\n  }\n}\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LogicalExpression = exports.BinaryExpression = exports.AssignmentExpression = AssignmentExpression;\nexports.AssignmentPattern = AssignmentPattern;\nexports.AwaitExpression = AwaitExpression;\nexports.BindExpression = BindExpression;\nexports.CallExpression = CallExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.Decorator = Decorator;\nexports.DoExpression = DoExpression;\nexports.EmptyStatement = EmptyStatement;\nexports.ExpressionStatement = ExpressionStatement;\nexports.Import = Import;\nexports.MemberExpression = MemberExpression;\nexports.MetaProperty = MetaProperty;\nexports.ModuleExpression = ModuleExpression;\nexports.NewExpression = NewExpression;\nexports.OptionalCallExpression = OptionalCallExpression;\nexports.OptionalMemberExpression = OptionalMemberExpression;\nexports.ParenthesizedExpression = ParenthesizedExpression;\nexports.PrivateName = PrivateName;\nexports.SequenceExpression = SequenceExpression;\nexports.Super = Super;\nexports.ThisExpression = ThisExpression;\nexports.UnaryExpression = UnaryExpression;\nexports.UpdateExpression = UpdateExpression;\nexports.V8IntrinsicIdentifier = V8IntrinsicIdentifier;\nexports.YieldExpression = YieldExpression;\nexports._shouldPrintDecoratorsBeforeExport = _shouldPrintDecoratorsBeforeExport;\nvar _t = require(\"@babel/types\");\nvar n = require(\"../node/index.js\");\nconst {\n  isCallExpression,\n  isLiteral,\n  isMemberExpression,\n  isNewExpression\n} = _t;\nfunction UnaryExpression(node) {\n  const {\n    operator\n  } = node;\n  if (operator === \"void\" || operator === \"delete\" || operator === \"typeof\" || operator === \"throw\") {\n    this.word(operator);\n    this.space();\n  } else {\n    this.token(operator);\n  }\n  this.print(node.argument, node);\n}\nfunction DoExpression(node) {\n  if (node.async) {\n    this.word(\"async\", true);\n    this.space();\n  }\n  this.word(\"do\");\n  this.space();\n  this.print(node.body, node);\n}\nfunction ParenthesizedExpression(node) {\n  this.tokenChar(40);\n  this.print(node.expression, node);\n  this.rightParens(node);\n}\nfunction UpdateExpression(node) {\n  if (node.prefix) {\n    this.token(node.operator);\n    this.print(node.argument, node);\n  } else {\n    this.printTerminatorless(node.argument, node, true);\n    this.token(node.operator);\n  }\n}\nfunction ConditionalExpression(node) {\n  this.print(node.test, node);\n  this.space();\n  this.tokenChar(63);\n  this.space();\n  this.print(node.consequent, node);\n  this.space();\n  this.tokenChar(58);\n  this.space();\n  this.print(node.alternate, node);\n}\nfunction NewExpression(node, parent) {\n  this.word(\"new\");\n  this.space();\n  this.print(node.callee, node);\n  if (this.format.minified && node.arguments.length === 0 && !node.optional && !isCallExpression(parent, {\n    callee: node\n  }) && !isMemberExpression(parent) && !isNewExpression(parent)) {\n    return;\n  }\n  this.print(node.typeArguments, node);\n  this.print(node.typeParameters, node);\n  if (node.optional) {\n    this.token(\"?.\");\n  }\n  this.tokenChar(40);\n  this.printList(node.arguments, node);\n  this.rightParens(node);\n}\nfunction SequenceExpression(node) {\n  this.printList(node.expressions, node);\n}\nfunction ThisExpression() {\n  this.word(\"this\");\n}\nfunction Super() {\n  this.word(\"super\");\n}\nfunction isDecoratorMemberExpression(node) {\n  switch (node.type) {\n    case \"Identifier\":\n      return true;\n    case \"MemberExpression\":\n      return !node.computed && node.property.type === \"Identifier\" && isDecoratorMemberExpression(node.object);\n    default:\n      return false;\n  }\n}\nfunction shouldParenthesizeDecoratorExpression(node) {\n  if (node.type === \"ParenthesizedExpression\") {\n    return false;\n  }\n  return !isDecoratorMemberExpression(node.type === \"CallExpression\" ? node.callee : node);\n}\nfunction _shouldPrintDecoratorsBeforeExport(node) {\n  if (typeof this.format.decoratorsBeforeExport === \"boolean\") {\n    return this.format.decoratorsBeforeExport;\n  }\n  return typeof node.start === \"number\" && node.start === node.declaration.start;\n}\nfunction Decorator(node) {\n  this.tokenChar(64);\n  const {\n    expression\n  } = node;\n  if (shouldParenthesizeDecoratorExpression(expression)) {\n    this.tokenChar(40);\n    this.print(expression, node);\n    this.tokenChar(41);\n  } else {\n    this.print(expression, node);\n  }\n  this.newline();\n}\nfunction OptionalMemberExpression(node) {\n  let {\n    computed\n  } = node;\n  const {\n    optional,\n    property\n  } = node;\n  this.print(node.object, node);\n  if (!computed && isMemberExpression(property)) {\n    throw new TypeError(\"Got a MemberExpression for MemberExpression property\");\n  }\n  if (isLiteral(property) && typeof property.value === \"number\") {\n    computed = true;\n  }\n  if (optional) {\n    this.token(\"?.\");\n  }\n  if (computed) {\n    this.tokenChar(91);\n    this.print(property, node);\n    this.tokenChar(93);\n  } else {\n    if (!optional) {\n      this.tokenChar(46);\n    }\n    this.print(property, node);\n  }\n}\nfunction OptionalCallExpression(node) {\n  this.print(node.callee, node);\n  this.print(node.typeParameters, node);\n  if (node.optional) {\n    this.token(\"?.\");\n  }\n  this.print(node.typeArguments, node);\n  this.tokenChar(40);\n  this.printList(node.arguments, node);\n  this.rightParens(node);\n}\nfunction CallExpression(node) {\n  this.print(node.callee, node);\n  this.print(node.typeArguments, node);\n  this.print(node.typeParameters, node);\n  this.tokenChar(40);\n  this.printList(node.arguments, node);\n  this.rightParens(node);\n}\nfunction Import() {\n  this.word(\"import\");\n}\nfunction AwaitExpression(node) {\n  this.word(\"await\");\n  if (node.argument) {\n    this.space();\n    this.printTerminatorless(node.argument, node, false);\n  }\n}\nfunction YieldExpression(node) {\n  this.word(\"yield\", true);\n  if (node.delegate) {\n    this.tokenChar(42);\n    if (node.argument) {\n      this.space();\n      this.print(node.argument, node);\n    }\n  } else {\n    if (node.argument) {\n      this.space();\n      this.printTerminatorless(node.argument, node, false);\n    }\n  }\n}\nfunction EmptyStatement() {\n  this.semicolon(true);\n}\nfunction ExpressionStatement(node) {\n  this.print(node.expression, node);\n  this.semicolon();\n}\nfunction AssignmentPattern(node) {\n  this.print(node.left, node);\n  if (node.left.optional) this.tokenChar(63);\n  this.print(node.left.typeAnnotation, node);\n  this.space();\n  this.tokenChar(61);\n  this.space();\n  this.print(node.right, node);\n}\nfunction AssignmentExpression(node, parent) {\n  const parens = this.inForStatementInitCounter && node.operator === \"in\" && !n.needsParens(node, parent);\n  if (parens) {\n    this.tokenChar(40);\n  }\n  this.print(node.left, node);\n  this.space();\n  if (node.operator === \"in\" || node.operator === \"instanceof\") {\n    this.word(node.operator);\n  } else {\n    this.token(node.operator);\n  }\n  this.space();\n  this.print(node.right, node);\n  if (parens) {\n    this.tokenChar(41);\n  }\n}\nfunction BindExpression(node) {\n  this.print(node.object, node);\n  this.token(\"::\");\n  this.print(node.callee, node);\n}\nfunction MemberExpression(node) {\n  this.print(node.object, node);\n  if (!node.computed && isMemberExpression(node.property)) {\n    throw new TypeError(\"Got a MemberExpression for MemberExpression property\");\n  }\n  let computed = node.computed;\n  if (isLiteral(node.property) && typeof node.property.value === \"number\") {\n    computed = true;\n  }\n  if (computed) {\n    this.tokenChar(91);\n    this.print(node.property, node);\n    this.tokenChar(93);\n  } else {\n    this.tokenChar(46);\n    this.print(node.property, node);\n  }\n}\nfunction MetaProperty(node) {\n  this.print(node.meta, node);\n  this.tokenChar(46);\n  this.print(node.property, node);\n}\nfunction PrivateName(node) {\n  this.tokenChar(35);\n  this.print(node.id, node);\n}\nfunction V8IntrinsicIdentifier(node) {\n  this.tokenChar(37);\n  this.word(node.name);\n}\nfunction ModuleExpression(node) {\n  this.word(\"module\", true);\n  this.space();\n  this.tokenChar(123);\n  this.indent();\n  const {\n    body\n  } = node;\n  if (body.body.length || body.directives.length) {\n    this.newline();\n  }\n  this.print(body, node);\n  this.dedent();\n  this.rightBrace(node);\n}\n\n//# sourceMappingURL=expressions.js.map\n","import type Printer from \"../printer.ts\";\nimport {\n  isCallExpression,\n  isLiteral,\n  isMemberExpression,\n  isNewExpression,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport * as n from \"../node/index.ts\";\n\nexport function UnaryExpression(this: Printer, node: t.UnaryExpression) {\n  const { operator } = node;\n  if (\n    operator === \"void\" ||\n    operator === \"delete\" ||\n    operator === \"typeof\" ||\n    // throwExpressions\n    operator === \"throw\"\n  ) {\n    this.word(operator);\n    this.space();\n  } else {\n    this.token(operator);\n  }\n\n  this.print(node.argument, node);\n}\n\nexport function DoExpression(this: Printer, node: t.DoExpression) {\n  if (node.async) {\n    this.word(\"async\", true);\n    this.space();\n  }\n  this.word(\"do\");\n  this.space();\n  this.print(node.body, node);\n}\n\nexport function ParenthesizedExpression(\n  this: Printer,\n  node: t.ParenthesizedExpression,\n) {\n  this.token(\"(\");\n  this.print(node.expression, node);\n  this.rightParens(node);\n}\n\nexport function UpdateExpression(this: Printer, node: t.UpdateExpression) {\n  if (node.prefix) {\n    this.token(node.operator);\n    this.print(node.argument, node);\n  } else {\n    this.printTerminatorless(node.argument, node, true);\n    this.token(node.operator);\n  }\n}\n\nexport function ConditionalExpression(\n  this: Printer,\n  node: t.ConditionalExpression,\n) {\n  this.print(node.test, node);\n  this.space();\n  this.token(\"?\");\n  this.space();\n  this.print(node.consequent, node);\n  this.space();\n  this.token(\":\");\n  this.space();\n  this.print(node.alternate, node);\n}\n\nexport function NewExpression(\n  this: Printer,\n  node: t.NewExpression,\n  parent: t.Node,\n) {\n  this.word(\"new\");\n  this.space();\n  this.print(node.callee, node);\n  if (\n    this.format.minified &&\n    node.arguments.length === 0 &&\n    !node.optional &&\n    !isCallExpression(parent, { callee: node }) &&\n    !isMemberExpression(parent) &&\n    !isNewExpression(parent)\n  ) {\n    return;\n  }\n\n  this.print(node.typeArguments, node); // Flow\n  this.print(node.typeParameters, node); // TS\n\n  if (node.optional) {\n    // TODO: This can never happen\n    this.token(\"?.\");\n  }\n  this.token(\"(\");\n  this.printList(node.arguments, node);\n  this.rightParens(node);\n}\n\nexport function SequenceExpression(this: Printer, node: t.SequenceExpression) {\n  this.printList(node.expressions, node);\n}\n\nexport function ThisExpression(this: Printer) {\n  this.word(\"this\");\n}\n\nexport function Super(this: Printer) {\n  this.word(\"super\");\n}\n\nfunction isDecoratorMemberExpression(\n  node: t.Expression | t.Super | t.V8IntrinsicIdentifier,\n): boolean {\n  switch (node.type) {\n    case \"Identifier\":\n      return true;\n    case \"MemberExpression\":\n      return (\n        !node.computed &&\n        node.property.type === \"Identifier\" &&\n        isDecoratorMemberExpression(node.object)\n      );\n    default:\n      return false;\n  }\n}\nfunction shouldParenthesizeDecoratorExpression(\n  node: t.Expression | t.Super | t.V8IntrinsicIdentifier,\n) {\n  if (node.type === \"ParenthesizedExpression\") {\n    // We didn't check extra?.parenthesized here because we don't track decorators in needsParen\n    return false;\n  }\n  return !isDecoratorMemberExpression(\n    node.type === \"CallExpression\" ? node.callee : node,\n  );\n}\n\nexport function _shouldPrintDecoratorsBeforeExport(\n  this: Printer,\n  node: t.ExportDeclaration & { declaration: t.ClassDeclaration },\n) {\n  if (typeof this.format.decoratorsBeforeExport === \"boolean\") {\n    return this.format.decoratorsBeforeExport;\n  }\n  return (\n    typeof node.start === \"number\" && node.start === node.declaration.start\n  );\n}\n\nexport function Decorator(this: Printer, node: t.Decorator) {\n  this.token(\"@\");\n  const { expression } = node;\n  if (shouldParenthesizeDecoratorExpression(expression)) {\n    this.token(\"(\");\n    this.print(expression, node);\n    this.token(\")\");\n  } else {\n    this.print(expression, node);\n  }\n  this.newline();\n}\n\nexport function OptionalMemberExpression(\n  this: Printer,\n  node: t.OptionalMemberExpression,\n) {\n  let { computed } = node;\n  const { optional, property } = node;\n\n  this.print(node.object, node);\n\n  if (!computed && isMemberExpression(property)) {\n    throw new TypeError(\"Got a MemberExpression for MemberExpression property\");\n  }\n\n  // @ts-expect-error todo(flow->ts) maybe instead of typeof check specific literal types?\n  if (isLiteral(property) && typeof property.value === \"number\") {\n    computed = true;\n  }\n  if (optional) {\n    this.token(\"?.\");\n  }\n\n  if (computed) {\n    this.token(\"[\");\n    this.print(property, node);\n    this.token(\"]\");\n  } else {\n    if (!optional) {\n      this.token(\".\");\n    }\n    this.print(property, node);\n  }\n}\n\nexport function OptionalCallExpression(\n  this: Printer,\n  node: t.OptionalCallExpression,\n) {\n  this.print(node.callee, node);\n\n  this.print(node.typeParameters, node); // TS\n\n  if (node.optional) {\n    this.token(\"?.\");\n  }\n\n  this.print(node.typeArguments, node); // Flow\n\n  this.token(\"(\");\n  this.printList(node.arguments, node);\n  this.rightParens(node);\n}\n\nexport function CallExpression(this: Printer, node: t.CallExpression) {\n  this.print(node.callee, node);\n\n  this.print(node.typeArguments, node); // Flow\n  this.print(node.typeParameters, node); // TS\n  this.token(\"(\");\n  this.printList(node.arguments, node);\n  this.rightParens(node);\n}\n\nexport function Import(this: Printer) {\n  this.word(\"import\");\n}\n\nexport function AwaitExpression(this: Printer, node: t.AwaitExpression) {\n  this.word(\"await\");\n\n  if (node.argument) {\n    this.space();\n    this.printTerminatorless(node.argument, node, false);\n  }\n}\n\nexport function YieldExpression(this: Printer, node: t.YieldExpression) {\n  this.word(\"yield\", true);\n\n  if (node.delegate) {\n    this.token(\"*\");\n    if (node.argument) {\n      this.space();\n      // line terminators are allowed after yield*\n      this.print(node.argument, node);\n    }\n  } else {\n    if (node.argument) {\n      this.space();\n      this.printTerminatorless(node.argument, node, false);\n    }\n  }\n}\n\nexport function EmptyStatement(this: Printer) {\n  this.semicolon(true /* force */);\n}\n\nexport function ExpressionStatement(\n  this: Printer,\n  node: t.ExpressionStatement,\n) {\n  this.print(node.expression, node);\n  this.semicolon();\n}\n\nexport function AssignmentPattern(this: Printer, node: t.AssignmentPattern) {\n  this.print(node.left, node);\n  // @ts-expect-error todo(flow->ts) property present on some of the types in union but not all\n  if (node.left.optional) this.token(\"?\");\n  // @ts-expect-error todo(flow->ts) property present on some of the types in union but not all\n  this.print(node.left.typeAnnotation, node);\n  this.space();\n  this.token(\"=\");\n  this.space();\n  this.print(node.right, node);\n}\n\nexport function AssignmentExpression(\n  this: Printer,\n  node: t.AssignmentExpression,\n  parent: t.Node,\n) {\n  // Somewhere inside a for statement `init` node but doesn't usually\n  // needs a paren except for `in` expressions: `for (a in b ? a : b;;)`\n  const parens =\n    this.inForStatementInitCounter &&\n    node.operator === \"in\" &&\n    !n.needsParens(node, parent);\n\n  if (parens) {\n    this.token(\"(\");\n  }\n\n  this.print(node.left, node);\n\n  this.space();\n  if (node.operator === \"in\" || node.operator === \"instanceof\") {\n    this.word(node.operator);\n  } else {\n    this.token(node.operator);\n  }\n  this.space();\n\n  this.print(node.right, node);\n\n  if (parens) {\n    this.token(\")\");\n  }\n}\n\nexport function BindExpression(this: Printer, node: t.BindExpression) {\n  this.print(node.object, node);\n  this.token(\"::\");\n  this.print(node.callee, node);\n}\n\nexport {\n  AssignmentExpression as BinaryExpression,\n  AssignmentExpression as LogicalExpression,\n};\n\nexport function MemberExpression(this: Printer, node: t.MemberExpression) {\n  this.print(node.object, node);\n\n  if (!node.computed && isMemberExpression(node.property)) {\n    throw new TypeError(\"Got a MemberExpression for MemberExpression property\");\n  }\n\n  let computed = node.computed;\n  // @ts-expect-error todo(flow->ts) maybe use specific literal types\n  if (isLiteral(node.property) && typeof node.property.value === \"number\") {\n    computed = true;\n  }\n\n  if (computed) {\n    this.token(\"[\");\n    this.print(node.property, node);\n    this.token(\"]\");\n  } else {\n    this.token(\".\");\n    this.print(node.property, node);\n  }\n}\n\nexport function MetaProperty(this: Printer, node: t.MetaProperty) {\n  this.print(node.meta, node);\n  this.token(\".\");\n  this.print(node.property, node);\n}\n\nexport function PrivateName(this: Printer, node: t.PrivateName) {\n  this.token(\"#\");\n  this.print(node.id, node);\n}\n\nexport function V8IntrinsicIdentifier(\n  this: Printer,\n  node: t.V8IntrinsicIdentifier,\n) {\n  this.token(\"%\");\n  this.word(node.name);\n}\n\nexport function ModuleExpression(this: Printer, node: t.ModuleExpression) {\n  this.word(\"module\", true);\n  this.space();\n  this.token(\"{\");\n  this.indent();\n  const { body } = node;\n  if (body.body.length || body.directives.length) {\n    this.newline();\n  }\n  this.print(body, node);\n  this.dedent();\n  this.rightBrace(node);\n}\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BreakStatement = BreakStatement;\nexports.CatchClause = CatchClause;\nexports.ContinueStatement = ContinueStatement;\nexports.DebuggerStatement = DebuggerStatement;\nexports.DoWhileStatement = DoWhileStatement;\nexports.ForOfStatement = exports.ForInStatement = void 0;\nexports.ForStatement = ForStatement;\nexports.IfStatement = IfStatement;\nexports.LabeledStatement = LabeledStatement;\nexports.ReturnStatement = ReturnStatement;\nexports.SwitchCase = SwitchCase;\nexports.SwitchStatement = SwitchStatement;\nexports.ThrowStatement = ThrowStatement;\nexports.TryStatement = TryStatement;\nexports.VariableDeclaration = VariableDeclaration;\nexports.VariableDeclarator = VariableDeclarator;\nexports.WhileStatement = WhileStatement;\nexports.WithStatement = WithStatement;\nvar _t = require(\"@babel/types\");\nconst {\n  isFor,\n  isForStatement,\n  isIfStatement,\n  isStatement\n} = _t;\nfunction WithStatement(node) {\n  this.word(\"with\");\n  this.space();\n  this.tokenChar(40);\n  this.print(node.object, node);\n  this.tokenChar(41);\n  this.printBlock(node);\n}\nfunction IfStatement(node) {\n  this.word(\"if\");\n  this.space();\n  this.tokenChar(40);\n  this.print(node.test, node);\n  this.tokenChar(41);\n  this.space();\n  const needsBlock = node.alternate && isIfStatement(getLastStatement(node.consequent));\n  if (needsBlock) {\n    this.tokenChar(123);\n    this.newline();\n    this.indent();\n  }\n  this.printAndIndentOnComments(node.consequent, node);\n  if (needsBlock) {\n    this.dedent();\n    this.newline();\n    this.tokenChar(125);\n  }\n  if (node.alternate) {\n    if (this.endsWith(125)) this.space();\n    this.word(\"else\");\n    this.space();\n    this.printAndIndentOnComments(node.alternate, node);\n  }\n}\nfunction getLastStatement(statement) {\n  const {\n    body\n  } = statement;\n  if (isStatement(body) === false) {\n    return statement;\n  }\n  return getLastStatement(body);\n}\nfunction ForStatement(node) {\n  this.word(\"for\");\n  this.space();\n  this.tokenChar(40);\n  this.inForStatementInitCounter++;\n  this.print(node.init, node);\n  this.inForStatementInitCounter--;\n  this.tokenChar(59);\n  if (node.test) {\n    this.space();\n    this.print(node.test, node);\n  }\n  this.tokenChar(59);\n  if (node.update) {\n    this.space();\n    this.print(node.update, node);\n  }\n  this.tokenChar(41);\n  this.printBlock(node);\n}\nfunction WhileStatement(node) {\n  this.word(\"while\");\n  this.space();\n  this.tokenChar(40);\n  this.print(node.test, node);\n  this.tokenChar(41);\n  this.printBlock(node);\n}\nfunction ForXStatement(node) {\n  this.word(\"for\");\n  this.space();\n  const isForOf = node.type === \"ForOfStatement\";\n  if (isForOf && node.await) {\n    this.word(\"await\");\n    this.space();\n  }\n  this.noIndentInnerCommentsHere();\n  this.tokenChar(40);\n  this.print(node.left, node);\n  this.space();\n  this.word(isForOf ? \"of\" : \"in\");\n  this.space();\n  this.print(node.right, node);\n  this.tokenChar(41);\n  this.printBlock(node);\n}\nconst ForInStatement = ForXStatement;\nexports.ForInStatement = ForInStatement;\nconst ForOfStatement = ForXStatement;\nexports.ForOfStatement = ForOfStatement;\nfunction DoWhileStatement(node) {\n  this.word(\"do\");\n  this.space();\n  this.print(node.body, node);\n  this.space();\n  this.word(\"while\");\n  this.space();\n  this.tokenChar(40);\n  this.print(node.test, node);\n  this.tokenChar(41);\n  this.semicolon();\n}\nfunction printStatementAfterKeyword(printer, node, parent, isLabel) {\n  if (node) {\n    printer.space();\n    printer.printTerminatorless(node, parent, isLabel);\n  }\n  printer.semicolon();\n}\nfunction BreakStatement(node) {\n  this.word(\"break\");\n  printStatementAfterKeyword(this, node.label, node, true);\n}\nfunction ContinueStatement(node) {\n  this.word(\"continue\");\n  printStatementAfterKeyword(this, node.label, node, true);\n}\nfunction ReturnStatement(node) {\n  this.word(\"return\");\n  printStatementAfterKeyword(this, node.argument, node, false);\n}\nfunction ThrowStatement(node) {\n  this.word(\"throw\");\n  printStatementAfterKeyword(this, node.argument, node, false);\n}\nfunction LabeledStatement(node) {\n  this.print(node.label, node);\n  this.tokenChar(58);\n  this.space();\n  this.print(node.body, node);\n}\nfunction TryStatement(node) {\n  this.word(\"try\");\n  this.space();\n  this.print(node.block, node);\n  this.space();\n  if (node.handlers) {\n    this.print(node.handlers[0], node);\n  } else {\n    this.print(node.handler, node);\n  }\n  if (node.finalizer) {\n    this.space();\n    this.word(\"finally\");\n    this.space();\n    this.print(node.finalizer, node);\n  }\n}\nfunction CatchClause(node) {\n  this.word(\"catch\");\n  this.space();\n  if (node.param) {\n    this.tokenChar(40);\n    this.print(node.param, node);\n    this.print(node.param.typeAnnotation, node);\n    this.tokenChar(41);\n    this.space();\n  }\n  this.print(node.body, node);\n}\nfunction SwitchStatement(node) {\n  this.word(\"switch\");\n  this.space();\n  this.tokenChar(40);\n  this.print(node.discriminant, node);\n  this.tokenChar(41);\n  this.space();\n  this.tokenChar(123);\n  this.printSequence(node.cases, node, {\n    indent: true,\n    addNewlines(leading, cas) {\n      if (!leading && node.cases[node.cases.length - 1] === cas) return -1;\n    }\n  });\n  this.rightBrace(node);\n}\nfunction SwitchCase(node) {\n  if (node.test) {\n    this.word(\"case\");\n    this.space();\n    this.print(node.test, node);\n    this.tokenChar(58);\n  } else {\n    this.word(\"default\");\n    this.tokenChar(58);\n  }\n  if (node.consequent.length) {\n    this.newline();\n    this.printSequence(node.consequent, node, {\n      indent: true\n    });\n  }\n}\nfunction DebuggerStatement() {\n  this.word(\"debugger\");\n  this.semicolon();\n}\nfunction VariableDeclaration(node, parent) {\n  if (node.declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n  const {\n    kind\n  } = node;\n  this.word(kind, kind === \"using\" || kind === \"await using\");\n  this.space();\n  let hasInits = false;\n  if (!isFor(parent)) {\n    for (const declar of node.declarations) {\n      if (declar.init) {\n        hasInits = true;\n      }\n    }\n  }\n  this.printList(node.declarations, node, {\n    separator: hasInits ? function () {\n      this.tokenChar(44);\n      this.newline();\n    } : undefined,\n    indent: node.declarations.length > 1 ? true : false\n  });\n  if (isFor(parent)) {\n    if (isForStatement(parent)) {\n      if (parent.init === node) return;\n    } else {\n      if (parent.left === node) return;\n    }\n  }\n  this.semicolon();\n}\nfunction VariableDeclarator(node) {\n  this.print(node.id, node);\n  if (node.definite) this.tokenChar(33);\n  this.print(node.id.typeAnnotation, node);\n  if (node.init) {\n    this.space();\n    this.tokenChar(61);\n    this.space();\n    this.print(node.init, node);\n  }\n}\n\n//# sourceMappingURL=statements.js.map\n","import type Printer from \"../printer.ts\";\nimport {\n  isFor,\n  isForStatement,\n  isIfStatement,\n  isStatement,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport * as charCodes from \"charcodes\";\n\nexport function WithStatement(this: Printer, node: t.WithStatement) {\n  this.word(\"with\");\n  this.space();\n  this.token(\"(\");\n  this.print(node.object, node);\n  this.token(\")\");\n  this.printBlock(node);\n}\n\nexport function IfStatement(this: Printer, node: t.IfStatement) {\n  this.word(\"if\");\n  this.space();\n  this.token(\"(\");\n  this.print(node.test, node);\n  this.token(\")\");\n  this.space();\n\n  const needsBlock =\n    node.alternate && isIfStatement(getLastStatement(node.consequent));\n  if (needsBlock) {\n    this.token(\"{\");\n    this.newline();\n    this.indent();\n  }\n\n  this.printAndIndentOnComments(node.consequent, node);\n\n  if (needsBlock) {\n    this.dedent();\n    this.newline();\n    this.token(\"}\");\n  }\n\n  if (node.alternate) {\n    if (this.endsWith(charCodes.rightCurlyBrace)) this.space();\n    this.word(\"else\");\n    this.space();\n    this.printAndIndentOnComments(node.alternate, node);\n  }\n}\n\n// Recursively get the last statement.\nfunction getLastStatement(statement: t.Statement): t.Statement {\n  // @ts-expect-error: If statement.body is empty or not a Node, isStatement will return false\n  const { body } = statement;\n  if (isStatement(body) === false) {\n    return statement;\n  }\n\n  return getLastStatement(body);\n}\n\nexport function ForStatement(this: Printer, node: t.ForStatement) {\n  this.word(\"for\");\n  this.space();\n  this.token(\"(\");\n\n  this.inForStatementInitCounter++;\n  this.print(node.init, node);\n  this.inForStatementInitCounter--;\n  this.token(\";\");\n\n  if (node.test) {\n    this.space();\n    this.print(node.test, node);\n  }\n  this.token(\";\");\n\n  if (node.update) {\n    this.space();\n    this.print(node.update, node);\n  }\n\n  this.token(\")\");\n  this.printBlock(node);\n}\n\nexport function WhileStatement(this: Printer, node: t.WhileStatement) {\n  this.word(\"while\");\n  this.space();\n  this.token(\"(\");\n  this.print(node.test, node);\n  this.token(\")\");\n  this.printBlock(node);\n}\n\nfunction ForXStatement(this: Printer, node: t.ForXStatement) {\n  this.word(\"for\");\n  this.space();\n  const isForOf = node.type === \"ForOfStatement\";\n  if (isForOf && node.await) {\n    this.word(\"await\");\n    this.space();\n  }\n  this.noIndentInnerCommentsHere();\n  this.token(\"(\");\n  this.print(node.left, node);\n  this.space();\n  this.word(isForOf ? \"of\" : \"in\");\n  this.space();\n  this.print(node.right, node);\n  this.token(\")\");\n  this.printBlock(node);\n}\n\nexport const ForInStatement = ForXStatement;\nexport const ForOfStatement = ForXStatement;\n\nexport function DoWhileStatement(this: Printer, node: t.DoWhileStatement) {\n  this.word(\"do\");\n  this.space();\n  this.print(node.body, node);\n  this.space();\n  this.word(\"while\");\n  this.space();\n  this.token(\"(\");\n  this.print(node.test, node);\n  this.token(\")\");\n  this.semicolon();\n}\n\nfunction printStatementAfterKeyword(\n  printer: Printer,\n  node: t.Node,\n  parent: t.Node,\n  isLabel: boolean,\n) {\n  if (node) {\n    printer.space();\n    printer.printTerminatorless(node, parent, isLabel);\n  }\n\n  printer.semicolon();\n}\n\nexport function BreakStatement(this: Printer, node: t.ContinueStatement) {\n  this.word(\"break\");\n  printStatementAfterKeyword(this, node.label, node, true);\n}\n\nexport function ContinueStatement(this: Printer, node: t.ContinueStatement) {\n  this.word(\"continue\");\n  printStatementAfterKeyword(this, node.label, node, true);\n}\n\nexport function ReturnStatement(this: Printer, node: t.ReturnStatement) {\n  this.word(\"return\");\n  printStatementAfterKeyword(this, node.argument, node, false);\n}\n\nexport function ThrowStatement(this: Printer, node: t.ThrowStatement) {\n  this.word(\"throw\");\n  printStatementAfterKeyword(this, node.argument, node, false);\n}\n\nexport function LabeledStatement(this: Printer, node: t.LabeledStatement) {\n  this.print(node.label, node);\n  this.token(\":\");\n  this.space();\n  this.print(node.body, node);\n}\n\nexport function TryStatement(this: Printer, node: t.TryStatement) {\n  this.word(\"try\");\n  this.space();\n  this.print(node.block, node);\n  this.space();\n\n  // Esprima bug puts the catch clause in a `handlers` array.\n  // see https://code.google.com/p/esprima/issues/detail?id=433\n  // We run into this from regenerator generated ast.\n  // @ts-expect-error todo(flow->ts) should ast node type be updated to support this?\n  if (node.handlers) {\n    // @ts-expect-error todo(flow->ts) should ast node type be updated to support this?\n    this.print(node.handlers[0], node);\n  } else {\n    this.print(node.handler, node);\n  }\n\n  if (node.finalizer) {\n    this.space();\n    this.word(\"finally\");\n    this.space();\n    this.print(node.finalizer, node);\n  }\n}\n\nexport function CatchClause(this: Printer, node: t.CatchClause) {\n  this.word(\"catch\");\n  this.space();\n  if (node.param) {\n    this.token(\"(\");\n    this.print(node.param, node);\n    this.print(node.param.typeAnnotation, node);\n    this.token(\")\");\n    this.space();\n  }\n  this.print(node.body, node);\n}\n\nexport function SwitchStatement(this: Printer, node: t.SwitchStatement) {\n  this.word(\"switch\");\n  this.space();\n  this.token(\"(\");\n  this.print(node.discriminant, node);\n  this.token(\")\");\n  this.space();\n  this.token(\"{\");\n\n  this.printSequence(node.cases, node, {\n    indent: true,\n    addNewlines(leading, cas) {\n      if (!leading && node.cases[node.cases.length - 1] === cas) return -1;\n    },\n  });\n\n  this.rightBrace(node);\n}\n\nexport function SwitchCase(this: Printer, node: t.SwitchCase) {\n  if (node.test) {\n    this.word(\"case\");\n    this.space();\n    this.print(node.test, node);\n    this.token(\":\");\n  } else {\n    this.word(\"default\");\n    this.token(\":\");\n  }\n\n  if (node.consequent.length) {\n    this.newline();\n    this.printSequence(node.consequent, node, { indent: true });\n  }\n}\n\nexport function DebuggerStatement(this: Printer) {\n  this.word(\"debugger\");\n  this.semicolon();\n}\n\nexport function VariableDeclaration(\n  this: Printer,\n  node: t.VariableDeclaration,\n  parent: t.Node,\n) {\n  if (node.declare) {\n    // TS\n    this.word(\"declare\");\n    this.space();\n  }\n\n  const { kind } = node;\n  this.word(kind, kind === \"using\" || kind === \"await using\");\n  this.space();\n\n  let hasInits = false;\n  // don't add whitespace to loop heads\n  if (!isFor(parent)) {\n    for (const declar of node.declarations) {\n      if (declar.init) {\n        // has an init so let's split it up over multiple lines\n        hasInits = true;\n      }\n    }\n  }\n\n  //\n  // use a pretty separator when we aren't in compact mode, have initializers and don't have retainLines on\n  // this will format declarations like:\n  //\n  //   let foo = \"bar\", bar = \"foo\";\n  //\n  // into\n  //\n  //   let foo = \"bar\",\n  //       bar = \"foo\";\n  //\n\n  this.printList(node.declarations, node, {\n    separator: hasInits\n      ? function (this: Printer) {\n          this.token(\",\");\n          this.newline();\n        }\n      : undefined,\n    indent: node.declarations.length > 1 ? true : false,\n  });\n\n  if (isFor(parent)) {\n    // don't give semicolons to these nodes since they'll be inserted in the parent generator\n    if (isForStatement(parent)) {\n      if (parent.init === node) return;\n    } else {\n      if (parent.left === node) return;\n    }\n  }\n\n  this.semicolon();\n}\n\nexport function VariableDeclarator(this: Printer, node: t.VariableDeclarator) {\n  this.print(node.id, node);\n  if (node.definite) this.token(\"!\"); // TS\n  // @ts-expect-error todo(flow-ts) Property 'typeAnnotation' does not exist on type 'MemberExpression'.\n  this.print(node.id.typeAnnotation, node);\n  if (node.init) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(node.init, node);\n  }\n}\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ClassAccessorProperty = ClassAccessorProperty;\nexports.ClassBody = ClassBody;\nexports.ClassExpression = exports.ClassDeclaration = ClassDeclaration;\nexports.ClassMethod = ClassMethod;\nexports.ClassPrivateMethod = ClassPrivateMethod;\nexports.ClassPrivateProperty = ClassPrivateProperty;\nexports.ClassProperty = ClassProperty;\nexports.StaticBlock = StaticBlock;\nexports._classMethodHead = _classMethodHead;\nvar _t = require(\"@babel/types\");\nconst {\n  isExportDefaultDeclaration,\n  isExportNamedDeclaration\n} = _t;\nfunction ClassDeclaration(node, parent) {\n  const inExport = isExportDefaultDeclaration(parent) || isExportNamedDeclaration(parent);\n  if (!inExport || !this._shouldPrintDecoratorsBeforeExport(parent)) {\n    this.printJoin(node.decorators, node);\n  }\n  if (node.declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n  if (node.abstract) {\n    this.word(\"abstract\");\n    this.space();\n  }\n  this.word(\"class\");\n  if (node.id) {\n    this.space();\n    this.print(node.id, node);\n  }\n  this.print(node.typeParameters, node);\n  if (node.superClass) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.print(node.superClass, node);\n    this.print(node.superTypeParameters, node);\n  }\n  if (node.implements) {\n    this.space();\n    this.word(\"implements\");\n    this.space();\n    this.printList(node.implements, node);\n  }\n  this.space();\n  this.print(node.body, node);\n}\nfunction ClassBody(node) {\n  this.tokenChar(123);\n  if (node.body.length === 0) {\n    this.tokenChar(125);\n  } else {\n    this.newline();\n    this.printSequence(node.body, node, {\n      indent: true\n    });\n    if (!this.endsWith(10)) this.newline();\n    this.rightBrace(node);\n  }\n}\nfunction ClassProperty(node) {\n  var _node$key$loc;\n  this.printJoin(node.decorators, node);\n  const endLine = (_node$key$loc = node.key.loc) == null || (_node$key$loc = _node$key$loc.end) == null ? void 0 : _node$key$loc.line;\n  if (endLine) this.catchUp(endLine);\n  this.tsPrintClassMemberModifiers(node);\n  if (node.computed) {\n    this.tokenChar(91);\n    this.print(node.key, node);\n    this.tokenChar(93);\n  } else {\n    this._variance(node);\n    this.print(node.key, node);\n  }\n  if (node.optional) {\n    this.tokenChar(63);\n  }\n  if (node.definite) {\n    this.tokenChar(33);\n  }\n  this.print(node.typeAnnotation, node);\n  if (node.value) {\n    this.space();\n    this.tokenChar(61);\n    this.space();\n    this.print(node.value, node);\n  }\n  this.semicolon();\n}\nfunction ClassAccessorProperty(node) {\n  var _node$key$loc2;\n  this.printJoin(node.decorators, node);\n  const endLine = (_node$key$loc2 = node.key.loc) == null || (_node$key$loc2 = _node$key$loc2.end) == null ? void 0 : _node$key$loc2.line;\n  if (endLine) this.catchUp(endLine);\n  this.tsPrintClassMemberModifiers(node);\n  this.word(\"accessor\", true);\n  this.space();\n  if (node.computed) {\n    this.tokenChar(91);\n    this.print(node.key, node);\n    this.tokenChar(93);\n  } else {\n    this._variance(node);\n    this.print(node.key, node);\n  }\n  if (node.optional) {\n    this.tokenChar(63);\n  }\n  if (node.definite) {\n    this.tokenChar(33);\n  }\n  this.print(node.typeAnnotation, node);\n  if (node.value) {\n    this.space();\n    this.tokenChar(61);\n    this.space();\n    this.print(node.value, node);\n  }\n  this.semicolon();\n}\nfunction ClassPrivateProperty(node) {\n  this.printJoin(node.decorators, node);\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  this.print(node.key, node);\n  this.print(node.typeAnnotation, node);\n  if (node.value) {\n    this.space();\n    this.tokenChar(61);\n    this.space();\n    this.print(node.value, node);\n  }\n  this.semicolon();\n}\nfunction ClassMethod(node) {\n  this._classMethodHead(node);\n  this.space();\n  this.print(node.body, node);\n}\nfunction ClassPrivateMethod(node) {\n  this._classMethodHead(node);\n  this.space();\n  this.print(node.body, node);\n}\nfunction _classMethodHead(node) {\n  var _node$key$loc3;\n  this.printJoin(node.decorators, node);\n  const endLine = (_node$key$loc3 = node.key.loc) == null || (_node$key$loc3 = _node$key$loc3.end) == null ? void 0 : _node$key$loc3.line;\n  if (endLine) this.catchUp(endLine);\n  this.tsPrintClassMemberModifiers(node);\n  this._methodHead(node);\n}\nfunction StaticBlock(node) {\n  this.word(\"static\");\n  this.space();\n  this.tokenChar(123);\n  if (node.body.length === 0) {\n    this.tokenChar(125);\n  } else {\n    this.newline();\n    this.printSequence(node.body, node, {\n      indent: true\n    });\n    this.rightBrace(node);\n  }\n}\n\n//# sourceMappingURL=classes.js.map\n","import type Printer from \"../printer.ts\";\nimport {\n  isExportDefaultDeclaration,\n  isExportNamedDeclaration,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport * as charCodes from \"charcodes\";\n\nexport function ClassDeclaration(\n  this: Printer,\n  node: t.ClassDeclaration,\n  parent: t.Node,\n) {\n  const inExport =\n    isExportDefaultDeclaration(parent) || isExportNamedDeclaration(parent);\n\n  if (\n    !inExport ||\n    !this._shouldPrintDecoratorsBeforeExport(\n      parent as t.ExportDeclaration & { declaration: t.ClassDeclaration },\n    )\n  ) {\n    this.printJoin(node.decorators, node);\n  }\n\n  if (node.declare) {\n    // TS\n    this.word(\"declare\");\n    this.space();\n  }\n\n  if (node.abstract) {\n    // TS\n    this.word(\"abstract\");\n    this.space();\n  }\n\n  this.word(\"class\");\n\n  if (node.id) {\n    this.space();\n    this.print(node.id, node);\n  }\n\n  this.print(node.typeParameters, node);\n\n  if (node.superClass) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.print(node.superClass, node);\n    this.print(node.superTypeParameters, node);\n  }\n\n  if (node.implements) {\n    this.space();\n    this.word(\"implements\");\n    this.space();\n    this.printList(node.implements, node);\n  }\n\n  this.space();\n  this.print(node.body, node);\n}\n\nexport { ClassDeclaration as ClassExpression };\n\nexport function ClassBody(this: Printer, node: t.ClassBody) {\n  this.token(\"{\");\n  if (node.body.length === 0) {\n    this.token(\"}\");\n  } else {\n    this.newline();\n\n    this.printSequence(node.body, node, { indent: true });\n\n    if (!this.endsWith(charCodes.lineFeed)) this.newline();\n\n    this.rightBrace(node);\n  }\n}\n\nexport function ClassProperty(this: Printer, node: t.ClassProperty) {\n  this.printJoin(node.decorators, node);\n\n  // catch up to property key, avoid line break\n  // between member modifiers and the property key.\n  const endLine = node.key.loc?.end?.line;\n  if (endLine) this.catchUp(endLine);\n\n  this.tsPrintClassMemberModifiers(node);\n\n  if (node.computed) {\n    this.token(\"[\");\n    this.print(node.key, node);\n    this.token(\"]\");\n  } else {\n    this._variance(node);\n    this.print(node.key, node);\n  }\n\n  // TS\n  if (node.optional) {\n    this.token(\"?\");\n  }\n  if (node.definite) {\n    this.token(\"!\");\n  }\n\n  this.print(node.typeAnnotation, node);\n  if (node.value) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(node.value, node);\n  }\n  this.semicolon();\n}\n\nexport function ClassAccessorProperty(\n  this: Printer,\n  node: t.ClassAccessorProperty,\n) {\n  this.printJoin(node.decorators, node);\n\n  // catch up to property key, avoid line break\n  // between member modifiers and the property key.\n  const endLine = node.key.loc?.end?.line;\n  if (endLine) this.catchUp(endLine);\n\n  // TS does not support class accessor property yet\n  this.tsPrintClassMemberModifiers(node);\n\n  this.word(\"accessor\", true);\n  this.space();\n\n  if (node.computed) {\n    this.token(\"[\");\n    this.print(node.key, node);\n    this.token(\"]\");\n  } else {\n    // Todo: Flow does not support class accessor property yet.\n    this._variance(node);\n    this.print(node.key, node);\n  }\n\n  // TS\n  if (node.optional) {\n    this.token(\"?\");\n  }\n  if (node.definite) {\n    this.token(\"!\");\n  }\n\n  this.print(node.typeAnnotation, node);\n  if (node.value) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(node.value, node);\n  }\n  this.semicolon();\n}\n\nexport function ClassPrivateProperty(\n  this: Printer,\n  node: t.ClassPrivateProperty,\n) {\n  this.printJoin(node.decorators, node);\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  this.print(node.key, node);\n  this.print(node.typeAnnotation, node);\n  if (node.value) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(node.value, node);\n  }\n  this.semicolon();\n}\n\nexport function ClassMethod(this: Printer, node: t.ClassMethod) {\n  this._classMethodHead(node);\n  this.space();\n  this.print(node.body, node);\n}\n\nexport function ClassPrivateMethod(this: Printer, node: t.ClassPrivateMethod) {\n  this._classMethodHead(node);\n  this.space();\n  this.print(node.body, node);\n}\n\nexport function _classMethodHead(\n  this: Printer,\n  node: t.ClassMethod | t.ClassPrivateMethod | t.TSDeclareMethod,\n) {\n  this.printJoin(node.decorators, node);\n\n  // catch up to method key, avoid line break\n  // between member modifiers/method heads and the method key.\n  const endLine = node.key.loc?.end?.line;\n  if (endLine) this.catchUp(endLine);\n\n  this.tsPrintClassMemberModifiers(node);\n  this._methodHead(node);\n}\n\nexport function StaticBlock(this: Printer, node: t.StaticBlock) {\n  this.word(\"static\");\n  this.space();\n  this.token(\"{\");\n  if (node.body.length === 0) {\n    this.token(\"}\");\n  } else {\n    this.newline();\n    this.printSequence(node.body, node, {\n      indent: true,\n    });\n    this.rightBrace(node);\n  }\n}\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ArrowFunctionExpression = ArrowFunctionExpression;\nexports.FunctionDeclaration = exports.FunctionExpression = FunctionExpression;\nexports._functionHead = _functionHead;\nexports._methodHead = _methodHead;\nexports._param = _param;\nexports._parameters = _parameters;\nexports._params = _params;\nexports._predicate = _predicate;\nvar _t = require(\"@babel/types\");\nconst {\n  isIdentifier\n} = _t;\nfunction _params(node, idNode, parentNode) {\n  this.print(node.typeParameters, node);\n  const nameInfo = _getFuncIdName.call(this, idNode, parentNode);\n  if (nameInfo) {\n    this.sourceIdentifierName(nameInfo.name, nameInfo.pos);\n  }\n  this.tokenChar(40);\n  this._parameters(node.params, node);\n  this.tokenChar(41);\n  const noLineTerminator = node.type === \"ArrowFunctionExpression\";\n  this.print(node.returnType, node, noLineTerminator);\n  this._noLineTerminator = noLineTerminator;\n}\nfunction _parameters(parameters, parent) {\n  const paramLength = parameters.length;\n  for (let i = 0; i < paramLength; i++) {\n    this._param(parameters[i], parent);\n    if (i < parameters.length - 1) {\n      this.tokenChar(44);\n      this.space();\n    }\n  }\n}\nfunction _param(parameter, parent) {\n  this.printJoin(parameter.decorators, parameter);\n  this.print(parameter, parent);\n  if (parameter.optional) {\n    this.tokenChar(63);\n  }\n  this.print(parameter.typeAnnotation, parameter);\n}\nfunction _methodHead(node) {\n  const kind = node.kind;\n  const key = node.key;\n  if (kind === \"get\" || kind === \"set\") {\n    this.word(kind);\n    this.space();\n  }\n  if (node.async) {\n    this.word(\"async\", true);\n    this.space();\n  }\n  if (kind === \"method\" || kind === \"init\") {\n    if (node.generator) {\n      this.tokenChar(42);\n    }\n  }\n  if (node.computed) {\n    this.tokenChar(91);\n    this.print(key, node);\n    this.tokenChar(93);\n  } else {\n    this.print(key, node);\n  }\n  if (node.optional) {\n    this.tokenChar(63);\n  }\n  this._params(node, node.computed && node.key.type !== \"StringLiteral\" ? undefined : node.key, undefined);\n}\nfunction _predicate(node, noLineTerminatorAfter) {\n  if (node.predicate) {\n    if (!node.returnType) {\n      this.tokenChar(58);\n    }\n    this.space();\n    this.print(node.predicate, node, noLineTerminatorAfter);\n  }\n}\nfunction _functionHead(node, parent) {\n  if (node.async) {\n    this.word(\"async\");\n    this._endsWithInnerRaw = false;\n    this.space();\n  }\n  this.word(\"function\");\n  if (node.generator) {\n    this._endsWithInnerRaw = false;\n    this.tokenChar(42);\n  }\n  this.space();\n  if (node.id) {\n    this.print(node.id, node);\n  }\n  this._params(node, node.id, parent);\n  if (node.type !== \"TSDeclareFunction\") {\n    this._predicate(node);\n  }\n}\nfunction FunctionExpression(node, parent) {\n  this._functionHead(node, parent);\n  this.space();\n  this.print(node.body, node);\n}\nfunction ArrowFunctionExpression(node, parent) {\n  if (node.async) {\n    this.word(\"async\", true);\n    this.space();\n  }\n  let firstParam;\n  if (!this.format.retainLines && node.params.length === 1 && isIdentifier(firstParam = node.params[0]) && !hasTypesOrComments(node, firstParam)) {\n    this.print(firstParam, node, true);\n  } else {\n    this._params(node, undefined, parent);\n  }\n  this._predicate(node, true);\n  this.space();\n  this.printInnerComments();\n  this.token(\"=>\");\n  this.space();\n  this.print(node.body, node);\n}\nfunction hasTypesOrComments(node, param) {\n  var _param$leadingComment, _param$trailingCommen;\n  return !!(node.typeParameters || node.returnType || node.predicate || param.typeAnnotation || param.optional || (_param$leadingComment = param.leadingComments) != null && _param$leadingComment.length || (_param$trailingCommen = param.trailingComments) != null && _param$trailingCommen.length);\n}\nfunction _getFuncIdName(idNode, parent) {\n  let id = idNode;\n  if (!id && parent) {\n    const parentType = parent.type;\n    if (parentType === \"VariableDeclarator\") {\n      id = parent.id;\n    } else if (parentType === \"AssignmentExpression\" || parentType === \"AssignmentPattern\") {\n      id = parent.left;\n    } else if (parentType === \"ObjectProperty\" || parentType === \"ClassProperty\") {\n      if (!parent.computed || parent.key.type === \"StringLiteral\") {\n        id = parent.key;\n      }\n    } else if (parentType === \"ClassPrivateProperty\" || parentType === \"ClassAccessorProperty\") {\n      id = parent.key;\n    }\n  }\n  if (!id) return;\n  let nameInfo;\n  if (id.type === \"Identifier\") {\n    var _id$loc, _id$loc2;\n    nameInfo = {\n      pos: (_id$loc = id.loc) == null ? void 0 : _id$loc.start,\n      name: ((_id$loc2 = id.loc) == null ? void 0 : _id$loc2.identifierName) || id.name\n    };\n  } else if (id.type === \"PrivateName\") {\n    var _id$loc3;\n    nameInfo = {\n      pos: (_id$loc3 = id.loc) == null ? void 0 : _id$loc3.start,\n      name: \"#\" + id.id.name\n    };\n  } else if (id.type === \"StringLiteral\") {\n    var _id$loc4;\n    nameInfo = {\n      pos: (_id$loc4 = id.loc) == null ? void 0 : _id$loc4.start,\n      name: id.value\n    };\n  }\n  return nameInfo;\n}\n\n//# sourceMappingURL=methods.js.map\n","import type Printer from \"../printer.ts\";\nimport type * as t from \"@babel/types\";\nimport { isIdentifier } from \"@babel/types\";\nimport type { NodePath } from \"@babel/traverse\";\n\nexport function _params(\n  this: Printer,\n  node: t.Function | t.TSDeclareMethod | t.TSDeclareFunction,\n  idNode: t.Expression | t.PrivateName,\n  parentNode: NodePath<\n    t.Function | t.TSDeclareMethod | t.TSDeclareFunction\n  >[\"parent\"],\n) {\n  this.print(node.typeParameters, node);\n\n  const nameInfo = _getFuncIdName.call(this, idNode, parentNode);\n  if (nameInfo) {\n    this.sourceIdentifierName(nameInfo.name, nameInfo.pos);\n  }\n\n  this.token(\"(\");\n  this._parameters(node.params, node);\n  this.token(\")\");\n\n  const noLineTerminator = node.type === \"ArrowFunctionExpression\";\n  this.print(node.returnType, node, noLineTerminator);\n\n  this._noLineTerminator = noLineTerminator;\n}\n\nexport function _parameters(\n  this: Printer,\n  parameters: t.Function[\"params\"],\n  parent:\n    | t.Function\n    | t.TSIndexSignature\n    | t.TSDeclareMethod\n    | t.TSDeclareFunction\n    | t.TSFunctionType\n    | t.TSConstructorType,\n) {\n  const paramLength = parameters.length;\n  for (let i = 0; i < paramLength; i++) {\n    this._param(parameters[i], parent);\n\n    if (i < parameters.length - 1) {\n      this.token(\",\");\n      this.space();\n    }\n  }\n}\n\nexport function _param(\n  this: Printer,\n  parameter: t.Identifier | t.RestElement | t.Pattern | t.TSParameterProperty,\n  parent?:\n    | t.Function\n    | t.TSIndexSignature\n    | t.TSDeclareMethod\n    | t.TSDeclareFunction\n    | t.TSFunctionType\n    | t.TSConstructorType,\n) {\n  this.printJoin(parameter.decorators, parameter);\n  this.print(parameter, parent);\n  if (\n    // @ts-expect-error optional is not in TSParameterProperty\n    parameter.optional\n  ) {\n    this.token(\"?\"); // TS / flow\n  }\n\n  this.print(\n    // @ts-expect-error typeAnnotation is not in TSParameterProperty\n    parameter.typeAnnotation,\n    parameter,\n  ); // TS / flow\n}\n\nexport function _methodHead(this: Printer, node: t.Method | t.TSDeclareMethod) {\n  const kind = node.kind;\n  const key = node.key;\n\n  if (kind === \"get\" || kind === \"set\") {\n    this.word(kind);\n    this.space();\n  }\n\n  if (node.async) {\n    this.word(\"async\", true);\n    this.space();\n  }\n\n  if (\n    kind === \"method\" ||\n    // @ts-expect-error Fixme: kind: \"init\" is not defined\n    kind === \"init\"\n  ) {\n    if (node.generator) {\n      this.token(\"*\");\n    }\n  }\n\n  if (node.computed) {\n    this.token(\"[\");\n    this.print(key, node);\n    this.token(\"]\");\n  } else {\n    this.print(key, node);\n  }\n\n  if (\n    // @ts-expect-error optional is not in ObjectMethod\n    node.optional\n  ) {\n    // TS\n    this.token(\"?\");\n  }\n\n  this._params(\n    node,\n    node.computed && node.key.type !== \"StringLiteral\" ? undefined : node.key,\n    undefined,\n  );\n}\n\nexport function _predicate(\n  this: Printer,\n  node:\n    | t.FunctionDeclaration\n    | t.FunctionExpression\n    | t.ArrowFunctionExpression,\n  noLineTerminatorAfter?: boolean,\n) {\n  if (node.predicate) {\n    if (!node.returnType) {\n      this.token(\":\");\n    }\n    this.space();\n    this.print(node.predicate, node, noLineTerminatorAfter);\n  }\n}\n\nexport function _functionHead(\n  this: Printer,\n  node: t.FunctionDeclaration | t.FunctionExpression | t.TSDeclareFunction,\n  parent: NodePath<\n    t.FunctionDeclaration | t.FunctionExpression | t.TSDeclareFunction\n  >[\"parent\"],\n) {\n  if (node.async) {\n    this.word(\"async\");\n    // We prevent inner comments from being printed here,\n    // so that they are always consistently printed in the\n    // same place regardless of the function type.\n    this._endsWithInnerRaw = false;\n    this.space();\n  }\n  this.word(\"function\");\n  if (node.generator) {\n    // We prevent inner comments from being printed here,\n    // so that they are always consistently printed in the\n    // same place regardless of the function type.\n    this._endsWithInnerRaw = false;\n    this.token(\"*\");\n  }\n\n  this.space();\n  if (node.id) {\n    this.print(node.id, node);\n  }\n\n  this._params(node, node.id, parent);\n  if (node.type !== \"TSDeclareFunction\") {\n    this._predicate(node);\n  }\n}\n\nexport function FunctionExpression(\n  this: Printer,\n  node: t.FunctionExpression,\n  parent: NodePath<t.FunctionExpression>[\"parent\"],\n) {\n  this._functionHead(node, parent);\n  this.space();\n  this.print(node.body, node);\n}\n\nexport { FunctionExpression as FunctionDeclaration };\n\nexport function ArrowFunctionExpression(\n  this: Printer,\n  node: t.ArrowFunctionExpression,\n  parent: NodePath<t.ArrowFunctionExpression>[\"parent\"],\n) {\n  if (node.async) {\n    this.word(\"async\", true);\n    this.space();\n  }\n\n  // Try to avoid printing parens in simple cases, but only if we're pretty\n  // sure that they aren't needed by type annotations or potential newlines.\n  let firstParam;\n  if (\n    !this.format.retainLines &&\n    node.params.length === 1 &&\n    isIdentifier((firstParam = node.params[0])) &&\n    !hasTypesOrComments(node, firstParam)\n  ) {\n    this.print(firstParam, node, true);\n  } else {\n    this._params(node, undefined, parent);\n  }\n\n  this._predicate(node, true);\n  this.space();\n  // When printing (x)/*1*/=>{}, we remove the parentheses\n  // and thus there aren't two contiguous inner tokens.\n  // We forcefully print inner comments here.\n  this.printInnerComments();\n  this.token(\"=>\");\n\n  this.space();\n\n  this.print(node.body, node);\n}\n\nfunction hasTypesOrComments(\n  node: t.ArrowFunctionExpression,\n  param: t.Identifier,\n): boolean {\n  return !!(\n    node.typeParameters ||\n    node.returnType ||\n    node.predicate ||\n    param.typeAnnotation ||\n    param.optional ||\n    // Flow does not support `foo /*: string*/ => {};`\n    param.leadingComments?.length ||\n    param.trailingComments?.length\n  );\n}\n\nfunction _getFuncIdName(\n  this: Printer,\n  idNode: t.Expression | t.PrivateName,\n  parent: NodePath<\n    t.Function | t.TSDeclareMethod | t.TSDeclareFunction\n  >[\"parent\"],\n) {\n  let id: t.Expression | t.PrivateName | t.LVal = idNode;\n\n  if (!id && parent) {\n    const parentType = parent.type;\n\n    if (parentType === \"VariableDeclarator\") {\n      id = parent.id;\n    } else if (\n      parentType === \"AssignmentExpression\" ||\n      parentType === \"AssignmentPattern\"\n    ) {\n      id = parent.left;\n    } else if (\n      parentType === \"ObjectProperty\" ||\n      parentType === \"ClassProperty\"\n    ) {\n      if (!parent.computed || parent.key.type === \"StringLiteral\") {\n        id = parent.key;\n      }\n    } else if (\n      parentType === \"ClassPrivateProperty\" ||\n      parentType === \"ClassAccessorProperty\"\n    ) {\n      id = parent.key;\n    }\n  }\n\n  if (!id) return;\n\n  let nameInfo;\n\n  if (id.type === \"Identifier\") {\n    nameInfo = {\n      pos: id.loc?.start,\n      name: id.loc?.identifierName || id.name,\n    };\n  } else if (id.type === \"PrivateName\") {\n    nameInfo = {\n      pos: id.loc?.start,\n      name: \"#\" + id.id.name,\n    };\n  } else if (id.type === \"StringLiteral\") {\n    nameInfo = {\n      pos: id.loc?.start,\n      name: id.value,\n    };\n  }\n\n  return nameInfo;\n}\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ExportAllDeclaration = ExportAllDeclaration;\nexports.ExportDefaultDeclaration = ExportDefaultDeclaration;\nexports.ExportDefaultSpecifier = ExportDefaultSpecifier;\nexports.ExportNamedDeclaration = ExportNamedDeclaration;\nexports.ExportNamespaceSpecifier = ExportNamespaceSpecifier;\nexports.ExportSpecifier = ExportSpecifier;\nexports.ImportAttribute = ImportAttribute;\nexports.ImportDeclaration = ImportDeclaration;\nexports.ImportDefaultSpecifier = ImportDefaultSpecifier;\nexports.ImportExpression = ImportExpression;\nexports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;\nexports.ImportSpecifier = ImportSpecifier;\nexports._printAttributes = _printAttributes;\nvar _t = require(\"@babel/types\");\nconst {\n  isClassDeclaration,\n  isExportDefaultSpecifier,\n  isExportNamespaceSpecifier,\n  isImportDefaultSpecifier,\n  isImportNamespaceSpecifier,\n  isStatement\n} = _t;\nfunction ImportSpecifier(node) {\n  if (node.importKind === \"type\" || node.importKind === \"typeof\") {\n    this.word(node.importKind);\n    this.space();\n  }\n  this.print(node.imported, node);\n  if (node.local && node.local.name !== node.imported.name) {\n    this.space();\n    this.word(\"as\");\n    this.space();\n    this.print(node.local, node);\n  }\n}\nfunction ImportDefaultSpecifier(node) {\n  this.print(node.local, node);\n}\nfunction ExportDefaultSpecifier(node) {\n  this.print(node.exported, node);\n}\nfunction ExportSpecifier(node) {\n  if (node.exportKind === \"type\") {\n    this.word(\"type\");\n    this.space();\n  }\n  this.print(node.local, node);\n  if (node.exported && node.local.name !== node.exported.name) {\n    this.space();\n    this.word(\"as\");\n    this.space();\n    this.print(node.exported, node);\n  }\n}\nfunction ExportNamespaceSpecifier(node) {\n  this.tokenChar(42);\n  this.space();\n  this.word(\"as\");\n  this.space();\n  this.print(node.exported, node);\n}\nlet warningShown = false;\nfunction _printAttributes(node) {\n  const {\n    importAttributesKeyword\n  } = this.format;\n  const {\n    attributes,\n    assertions\n  } = node;\n  if (attributes && !importAttributesKeyword && !warningShown) {\n    warningShown = true;\n    console.warn(`\\\nYou are using import attributes, without specifying the desired output syntax.\nPlease specify the \"importAttributesKeyword\" generator option, whose value can be one of:\n - \"with\"        : \\`import { a } from \"b\" with { type: \"json\" };\\`\n - \"assert\"      : \\`import { a } from \"b\" assert { type: \"json\" };\\`\n - \"with-legacy\" : \\`import { a } from \"b\" with type: \"json\";\\`\n`);\n  }\n  const useAssertKeyword = importAttributesKeyword === \"assert\" || !importAttributesKeyword && assertions;\n  this.word(useAssertKeyword ? \"assert\" : \"with\");\n  this.space();\n  if (!useAssertKeyword && importAttributesKeyword !== \"with\") {\n    this.printList(attributes || assertions, node);\n    return;\n  }\n  this.tokenChar(123);\n  this.space();\n  this.printList(attributes || assertions, node);\n  this.space();\n  this.tokenChar(125);\n}\nfunction ExportAllDeclaration(node) {\n  var _node$attributes, _node$assertions;\n  this.word(\"export\");\n  this.space();\n  if (node.exportKind === \"type\") {\n    this.word(\"type\");\n    this.space();\n  }\n  this.tokenChar(42);\n  this.space();\n  this.word(\"from\");\n  this.space();\n  if ((_node$attributes = node.attributes) != null && _node$attributes.length || (_node$assertions = node.assertions) != null && _node$assertions.length) {\n    this.print(node.source, node, true);\n    this.space();\n    this._printAttributes(node);\n  } else {\n    this.print(node.source, node);\n  }\n  this.semicolon();\n}\nfunction maybePrintDecoratorsBeforeExport(printer, node) {\n  if (isClassDeclaration(node.declaration) && printer._shouldPrintDecoratorsBeforeExport(node)) {\n    printer.printJoin(node.declaration.decorators, node);\n  }\n}\nfunction ExportNamedDeclaration(node) {\n  maybePrintDecoratorsBeforeExport(this, node);\n  this.word(\"export\");\n  this.space();\n  if (node.declaration) {\n    const declar = node.declaration;\n    this.print(declar, node);\n    if (!isStatement(declar)) this.semicolon();\n  } else {\n    if (node.exportKind === \"type\") {\n      this.word(\"type\");\n      this.space();\n    }\n    const specifiers = node.specifiers.slice(0);\n    let hasSpecial = false;\n    for (;;) {\n      const first = specifiers[0];\n      if (isExportDefaultSpecifier(first) || isExportNamespaceSpecifier(first)) {\n        hasSpecial = true;\n        this.print(specifiers.shift(), node);\n        if (specifiers.length) {\n          this.tokenChar(44);\n          this.space();\n        }\n      } else {\n        break;\n      }\n    }\n    if (specifiers.length || !specifiers.length && !hasSpecial) {\n      this.tokenChar(123);\n      if (specifiers.length) {\n        this.space();\n        this.printList(specifiers, node);\n        this.space();\n      }\n      this.tokenChar(125);\n    }\n    if (node.source) {\n      var _node$attributes2, _node$assertions2;\n      this.space();\n      this.word(\"from\");\n      this.space();\n      if ((_node$attributes2 = node.attributes) != null && _node$attributes2.length || (_node$assertions2 = node.assertions) != null && _node$assertions2.length) {\n        this.print(node.source, node, true);\n        this.space();\n        this._printAttributes(node);\n      } else {\n        this.print(node.source, node);\n      }\n    }\n    this.semicolon();\n  }\n}\nfunction ExportDefaultDeclaration(node) {\n  maybePrintDecoratorsBeforeExport(this, node);\n  this.word(\"export\");\n  this.noIndentInnerCommentsHere();\n  this.space();\n  this.word(\"default\");\n  this.space();\n  const declar = node.declaration;\n  this.print(declar, node);\n  if (!isStatement(declar)) this.semicolon();\n}\nfunction ImportDeclaration(node) {\n  var _node$attributes3, _node$assertions3;\n  this.word(\"import\");\n  this.space();\n  const isTypeKind = node.importKind === \"type\" || node.importKind === \"typeof\";\n  if (isTypeKind) {\n    this.noIndentInnerCommentsHere();\n    this.word(node.importKind);\n    this.space();\n  } else if (node.module) {\n    this.noIndentInnerCommentsHere();\n    this.word(\"module\");\n    this.space();\n  } else if (node.phase) {\n    this.noIndentInnerCommentsHere();\n    this.word(node.phase);\n    this.space();\n  }\n  const specifiers = node.specifiers.slice(0);\n  const hasSpecifiers = !!specifiers.length;\n  while (hasSpecifiers) {\n    const first = specifiers[0];\n    if (isImportDefaultSpecifier(first) || isImportNamespaceSpecifier(first)) {\n      this.print(specifiers.shift(), node);\n      if (specifiers.length) {\n        this.tokenChar(44);\n        this.space();\n      }\n    } else {\n      break;\n    }\n  }\n  if (specifiers.length) {\n    this.tokenChar(123);\n    this.space();\n    this.printList(specifiers, node);\n    this.space();\n    this.tokenChar(125);\n  } else if (isTypeKind && !hasSpecifiers) {\n    this.tokenChar(123);\n    this.tokenChar(125);\n  }\n  if (hasSpecifiers || isTypeKind) {\n    this.space();\n    this.word(\"from\");\n    this.space();\n  }\n  if ((_node$attributes3 = node.attributes) != null && _node$attributes3.length || (_node$assertions3 = node.assertions) != null && _node$assertions3.length) {\n    this.print(node.source, node, true);\n    this.space();\n    this._printAttributes(node);\n  } else {\n    this.print(node.source, node);\n  }\n  this.semicolon();\n}\nfunction ImportAttribute(node) {\n  this.print(node.key);\n  this.tokenChar(58);\n  this.space();\n  this.print(node.value);\n}\nfunction ImportNamespaceSpecifier(node) {\n  this.tokenChar(42);\n  this.space();\n  this.word(\"as\");\n  this.space();\n  this.print(node.local, node);\n}\nfunction ImportExpression(node) {\n  this.word(\"import\");\n  if (node.phase) {\n    this.tokenChar(46);\n    this.word(node.phase);\n  }\n  this.tokenChar(40);\n  this.print(node.source, node);\n  if (node.options != null) {\n    this.tokenChar(44);\n    this.space();\n    this.print(node.options, node);\n  }\n  this.tokenChar(41);\n}\n\n//# sourceMappingURL=modules.js.map\n","import type Printer from \"../printer.ts\";\nimport {\n  isClassDeclaration,\n  isExportDefaultSpecifier,\n  isExportNamespaceSpecifier,\n  isImportDefaultSpecifier,\n  isImportNamespaceSpecifier,\n  isStatement,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\nexport function ImportSpecifier(this: Printer, node: t.ImportSpecifier) {\n  if (node.importKind === \"type\" || node.importKind === \"typeof\") {\n    this.word(node.importKind);\n    this.space();\n  }\n\n  this.print(node.imported, node);\n  // @ts-expect-error todo(flow-ts) maybe check node type instead of relying on name to be undefined on t.StringLiteral\n  if (node.local && node.local.name !== node.imported.name) {\n    this.space();\n    this.word(\"as\");\n    this.space();\n    this.print(node.local, node);\n  }\n}\n\nexport function ImportDefaultSpecifier(\n  this: Printer,\n  node: t.ImportDefaultSpecifier,\n) {\n  this.print(node.local, node);\n}\n\nexport function ExportDefaultSpecifier(\n  this: Printer,\n  node: t.ExportDefaultSpecifier,\n) {\n  this.print(node.exported, node);\n}\n\nexport function ExportSpecifier(this: Printer, node: t.ExportSpecifier) {\n  if (node.exportKind === \"type\") {\n    this.word(\"type\");\n    this.space();\n  }\n\n  this.print(node.local, node);\n  // @ts-expect-error todo(flow-ts) maybe check node type instead of relying on name to be undefined on t.StringLiteral\n  if (node.exported && node.local.name !== node.exported.name) {\n    this.space();\n    this.word(\"as\");\n    this.space();\n    this.print(node.exported, node);\n  }\n}\n\nexport function ExportNamespaceSpecifier(\n  this: Printer,\n  node: t.ExportNamespaceSpecifier,\n) {\n  this.token(\"*\");\n  this.space();\n  this.word(\"as\");\n  this.space();\n  this.print(node.exported, node);\n}\n\nlet warningShown = false;\n\nexport function _printAttributes(\n  this: Printer,\n  node: Extract<t.Node, { attributes?: t.ImportAttribute[] }>,\n) {\n  const { importAttributesKeyword } = this.format;\n  const { attributes, assertions } = node;\n\n  if (\n    attributes &&\n    !importAttributesKeyword &&\n    // In the production build only show the warning once.\n    // We want to show it per-usage locally for tests.\n    (!process.env.IS_PUBLISH || !warningShown)\n  ) {\n    warningShown = true;\n    console.warn(`\\\nYou are using import attributes, without specifying the desired output syntax.\nPlease specify the \"importAttributesKeyword\" generator option, whose value can be one of:\n - \"with\"        : \\`import { a } from \"b\" with { type: \"json\" };\\`\n - \"assert\"      : \\`import { a } from \"b\" assert { type: \"json\" };\\`\n - \"with-legacy\" : \\`import { a } from \"b\" with type: \"json\";\\`\n`);\n  }\n\n  const useAssertKeyword =\n    importAttributesKeyword === \"assert\" ||\n    (!importAttributesKeyword && assertions);\n\n  this.word(useAssertKeyword ? \"assert\" : \"with\");\n  this.space();\n\n  if (!useAssertKeyword && importAttributesKeyword !== \"with\") {\n    // with-legacy\n    this.printList(attributes || assertions, node);\n    return;\n  }\n\n  this.token(\"{\");\n  this.space();\n  this.printList(attributes || assertions, node);\n  this.space();\n  this.token(\"}\");\n}\n\nexport function ExportAllDeclaration(\n  this: Printer,\n  node: t.ExportAllDeclaration | t.DeclareExportAllDeclaration,\n) {\n  this.word(\"export\");\n  this.space();\n  if (node.exportKind === \"type\") {\n    this.word(\"type\");\n    this.space();\n  }\n  this.token(\"*\");\n  this.space();\n  this.word(\"from\");\n  this.space();\n  // @ts-expect-error Fixme: attributes is not defined in DeclareExportAllDeclaration\n  if (node.attributes?.length || node.assertions?.length) {\n    this.print(node.source, node, true);\n    this.space();\n    // @ts-expect-error Fixme: attributes is not defined in DeclareExportAllDeclaration\n    this._printAttributes(node);\n  } else {\n    this.print(node.source, node);\n  }\n\n  this.semicolon();\n}\n\nfunction maybePrintDecoratorsBeforeExport(\n  printer: Printer,\n  node: t.ExportNamedDeclaration | t.ExportDefaultDeclaration,\n) {\n  if (\n    isClassDeclaration(node.declaration) &&\n    printer._shouldPrintDecoratorsBeforeExport(\n      node as t.ExportNamedDeclaration & { declaration: t.ClassDeclaration },\n    )\n  ) {\n    printer.printJoin(node.declaration.decorators, node);\n  }\n}\n\nexport function ExportNamedDeclaration(\n  this: Printer,\n  node: t.ExportNamedDeclaration,\n) {\n  maybePrintDecoratorsBeforeExport(this, node);\n\n  this.word(\"export\");\n  this.space();\n  if (node.declaration) {\n    const declar = node.declaration;\n    this.print(declar, node);\n    if (!isStatement(declar)) this.semicolon();\n  } else {\n    if (node.exportKind === \"type\") {\n      this.word(\"type\");\n      this.space();\n    }\n\n    const specifiers = node.specifiers.slice(0);\n\n    // print \"special\" specifiers first\n    let hasSpecial = false;\n    for (;;) {\n      const first = specifiers[0];\n      if (\n        isExportDefaultSpecifier(first) ||\n        isExportNamespaceSpecifier(first)\n      ) {\n        hasSpecial = true;\n        this.print(specifiers.shift(), node);\n        if (specifiers.length) {\n          this.token(\",\");\n          this.space();\n        }\n      } else {\n        break;\n      }\n    }\n\n    if (specifiers.length || (!specifiers.length && !hasSpecial)) {\n      this.token(\"{\");\n      if (specifiers.length) {\n        this.space();\n        this.printList(specifiers, node);\n        this.space();\n      }\n      this.token(\"}\");\n    }\n\n    if (node.source) {\n      this.space();\n      this.word(\"from\");\n      this.space();\n      if (node.attributes?.length || node.assertions?.length) {\n        this.print(node.source, node, true);\n        this.space();\n        this._printAttributes(node);\n      } else {\n        this.print(node.source, node);\n      }\n    }\n\n    this.semicolon();\n  }\n}\n\nexport function ExportDefaultDeclaration(\n  this: Printer,\n  node: t.ExportDefaultDeclaration,\n) {\n  maybePrintDecoratorsBeforeExport(this, node);\n\n  this.word(\"export\");\n  this.noIndentInnerCommentsHere();\n  this.space();\n  this.word(\"default\");\n  this.space();\n  const declar = node.declaration;\n  this.print(declar, node);\n  if (!isStatement(declar)) this.semicolon();\n}\n\nexport function ImportDeclaration(this: Printer, node: t.ImportDeclaration) {\n  this.word(\"import\");\n  this.space();\n\n  const isTypeKind = node.importKind === \"type\" || node.importKind === \"typeof\";\n  if (isTypeKind) {\n    this.noIndentInnerCommentsHere();\n    this.word(node.importKind);\n    this.space();\n  } else if (node.module) {\n    this.noIndentInnerCommentsHere();\n    this.word(\"module\");\n    this.space();\n  } else if (node.phase) {\n    this.noIndentInnerCommentsHere();\n    this.word(node.phase);\n    this.space();\n  }\n\n  const specifiers = node.specifiers.slice(0);\n  const hasSpecifiers = !!specifiers.length;\n  // print \"special\" specifiers first. The loop condition is constant,\n  // but there is a \"break\" in the body.\n  while (hasSpecifiers) {\n    const first = specifiers[0];\n    if (isImportDefaultSpecifier(first) || isImportNamespaceSpecifier(first)) {\n      this.print(specifiers.shift(), node);\n      if (specifiers.length) {\n        this.token(\",\");\n        this.space();\n      }\n    } else {\n      break;\n    }\n  }\n\n  if (specifiers.length) {\n    this.token(\"{\");\n    this.space();\n    this.printList(specifiers, node);\n    this.space();\n    this.token(\"}\");\n  } else if (isTypeKind && !hasSpecifiers) {\n    this.token(\"{\");\n    this.token(\"}\");\n  }\n\n  if (hasSpecifiers || isTypeKind) {\n    this.space();\n    this.word(\"from\");\n    this.space();\n  }\n\n  if (node.attributes?.length || node.assertions?.length) {\n    this.print(node.source, node, true);\n    this.space();\n    this._printAttributes(node);\n  } else {\n    this.print(node.source, node);\n  }\n\n  this.semicolon();\n}\n\nexport function ImportAttribute(this: Printer, node: t.ImportAttribute) {\n  this.print(node.key);\n  this.token(\":\");\n  this.space();\n  this.print(node.value);\n}\n\nexport function ImportNamespaceSpecifier(\n  this: Printer,\n  node: t.ImportNamespaceSpecifier,\n) {\n  this.token(\"*\");\n  this.space();\n  this.word(\"as\");\n  this.space();\n  this.print(node.local, node);\n}\n\nexport function ImportExpression(this: Printer, node: t.ImportExpression) {\n  this.word(\"import\");\n  if (node.phase) {\n    this.token(\".\");\n    this.word(node.phase);\n  }\n  this.token(\"(\");\n  this.print(node.source, node);\n  if (node.options != null) {\n    this.token(\",\");\n    this.space();\n    this.print(node.options, node);\n  }\n  this.token(\")\");\n}\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ArgumentPlaceholder = ArgumentPlaceholder;\nexports.ArrayPattern = exports.ArrayExpression = ArrayExpression;\nexports.BigIntLiteral = BigIntLiteral;\nexports.BooleanLiteral = BooleanLiteral;\nexports.DecimalLiteral = DecimalLiteral;\nexports.Identifier = Identifier;\nexports.NullLiteral = NullLiteral;\nexports.NumericLiteral = NumericLiteral;\nexports.ObjectPattern = exports.ObjectExpression = ObjectExpression;\nexports.ObjectMethod = ObjectMethod;\nexports.ObjectProperty = ObjectProperty;\nexports.PipelineBareFunction = PipelineBareFunction;\nexports.PipelinePrimaryTopicReference = PipelinePrimaryTopicReference;\nexports.PipelineTopicExpression = PipelineTopicExpression;\nexports.RecordExpression = RecordExpression;\nexports.RegExpLiteral = RegExpLiteral;\nexports.SpreadElement = exports.RestElement = RestElement;\nexports.StringLiteral = StringLiteral;\nexports.TopicReference = TopicReference;\nexports.TupleExpression = TupleExpression;\nvar _t = require(\"@babel/types\");\nvar _jsesc = require(\"jsesc\");\nconst {\n  isAssignmentPattern,\n  isIdentifier\n} = _t;\nfunction Identifier(node) {\n  var _node$loc;\n  this.sourceIdentifierName(((_node$loc = node.loc) == null ? void 0 : _node$loc.identifierName) || node.name);\n  this.word(node.name);\n}\nfunction ArgumentPlaceholder() {\n  this.tokenChar(63);\n}\nfunction RestElement(node) {\n  this.token(\"...\");\n  this.print(node.argument, node);\n}\nfunction ObjectExpression(node) {\n  const props = node.properties;\n  this.tokenChar(123);\n  if (props.length) {\n    this.space();\n    this.printList(props, node, {\n      indent: true,\n      statement: true\n    });\n    this.space();\n  }\n  this.sourceWithOffset(\"end\", node.loc, -1);\n  this.tokenChar(125);\n}\nfunction ObjectMethod(node) {\n  this.printJoin(node.decorators, node);\n  this._methodHead(node);\n  this.space();\n  this.print(node.body, node);\n}\nfunction ObjectProperty(node) {\n  this.printJoin(node.decorators, node);\n  if (node.computed) {\n    this.tokenChar(91);\n    this.print(node.key, node);\n    this.tokenChar(93);\n  } else {\n    if (isAssignmentPattern(node.value) && isIdentifier(node.key) && node.key.name === node.value.left.name) {\n      this.print(node.value, node);\n      return;\n    }\n    this.print(node.key, node);\n    if (node.shorthand && isIdentifier(node.key) && isIdentifier(node.value) && node.key.name === node.value.name) {\n      return;\n    }\n  }\n  this.tokenChar(58);\n  this.space();\n  this.print(node.value, node);\n}\nfunction ArrayExpression(node) {\n  const elems = node.elements;\n  const len = elems.length;\n  this.tokenChar(91);\n  for (let i = 0; i < elems.length; i++) {\n    const elem = elems[i];\n    if (elem) {\n      if (i > 0) this.space();\n      this.print(elem, node);\n      if (i < len - 1) this.tokenChar(44);\n    } else {\n      this.tokenChar(44);\n    }\n  }\n  this.tokenChar(93);\n}\nfunction RecordExpression(node) {\n  const props = node.properties;\n  let startToken;\n  let endToken;\n  if (this.format.recordAndTupleSyntaxType === \"bar\") {\n    startToken = \"{|\";\n    endToken = \"|}\";\n  } else if (this.format.recordAndTupleSyntaxType !== \"hash\" && this.format.recordAndTupleSyntaxType != null) {\n    throw new Error(`The \"recordAndTupleSyntaxType\" generator option must be \"bar\" or \"hash\" (${JSON.stringify(this.format.recordAndTupleSyntaxType)} received).`);\n  } else {\n    startToken = \"#{\";\n    endToken = \"}\";\n  }\n  this.token(startToken);\n  if (props.length) {\n    this.space();\n    this.printList(props, node, {\n      indent: true,\n      statement: true\n    });\n    this.space();\n  }\n  this.token(endToken);\n}\nfunction TupleExpression(node) {\n  const elems = node.elements;\n  const len = elems.length;\n  let startToken;\n  let endToken;\n  if (this.format.recordAndTupleSyntaxType === \"bar\") {\n    startToken = \"[|\";\n    endToken = \"|]\";\n  } else if (this.format.recordAndTupleSyntaxType === \"hash\") {\n    startToken = \"#[\";\n    endToken = \"]\";\n  } else {\n    throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);\n  }\n  this.token(startToken);\n  for (let i = 0; i < elems.length; i++) {\n    const elem = elems[i];\n    if (elem) {\n      if (i > 0) this.space();\n      this.print(elem, node);\n      if (i < len - 1) this.tokenChar(44);\n    }\n  }\n  this.token(endToken);\n}\nfunction RegExpLiteral(node) {\n  this.word(`/${node.pattern}/${node.flags}`);\n}\nfunction BooleanLiteral(node) {\n  this.word(node.value ? \"true\" : \"false\");\n}\nfunction NullLiteral() {\n  this.word(\"null\");\n}\nfunction NumericLiteral(node) {\n  const raw = this.getPossibleRaw(node);\n  const opts = this.format.jsescOption;\n  const value = node.value + \"\";\n  if (opts.numbers) {\n    this.number(_jsesc(node.value, opts));\n  } else if (raw == null) {\n    this.number(value);\n  } else if (this.format.minified) {\n    this.number(raw.length < value.length ? raw : value);\n  } else {\n    this.number(raw);\n  }\n}\nfunction StringLiteral(node) {\n  const raw = this.getPossibleRaw(node);\n  if (!this.format.minified && raw !== undefined) {\n    this.token(raw);\n    return;\n  }\n  const val = _jsesc(node.value, this.format.jsescOption);\n  this.token(val);\n}\nfunction BigIntLiteral(node) {\n  const raw = this.getPossibleRaw(node);\n  if (!this.format.minified && raw !== undefined) {\n    this.word(raw);\n    return;\n  }\n  this.word(node.value + \"n\");\n}\nfunction DecimalLiteral(node) {\n  const raw = this.getPossibleRaw(node);\n  if (!this.format.minified && raw !== undefined) {\n    this.word(raw);\n    return;\n  }\n  this.word(node.value + \"m\");\n}\nconst validTopicTokenSet = new Set([\"^^\", \"@@\", \"^\", \"%\", \"#\"]);\nfunction TopicReference() {\n  const {\n    topicToken\n  } = this.format;\n  if (validTopicTokenSet.has(topicToken)) {\n    this.token(topicToken);\n  } else {\n    const givenTopicTokenJSON = JSON.stringify(topicToken);\n    const validTopics = Array.from(validTopicTokenSet, v => JSON.stringify(v));\n    throw new Error(`The \"topicToken\" generator option must be one of ` + `${validTopics.join(\", \")} (${givenTopicTokenJSON} received instead).`);\n  }\n}\nfunction PipelineTopicExpression(node) {\n  this.print(node.expression, node);\n}\nfunction PipelineBareFunction(node) {\n  this.print(node.callee, node);\n}\nfunction PipelinePrimaryTopicReference() {\n  this.tokenChar(35);\n}\n\n//# sourceMappingURL=types.js.map\n","import type Printer from \"../printer.ts\";\nimport { isAssignmentPattern, isIdentifier } from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport jsesc from \"jsesc\";\n\nexport function Identifier(this: Printer, node: t.Identifier) {\n  this.sourceIdentifierName(node.loc?.identifierName || node.name);\n  this.word(node.name);\n}\n\nexport function ArgumentPlaceholder(this: Printer) {\n  this.token(\"?\");\n}\n\nexport function RestElement(this: Printer, node: t.RestElement) {\n  this.token(\"...\");\n  this.print(node.argument, node);\n}\n\nexport { RestElement as SpreadElement };\n\nexport function ObjectExpression(this: Printer, node: t.ObjectExpression) {\n  const props = node.properties;\n\n  this.token(\"{\");\n\n  if (props.length) {\n    this.space();\n    this.printList(props, node, { indent: true, statement: true });\n    this.space();\n  }\n\n  this.sourceWithOffset(\"end\", node.loc, -1);\n\n  this.token(\"}\");\n}\n\nexport { ObjectExpression as ObjectPattern };\n\nexport function ObjectMethod(this: Printer, node: t.ObjectMethod) {\n  this.printJoin(node.decorators, node);\n  this._methodHead(node);\n  this.space();\n  this.print(node.body, node);\n}\n\nexport function ObjectProperty(this: Printer, node: t.ObjectProperty) {\n  this.printJoin(node.decorators, node);\n\n  if (node.computed) {\n    this.token(\"[\");\n    this.print(node.key, node);\n    this.token(\"]\");\n  } else {\n    // print `({ foo: foo = 5 } = {})` as `({ foo = 5 } = {});`\n    if (\n      isAssignmentPattern(node.value) &&\n      isIdentifier(node.key) &&\n      // @ts-expect-error todo(flow->ts) `.name` does not exist on some types in union\n      node.key.name === node.value.left.name\n    ) {\n      this.print(node.value, node);\n      return;\n    }\n\n    this.print(node.key, node);\n\n    // shorthand!\n    if (\n      node.shorthand &&\n      isIdentifier(node.key) &&\n      isIdentifier(node.value) &&\n      node.key.name === node.value.name\n    ) {\n      return;\n    }\n  }\n\n  this.token(\":\");\n  this.space();\n  this.print(node.value, node);\n}\n\nexport function ArrayExpression(this: Printer, node: t.ArrayExpression) {\n  const elems = node.elements;\n  const len = elems.length;\n\n  this.token(\"[\");\n\n  for (let i = 0; i < elems.length; i++) {\n    const elem = elems[i];\n    if (elem) {\n      if (i > 0) this.space();\n      this.print(elem, node);\n      if (i < len - 1) this.token(\",\");\n    } else {\n      // If the array expression ends with a hole, that hole\n      // will be ignored by the interpreter, but if it ends with\n      // two (or more) holes, we need to write out two (or more)\n      // commas so that the resulting code is interpreted with\n      // both (all) of the holes.\n      this.token(\",\");\n    }\n  }\n\n  this.token(\"]\");\n}\n\nexport { ArrayExpression as ArrayPattern };\n\nexport function RecordExpression(this: Printer, node: t.RecordExpression) {\n  const props = node.properties;\n\n  let startToken;\n  let endToken;\n  if (this.format.recordAndTupleSyntaxType === \"bar\") {\n    startToken = \"{|\";\n    endToken = \"|}\";\n  } else if (\n    this.format.recordAndTupleSyntaxType !== \"hash\" &&\n    this.format.recordAndTupleSyntaxType != null\n  ) {\n    throw new Error(\n      `The \"recordAndTupleSyntaxType\" generator option must be \"bar\" or \"hash\" (${JSON.stringify(\n        this.format.recordAndTupleSyntaxType,\n      )} received).`,\n    );\n  } else {\n    startToken = \"#{\";\n    endToken = \"}\";\n  }\n\n  this.token(startToken);\n\n  if (props.length) {\n    this.space();\n    this.printList(props, node, { indent: true, statement: true });\n    this.space();\n  }\n  this.token(endToken);\n}\n\nexport function TupleExpression(this: Printer, node: t.TupleExpression) {\n  const elems = node.elements;\n  const len = elems.length;\n\n  let startToken;\n  let endToken;\n  if (this.format.recordAndTupleSyntaxType === \"bar\") {\n    startToken = \"[|\";\n    endToken = \"|]\";\n  } else if (this.format.recordAndTupleSyntaxType === \"hash\") {\n    startToken = \"#[\";\n    endToken = \"]\";\n  } else {\n    throw new Error(\n      `${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`,\n    );\n  }\n\n  this.token(startToken);\n\n  for (let i = 0; i < elems.length; i++) {\n    const elem = elems[i];\n    if (elem) {\n      if (i > 0) this.space();\n      this.print(elem, node);\n      if (i < len - 1) this.token(\",\");\n    }\n  }\n\n  this.token(endToken);\n}\n\nexport function RegExpLiteral(this: Printer, node: t.RegExpLiteral) {\n  this.word(`/${node.pattern}/${node.flags}`);\n}\n\nexport function BooleanLiteral(this: Printer, node: t.BooleanLiteral) {\n  this.word(node.value ? \"true\" : \"false\");\n}\n\nexport function NullLiteral(this: Printer) {\n  this.word(\"null\");\n}\n\nexport function NumericLiteral(this: Printer, node: t.NumericLiteral) {\n  const raw = this.getPossibleRaw(node);\n  const opts = this.format.jsescOption;\n  const value = node.value + \"\";\n  if (opts.numbers) {\n    this.number(jsesc(node.value, opts));\n  } else if (raw == null) {\n    this.number(value); // normalize\n  } else if (this.format.minified) {\n    this.number(raw.length < value.length ? raw : value);\n  } else {\n    this.number(raw);\n  }\n}\n\nexport function StringLiteral(this: Printer, node: t.StringLiteral) {\n  const raw = this.getPossibleRaw(node);\n  if (!this.format.minified && raw !== undefined) {\n    this.token(raw);\n    return;\n  }\n\n  const val = jsesc(node.value, this.format.jsescOption);\n\n  this.token(val);\n}\n\nexport function BigIntLiteral(this: Printer, node: t.BigIntLiteral) {\n  const raw = this.getPossibleRaw(node);\n  if (!this.format.minified && raw !== undefined) {\n    this.word(raw);\n    return;\n  }\n  this.word(node.value + \"n\");\n}\n\nexport function DecimalLiteral(this: Printer, node: t.DecimalLiteral) {\n  const raw = this.getPossibleRaw(node);\n  if (!this.format.minified && raw !== undefined) {\n    this.word(raw);\n    return;\n  }\n  this.word(node.value + \"m\");\n}\n\n// Hack pipe operator\nconst validTopicTokenSet = new Set([\"^^\", \"@@\", \"^\", \"%\", \"#\"]);\nexport function TopicReference(this: Printer) {\n  const { topicToken } = this.format;\n\n  if (validTopicTokenSet.has(topicToken)) {\n    this.token(topicToken);\n  } else {\n    const givenTopicTokenJSON = JSON.stringify(topicToken);\n    const validTopics = Array.from(validTopicTokenSet, v => JSON.stringify(v));\n    throw new Error(\n      `The \"topicToken\" generator option must be one of ` +\n        `${validTopics.join(\", \")} (${givenTopicTokenJSON} received instead).`,\n    );\n  }\n}\n\n// Smart-mix pipe operator\nexport function PipelineTopicExpression(\n  this: Printer,\n  node: t.PipelineTopicExpression,\n) {\n  this.print(node.expression, node);\n}\n\nexport function PipelineBareFunction(\n  this: Printer,\n  node: t.PipelineBareFunction,\n) {\n  this.print(node.callee, node);\n}\n\nexport function PipelinePrimaryTopicReference(this: Printer) {\n  this.token(\"#\");\n}\n","'use strict';\n\nconst object = {};\nconst hasOwnProperty = object.hasOwnProperty;\nconst forOwn = (object, callback) => {\n\tfor (const key in object) {\n\t\tif (hasOwnProperty.call(object, key)) {\n\t\t\tcallback(key, object[key]);\n\t\t}\n\t}\n};\n\nconst extend = (destination, source) => {\n\tif (!source) {\n\t\treturn destination;\n\t}\n\tforOwn(source, (key, value) => {\n\t\tdestination[key] = value;\n\t});\n\treturn destination;\n};\n\nconst forEach = (array, callback) => {\n\tconst length = array.length;\n\tlet index = -1;\n\twhile (++index < length) {\n\t\tcallback(array[index]);\n\t}\n};\n\nconst toString = object.toString;\nconst isArray = Array.isArray;\nconst isBuffer = Buffer.isBuffer;\nconst isObject = (value) => {\n\t// This is a very simple check, but its good enough for what we need.\n\treturn toString.call(value) == '[object Object]';\n};\nconst isString = (value) => {\n\treturn typeof value == 'string' ||\n\t\ttoString.call(value) == '[object String]';\n};\nconst isNumber = (value) => {\n\treturn typeof value == 'number' ||\n\t\ttoString.call(value) == '[object Number]';\n};\nconst isFunction = (value) => {\n\treturn typeof value == 'function';\n};\nconst isMap = (value) => {\n\treturn toString.call(value) == '[object Map]';\n};\nconst isSet = (value) => {\n\treturn toString.call(value) == '[object Set]';\n};\n\n/*--------------------------------------------------------------------------*/\n\n// https://mathiasbynens.be/notes/javascript-escapes#single\nconst singleEscapes = {\n\t'\"': '\\\\\"',\n\t'\\'': '\\\\\\'',\n\t'\\\\': '\\\\\\\\',\n\t'\\b': '\\\\b',\n\t'\\f': '\\\\f',\n\t'\\n': '\\\\n',\n\t'\\r': '\\\\r',\n\t'\\t': '\\\\t'\n\t// `\\v` is omitted intentionally, because in IE < 9, '\\v' == 'v'.\n\t// '\\v': '\\\\x0B'\n};\nconst regexSingleEscape = /[\"'\\\\\\b\\f\\n\\r\\t]/;\n\nconst regexDigit = /[0-9]/;\nconst regexWhitelist = /[ !#-&\\(-\\[\\]-_a-~]/;\n\nconst jsesc = (argument, options) => {\n\tconst increaseIndentation = () => {\n\t\toldIndent = indent;\n\t\t++options.indentLevel;\n\t\tindent = options.indent.repeat(options.indentLevel)\n\t};\n\t// Handle options\n\tconst defaults = {\n\t\t'escapeEverything': false,\n\t\t'minimal': false,\n\t\t'isScriptContext': false,\n\t\t'quotes': 'single',\n\t\t'wrap': false,\n\t\t'es6': false,\n\t\t'json': false,\n\t\t'compact': true,\n\t\t'lowercaseHex': false,\n\t\t'numbers': 'decimal',\n\t\t'indent': '\\t',\n\t\t'indentLevel': 0,\n\t\t'__inline1__': false,\n\t\t'__inline2__': false\n\t};\n\tconst json = options && options.json;\n\tif (json) {\n\t\tdefaults.quotes = 'double';\n\t\tdefaults.wrap = true;\n\t}\n\toptions = extend(defaults, options);\n\tif (\n\t\toptions.quotes != 'single' &&\n\t\toptions.quotes != 'double' &&\n\t\toptions.quotes != 'backtick'\n\t) {\n\t\toptions.quotes = 'single';\n\t}\n\tconst quote = options.quotes == 'double' ?\n\t\t'\"' :\n\t\t(options.quotes == 'backtick' ?\n\t\t\t'`' :\n\t\t\t'\\''\n\t\t);\n\tconst compact = options.compact;\n\tconst lowercaseHex = options.lowercaseHex;\n\tlet indent = options.indent.repeat(options.indentLevel);\n\tlet oldIndent = '';\n\tconst inline1 = options.__inline1__;\n\tconst inline2 = options.__inline2__;\n\tconst newLine = compact ? '' : '\\n';\n\tlet result;\n\tlet isEmpty = true;\n\tconst useBinNumbers = options.numbers == 'binary';\n\tconst useOctNumbers = options.numbers == 'octal';\n\tconst useDecNumbers = options.numbers == 'decimal';\n\tconst useHexNumbers = options.numbers == 'hexadecimal';\n\n\tif (json && argument && isFunction(argument.toJSON)) {\n\t\targument = argument.toJSON();\n\t}\n\n\tif (!isString(argument)) {\n\t\tif (isMap(argument)) {\n\t\t\tif (argument.size == 0) {\n\t\t\t\treturn 'new Map()';\n\t\t\t}\n\t\t\tif (!compact) {\n\t\t\t\toptions.__inline1__ = true;\n\t\t\t\toptions.__inline2__ = false;\n\t\t\t}\n\t\t\treturn 'new Map(' + jsesc(Array.from(argument), options) + ')';\n\t\t}\n\t\tif (isSet(argument)) {\n\t\t\tif (argument.size == 0) {\n\t\t\t\treturn 'new Set()';\n\t\t\t}\n\t\t\treturn 'new Set(' + jsesc(Array.from(argument), options) + ')';\n\t\t}\n\t\tif (isBuffer(argument)) {\n\t\t\tif (argument.length == 0) {\n\t\t\t\treturn 'Buffer.from([])';\n\t\t\t}\n\t\t\treturn 'Buffer.from(' + jsesc(Array.from(argument), options) + ')';\n\t\t}\n\t\tif (isArray(argument)) {\n\t\t\tresult = [];\n\t\t\toptions.wrap = true;\n\t\t\tif (inline1) {\n\t\t\t\toptions.__inline1__ = false;\n\t\t\t\toptions.__inline2__ = true;\n\t\t\t}\n\t\t\tif (!inline2) {\n\t\t\t\tincreaseIndentation();\n\t\t\t}\n\t\t\tforEach(argument, (value) => {\n\t\t\t\tisEmpty = false;\n\t\t\t\tif (inline2) {\n\t\t\t\t\toptions.__inline2__ = false;\n\t\t\t\t}\n\t\t\t\tresult.push(\n\t\t\t\t\t(compact || inline2 ? '' : indent) +\n\t\t\t\t\tjsesc(value, options)\n\t\t\t\t);\n\t\t\t});\n\t\t\tif (isEmpty) {\n\t\t\t\treturn '[]';\n\t\t\t}\n\t\t\tif (inline2) {\n\t\t\t\treturn '[' + result.join(', ') + ']';\n\t\t\t}\n\t\t\treturn '[' + newLine + result.join(',' + newLine) + newLine +\n\t\t\t\t(compact ? '' : oldIndent) + ']';\n\t\t} else if (isNumber(argument)) {\n\t\t\tif (json) {\n\t\t\t\t// Some number values (e.g. `Infinity`) cannot be represented in JSON.\n\t\t\t\treturn JSON.stringify(argument);\n\t\t\t}\n\t\t\tif (useDecNumbers) {\n\t\t\t\treturn String(argument);\n\t\t\t}\n\t\t\tif (useHexNumbers) {\n\t\t\t\tlet hexadecimal = argument.toString(16);\n\t\t\t\tif (!lowercaseHex) {\n\t\t\t\t\thexadecimal = hexadecimal.toUpperCase();\n\t\t\t\t}\n\t\t\t\treturn '0x' + hexadecimal;\n\t\t\t}\n\t\t\tif (useBinNumbers) {\n\t\t\t\treturn '0b' + argument.toString(2);\n\t\t\t}\n\t\t\tif (useOctNumbers) {\n\t\t\t\treturn '0o' + argument.toString(8);\n\t\t\t}\n\t\t} else if (!isObject(argument)) {\n\t\t\tif (json) {\n\t\t\t\t// For some values (e.g. `undefined`, `function` objects),\n\t\t\t\t// `JSON.stringify(value)` returns `undefined` (which isnt valid\n\t\t\t\t// JSON) instead of `'null'`.\n\t\t\t\treturn JSON.stringify(argument) || 'null';\n\t\t\t}\n\t\t\treturn String(argument);\n\t\t} else { // its an object\n\t\t\tresult = [];\n\t\t\toptions.wrap = true;\n\t\t\tincreaseIndentation();\n\t\t\tforOwn(argument, (key, value) => {\n\t\t\t\tisEmpty = false;\n\t\t\t\tresult.push(\n\t\t\t\t\t(compact ? '' : indent) +\n\t\t\t\t\tjsesc(key, options) + ':' +\n\t\t\t\t\t(compact ? '' : ' ') +\n\t\t\t\t\tjsesc(value, options)\n\t\t\t\t);\n\t\t\t});\n\t\t\tif (isEmpty) {\n\t\t\t\treturn '{}';\n\t\t\t}\n\t\t\treturn '{' + newLine + result.join(',' + newLine) + newLine +\n\t\t\t\t(compact ? '' : oldIndent) + '}';\n\t\t}\n\t}\n\n\tconst string = argument;\n\t// Loop over each code unit in the string and escape it\n\tlet index = -1;\n\tconst length = string.length;\n\tresult = '';\n\twhile (++index < length) {\n\t\tconst character = string.charAt(index);\n\t\tif (options.es6) {\n\t\t\tconst first = string.charCodeAt(index);\n\t\t\tif ( // check if its the start of a surrogate pair\n\t\t\t\tfirst >= 0xD800 && first <= 0xDBFF && // high surrogate\n\t\t\t\tlength > index + 1 // there is a next code unit\n\t\t\t) {\n\t\t\t\tconst second = string.charCodeAt(index + 1);\n\t\t\t\tif (second >= 0xDC00 && second <= 0xDFFF) { // low surrogate\n\t\t\t\t\t// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n\t\t\t\t\tconst codePoint = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n\t\t\t\t\tlet hexadecimal = codePoint.toString(16);\n\t\t\t\t\tif (!lowercaseHex) {\n\t\t\t\t\t\thexadecimal = hexadecimal.toUpperCase();\n\t\t\t\t\t}\n\t\t\t\t\tresult += '\\\\u{' + hexadecimal + '}';\n\t\t\t\t\t++index;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!options.escapeEverything) {\n\t\t\tif (regexWhitelist.test(character)) {\n\t\t\t\t// Its a printable ASCII character that is not `\"`, `'` or `\\`,\n\t\t\t\t// so dont escape it.\n\t\t\t\tresult += character;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (character == '\"') {\n\t\t\t\tresult += quote == character ? '\\\\\"' : character;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (character == '`') {\n\t\t\t\tresult += quote == character ? '\\\\`' : character;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (character == '\\'') {\n\t\t\t\tresult += quote == character ? '\\\\\\'' : character;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (\n\t\t\tcharacter == '\\0' &&\n\t\t\t!json &&\n\t\t\t!regexDigit.test(string.charAt(index + 1))\n\t\t) {\n\t\t\tresult += '\\\\0';\n\t\t\tcontinue;\n\t\t}\n\t\tif (regexSingleEscape.test(character)) {\n\t\t\t// no need for a `hasOwnProperty` check here\n\t\t\tresult += singleEscapes[character];\n\t\t\tcontinue;\n\t\t}\n\t\tconst charCode = character.charCodeAt(0);\n\t\tif (options.minimal && charCode != 0x2028 && charCode != 0x2029) {\n\t\t\tresult += character;\n\t\t\tcontinue;\n\t\t}\n\t\tlet hexadecimal = charCode.toString(16);\n\t\tif (!lowercaseHex) {\n\t\t\thexadecimal = hexadecimal.toUpperCase();\n\t\t}\n\t\tconst longhand = hexadecimal.length > 2 || json;\n\t\tconst escaped = '\\\\' + (longhand ? 'u' : 'x') +\n\t\t\t('0000' + hexadecimal).slice(longhand ? -4 : -2);\n\t\tresult += escaped;\n\t\tcontinue;\n\t}\n\tif (options.wrap) {\n\t\tresult = quote + result + quote;\n\t}\n\tif (quote == '`') {\n\t\tresult = result.replace(/\\$\\{/g, '\\\\\\$\\{');\n\t}\n\tif (options.isScriptContext) {\n\t\t// https://mathiasbynens.be/notes/etago\n\t\treturn result\n\t\t\t.replace(/<\\/(script|style)/gi, '<\\\\/$1')\n\t\t\t.replace(/<!--/g, json ? '\\\\u003C!--' : '\\\\x3C!--');\n\t}\n\treturn result;\n};\n\njsesc.version = '2.5.2';\n\nmodule.exports = jsesc;\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AnyTypeAnnotation = AnyTypeAnnotation;\nexports.ArrayTypeAnnotation = ArrayTypeAnnotation;\nexports.BooleanLiteralTypeAnnotation = BooleanLiteralTypeAnnotation;\nexports.BooleanTypeAnnotation = BooleanTypeAnnotation;\nexports.DeclareClass = DeclareClass;\nexports.DeclareExportAllDeclaration = DeclareExportAllDeclaration;\nexports.DeclareExportDeclaration = DeclareExportDeclaration;\nexports.DeclareFunction = DeclareFunction;\nexports.DeclareInterface = DeclareInterface;\nexports.DeclareModule = DeclareModule;\nexports.DeclareModuleExports = DeclareModuleExports;\nexports.DeclareOpaqueType = DeclareOpaqueType;\nexports.DeclareTypeAlias = DeclareTypeAlias;\nexports.DeclareVariable = DeclareVariable;\nexports.DeclaredPredicate = DeclaredPredicate;\nexports.EmptyTypeAnnotation = EmptyTypeAnnotation;\nexports.EnumBooleanBody = EnumBooleanBody;\nexports.EnumBooleanMember = EnumBooleanMember;\nexports.EnumDeclaration = EnumDeclaration;\nexports.EnumDefaultedMember = EnumDefaultedMember;\nexports.EnumNumberBody = EnumNumberBody;\nexports.EnumNumberMember = EnumNumberMember;\nexports.EnumStringBody = EnumStringBody;\nexports.EnumStringMember = EnumStringMember;\nexports.EnumSymbolBody = EnumSymbolBody;\nexports.ExistsTypeAnnotation = ExistsTypeAnnotation;\nexports.FunctionTypeAnnotation = FunctionTypeAnnotation;\nexports.FunctionTypeParam = FunctionTypeParam;\nexports.IndexedAccessType = IndexedAccessType;\nexports.InferredPredicate = InferredPredicate;\nexports.InterfaceDeclaration = InterfaceDeclaration;\nexports.GenericTypeAnnotation = exports.ClassImplements = exports.InterfaceExtends = InterfaceExtends;\nexports.InterfaceTypeAnnotation = InterfaceTypeAnnotation;\nexports.IntersectionTypeAnnotation = IntersectionTypeAnnotation;\nexports.MixedTypeAnnotation = MixedTypeAnnotation;\nexports.NullLiteralTypeAnnotation = NullLiteralTypeAnnotation;\nexports.NullableTypeAnnotation = NullableTypeAnnotation;\nObject.defineProperty(exports, \"NumberLiteralTypeAnnotation\", {\n  enumerable: true,\n  get: function () {\n    return _types2.NumericLiteral;\n  }\n});\nexports.NumberTypeAnnotation = NumberTypeAnnotation;\nexports.ObjectTypeAnnotation = ObjectTypeAnnotation;\nexports.ObjectTypeCallProperty = ObjectTypeCallProperty;\nexports.ObjectTypeIndexer = ObjectTypeIndexer;\nexports.ObjectTypeInternalSlot = ObjectTypeInternalSlot;\nexports.ObjectTypeProperty = ObjectTypeProperty;\nexports.ObjectTypeSpreadProperty = ObjectTypeSpreadProperty;\nexports.OpaqueType = OpaqueType;\nexports.OptionalIndexedAccessType = OptionalIndexedAccessType;\nexports.QualifiedTypeIdentifier = QualifiedTypeIdentifier;\nObject.defineProperty(exports, \"StringLiteralTypeAnnotation\", {\n  enumerable: true,\n  get: function () {\n    return _types2.StringLiteral;\n  }\n});\nexports.StringTypeAnnotation = StringTypeAnnotation;\nexports.SymbolTypeAnnotation = SymbolTypeAnnotation;\nexports.ThisTypeAnnotation = ThisTypeAnnotation;\nexports.TupleTypeAnnotation = TupleTypeAnnotation;\nexports.TypeAlias = TypeAlias;\nexports.TypeAnnotation = TypeAnnotation;\nexports.TypeCastExpression = TypeCastExpression;\nexports.TypeParameter = TypeParameter;\nexports.TypeParameterDeclaration = exports.TypeParameterInstantiation = TypeParameterInstantiation;\nexports.TypeofTypeAnnotation = TypeofTypeAnnotation;\nexports.UnionTypeAnnotation = UnionTypeAnnotation;\nexports.Variance = Variance;\nexports.VoidTypeAnnotation = VoidTypeAnnotation;\nexports._interfaceish = _interfaceish;\nexports._variance = _variance;\nvar _t = require(\"@babel/types\");\nvar _modules = require(\"./modules.js\");\nvar _types2 = require(\"./types.js\");\nconst {\n  isDeclareExportDeclaration,\n  isStatement\n} = _t;\nfunction AnyTypeAnnotation() {\n  this.word(\"any\");\n}\nfunction ArrayTypeAnnotation(node) {\n  this.print(node.elementType, node, true);\n  this.tokenChar(91);\n  this.tokenChar(93);\n}\nfunction BooleanTypeAnnotation() {\n  this.word(\"boolean\");\n}\nfunction BooleanLiteralTypeAnnotation(node) {\n  this.word(node.value ? \"true\" : \"false\");\n}\nfunction NullLiteralTypeAnnotation() {\n  this.word(\"null\");\n}\nfunction DeclareClass(node, parent) {\n  if (!isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.word(\"class\");\n  this.space();\n  this._interfaceish(node);\n}\nfunction DeclareFunction(node, parent) {\n  if (!isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.word(\"function\");\n  this.space();\n  this.print(node.id, node);\n  this.print(node.id.typeAnnotation.typeAnnotation, node);\n  if (node.predicate) {\n    this.space();\n    this.print(node.predicate, node);\n  }\n  this.semicolon();\n}\nfunction InferredPredicate() {\n  this.tokenChar(37);\n  this.word(\"checks\");\n}\nfunction DeclaredPredicate(node) {\n  this.tokenChar(37);\n  this.word(\"checks\");\n  this.tokenChar(40);\n  this.print(node.value, node);\n  this.tokenChar(41);\n}\nfunction DeclareInterface(node) {\n  this.word(\"declare\");\n  this.space();\n  this.InterfaceDeclaration(node);\n}\nfunction DeclareModule(node) {\n  this.word(\"declare\");\n  this.space();\n  this.word(\"module\");\n  this.space();\n  this.print(node.id, node);\n  this.space();\n  this.print(node.body, node);\n}\nfunction DeclareModuleExports(node) {\n  this.word(\"declare\");\n  this.space();\n  this.word(\"module\");\n  this.tokenChar(46);\n  this.word(\"exports\");\n  this.print(node.typeAnnotation, node);\n}\nfunction DeclareTypeAlias(node) {\n  this.word(\"declare\");\n  this.space();\n  this.TypeAlias(node);\n}\nfunction DeclareOpaqueType(node, parent) {\n  if (!isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.OpaqueType(node);\n}\nfunction DeclareVariable(node, parent) {\n  if (!isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.word(\"var\");\n  this.space();\n  this.print(node.id, node);\n  this.print(node.id.typeAnnotation, node);\n  this.semicolon();\n}\nfunction DeclareExportDeclaration(node) {\n  this.word(\"declare\");\n  this.space();\n  this.word(\"export\");\n  this.space();\n  if (node.default) {\n    this.word(\"default\");\n    this.space();\n  }\n  FlowExportDeclaration.call(this, node);\n}\nfunction DeclareExportAllDeclaration(node) {\n  this.word(\"declare\");\n  this.space();\n  _modules.ExportAllDeclaration.call(this, node);\n}\nfunction EnumDeclaration(node) {\n  const {\n    id,\n    body\n  } = node;\n  this.word(\"enum\");\n  this.space();\n  this.print(id, node);\n  this.print(body, node);\n}\nfunction enumExplicitType(context, name, hasExplicitType) {\n  if (hasExplicitType) {\n    context.space();\n    context.word(\"of\");\n    context.space();\n    context.word(name);\n  }\n  context.space();\n}\nfunction enumBody(context, node) {\n  const {\n    members\n  } = node;\n  context.token(\"{\");\n  context.indent();\n  context.newline();\n  for (const member of members) {\n    context.print(member, node);\n    context.newline();\n  }\n  if (node.hasUnknownMembers) {\n    context.token(\"...\");\n    context.newline();\n  }\n  context.dedent();\n  context.token(\"}\");\n}\nfunction EnumBooleanBody(node) {\n  const {\n    explicitType\n  } = node;\n  enumExplicitType(this, \"boolean\", explicitType);\n  enumBody(this, node);\n}\nfunction EnumNumberBody(node) {\n  const {\n    explicitType\n  } = node;\n  enumExplicitType(this, \"number\", explicitType);\n  enumBody(this, node);\n}\nfunction EnumStringBody(node) {\n  const {\n    explicitType\n  } = node;\n  enumExplicitType(this, \"string\", explicitType);\n  enumBody(this, node);\n}\nfunction EnumSymbolBody(node) {\n  enumExplicitType(this, \"symbol\", true);\n  enumBody(this, node);\n}\nfunction EnumDefaultedMember(node) {\n  const {\n    id\n  } = node;\n  this.print(id, node);\n  this.tokenChar(44);\n}\nfunction enumInitializedMember(context, node) {\n  const {\n    id,\n    init\n  } = node;\n  context.print(id, node);\n  context.space();\n  context.token(\"=\");\n  context.space();\n  context.print(init, node);\n  context.token(\",\");\n}\nfunction EnumBooleanMember(node) {\n  enumInitializedMember(this, node);\n}\nfunction EnumNumberMember(node) {\n  enumInitializedMember(this, node);\n}\nfunction EnumStringMember(node) {\n  enumInitializedMember(this, node);\n}\nfunction FlowExportDeclaration(node) {\n  if (node.declaration) {\n    const declar = node.declaration;\n    this.print(declar, node);\n    if (!isStatement(declar)) this.semicolon();\n  } else {\n    this.tokenChar(123);\n    if (node.specifiers.length) {\n      this.space();\n      this.printList(node.specifiers, node);\n      this.space();\n    }\n    this.tokenChar(125);\n    if (node.source) {\n      this.space();\n      this.word(\"from\");\n      this.space();\n      this.print(node.source, node);\n    }\n    this.semicolon();\n  }\n}\nfunction ExistsTypeAnnotation() {\n  this.tokenChar(42);\n}\nfunction FunctionTypeAnnotation(node, parent) {\n  this.print(node.typeParameters, node);\n  this.tokenChar(40);\n  if (node.this) {\n    this.word(\"this\");\n    this.tokenChar(58);\n    this.space();\n    this.print(node.this.typeAnnotation, node);\n    if (node.params.length || node.rest) {\n      this.tokenChar(44);\n      this.space();\n    }\n  }\n  this.printList(node.params, node);\n  if (node.rest) {\n    if (node.params.length) {\n      this.tokenChar(44);\n      this.space();\n    }\n    this.token(\"...\");\n    this.print(node.rest, node);\n  }\n  this.tokenChar(41);\n  const type = parent == null ? void 0 : parent.type;\n  if (type != null && (type === \"ObjectTypeCallProperty\" || type === \"ObjectTypeInternalSlot\" || type === \"DeclareFunction\" || type === \"ObjectTypeProperty\" && parent.method)) {\n    this.tokenChar(58);\n  } else {\n    this.space();\n    this.token(\"=>\");\n  }\n  this.space();\n  this.print(node.returnType, node);\n}\nfunction FunctionTypeParam(node) {\n  this.print(node.name, node);\n  if (node.optional) this.tokenChar(63);\n  if (node.name) {\n    this.tokenChar(58);\n    this.space();\n  }\n  this.print(node.typeAnnotation, node);\n}\nfunction InterfaceExtends(node) {\n  this.print(node.id, node);\n  this.print(node.typeParameters, node, true);\n}\nfunction _interfaceish(node) {\n  var _node$extends;\n  this.print(node.id, node);\n  this.print(node.typeParameters, node);\n  if ((_node$extends = node.extends) != null && _node$extends.length) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.printList(node.extends, node);\n  }\n  if (node.type === \"DeclareClass\") {\n    var _node$mixins, _node$implements;\n    if ((_node$mixins = node.mixins) != null && _node$mixins.length) {\n      this.space();\n      this.word(\"mixins\");\n      this.space();\n      this.printList(node.mixins, node);\n    }\n    if ((_node$implements = node.implements) != null && _node$implements.length) {\n      this.space();\n      this.word(\"implements\");\n      this.space();\n      this.printList(node.implements, node);\n    }\n  }\n  this.space();\n  this.print(node.body, node);\n}\nfunction _variance(node) {\n  var _node$variance;\n  const kind = (_node$variance = node.variance) == null ? void 0 : _node$variance.kind;\n  if (kind != null) {\n    if (kind === \"plus\") {\n      this.tokenChar(43);\n    } else if (kind === \"minus\") {\n      this.tokenChar(45);\n    }\n  }\n}\nfunction InterfaceDeclaration(node) {\n  this.word(\"interface\");\n  this.space();\n  this._interfaceish(node);\n}\nfunction andSeparator() {\n  this.space();\n  this.tokenChar(38);\n  this.space();\n}\nfunction InterfaceTypeAnnotation(node) {\n  var _node$extends2;\n  this.word(\"interface\");\n  if ((_node$extends2 = node.extends) != null && _node$extends2.length) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.printList(node.extends, node);\n  }\n  this.space();\n  this.print(node.body, node);\n}\nfunction IntersectionTypeAnnotation(node) {\n  this.printJoin(node.types, node, {\n    separator: andSeparator\n  });\n}\nfunction MixedTypeAnnotation() {\n  this.word(\"mixed\");\n}\nfunction EmptyTypeAnnotation() {\n  this.word(\"empty\");\n}\nfunction NullableTypeAnnotation(node) {\n  this.tokenChar(63);\n  this.print(node.typeAnnotation, node);\n}\nfunction NumberTypeAnnotation() {\n  this.word(\"number\");\n}\nfunction StringTypeAnnotation() {\n  this.word(\"string\");\n}\nfunction ThisTypeAnnotation() {\n  this.word(\"this\");\n}\nfunction TupleTypeAnnotation(node) {\n  this.tokenChar(91);\n  this.printList(node.types, node);\n  this.tokenChar(93);\n}\nfunction TypeofTypeAnnotation(node) {\n  this.word(\"typeof\");\n  this.space();\n  this.print(node.argument, node);\n}\nfunction TypeAlias(node) {\n  this.word(\"type\");\n  this.space();\n  this.print(node.id, node);\n  this.print(node.typeParameters, node);\n  this.space();\n  this.tokenChar(61);\n  this.space();\n  this.print(node.right, node);\n  this.semicolon();\n}\nfunction TypeAnnotation(node) {\n  this.tokenChar(58);\n  this.space();\n  if (node.optional) this.tokenChar(63);\n  this.print(node.typeAnnotation, node);\n}\nfunction TypeParameterInstantiation(node) {\n  this.tokenChar(60);\n  this.printList(node.params, node, {});\n  this.tokenChar(62);\n}\nfunction TypeParameter(node) {\n  this._variance(node);\n  this.word(node.name);\n  if (node.bound) {\n    this.print(node.bound, node);\n  }\n  if (node.default) {\n    this.space();\n    this.tokenChar(61);\n    this.space();\n    this.print(node.default, node);\n  }\n}\nfunction OpaqueType(node) {\n  this.word(\"opaque\");\n  this.space();\n  this.word(\"type\");\n  this.space();\n  this.print(node.id, node);\n  this.print(node.typeParameters, node);\n  if (node.supertype) {\n    this.tokenChar(58);\n    this.space();\n    this.print(node.supertype, node);\n  }\n  if (node.impltype) {\n    this.space();\n    this.tokenChar(61);\n    this.space();\n    this.print(node.impltype, node);\n  }\n  this.semicolon();\n}\nfunction ObjectTypeAnnotation(node) {\n  if (node.exact) {\n    this.token(\"{|\");\n  } else {\n    this.tokenChar(123);\n  }\n  const props = [...node.properties, ...(node.callProperties || []), ...(node.indexers || []), ...(node.internalSlots || [])];\n  if (props.length) {\n    this.newline();\n    this.space();\n    this.printJoin(props, node, {\n      addNewlines(leading) {\n        if (leading && !props[0]) return 1;\n      },\n      indent: true,\n      statement: true,\n      iterator: () => {\n        if (props.length !== 1 || node.inexact) {\n          this.tokenChar(44);\n          this.space();\n        }\n      }\n    });\n    this.space();\n  }\n  if (node.inexact) {\n    this.indent();\n    this.token(\"...\");\n    if (props.length) {\n      this.newline();\n    }\n    this.dedent();\n  }\n  if (node.exact) {\n    this.token(\"|}\");\n  } else {\n    this.tokenChar(125);\n  }\n}\nfunction ObjectTypeInternalSlot(node) {\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  this.tokenChar(91);\n  this.tokenChar(91);\n  this.print(node.id, node);\n  this.tokenChar(93);\n  this.tokenChar(93);\n  if (node.optional) this.tokenChar(63);\n  if (!node.method) {\n    this.tokenChar(58);\n    this.space();\n  }\n  this.print(node.value, node);\n}\nfunction ObjectTypeCallProperty(node) {\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  this.print(node.value, node);\n}\nfunction ObjectTypeIndexer(node) {\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  this._variance(node);\n  this.tokenChar(91);\n  if (node.id) {\n    this.print(node.id, node);\n    this.tokenChar(58);\n    this.space();\n  }\n  this.print(node.key, node);\n  this.tokenChar(93);\n  this.tokenChar(58);\n  this.space();\n  this.print(node.value, node);\n}\nfunction ObjectTypeProperty(node) {\n  if (node.proto) {\n    this.word(\"proto\");\n    this.space();\n  }\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  if (node.kind === \"get\" || node.kind === \"set\") {\n    this.word(node.kind);\n    this.space();\n  }\n  this._variance(node);\n  this.print(node.key, node);\n  if (node.optional) this.tokenChar(63);\n  if (!node.method) {\n    this.tokenChar(58);\n    this.space();\n  }\n  this.print(node.value, node);\n}\nfunction ObjectTypeSpreadProperty(node) {\n  this.token(\"...\");\n  this.print(node.argument, node);\n}\nfunction QualifiedTypeIdentifier(node) {\n  this.print(node.qualification, node);\n  this.tokenChar(46);\n  this.print(node.id, node);\n}\nfunction SymbolTypeAnnotation() {\n  this.word(\"symbol\");\n}\nfunction orSeparator() {\n  this.space();\n  this.tokenChar(124);\n  this.space();\n}\nfunction UnionTypeAnnotation(node) {\n  this.printJoin(node.types, node, {\n    separator: orSeparator\n  });\n}\nfunction TypeCastExpression(node) {\n  this.tokenChar(40);\n  this.print(node.expression, node);\n  this.print(node.typeAnnotation, node);\n  this.tokenChar(41);\n}\nfunction Variance(node) {\n  if (node.kind === \"plus\") {\n    this.tokenChar(43);\n  } else {\n    this.tokenChar(45);\n  }\n}\nfunction VoidTypeAnnotation() {\n  this.word(\"void\");\n}\nfunction IndexedAccessType(node) {\n  this.print(node.objectType, node, true);\n  this.tokenChar(91);\n  this.print(node.indexType, node);\n  this.tokenChar(93);\n}\nfunction OptionalIndexedAccessType(node) {\n  this.print(node.objectType, node);\n  if (node.optional) {\n    this.token(\"?.\");\n  }\n  this.tokenChar(91);\n  this.print(node.indexType, node);\n  this.tokenChar(93);\n}\n\n//# sourceMappingURL=flow.js.map\n","import type Printer from \"../printer.ts\";\nimport { isDeclareExportDeclaration, isStatement } from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport { ExportAllDeclaration } from \"./modules.ts\";\n\nexport function AnyTypeAnnotation(this: Printer) {\n  this.word(\"any\");\n}\n\nexport function ArrayTypeAnnotation(\n  this: Printer,\n  node: t.ArrayTypeAnnotation,\n) {\n  this.print(node.elementType, node, true);\n  this.token(\"[\");\n  this.token(\"]\");\n}\n\nexport function BooleanTypeAnnotation(this: Printer) {\n  this.word(\"boolean\");\n}\n\nexport function BooleanLiteralTypeAnnotation(\n  this: Printer,\n  node: t.BooleanLiteralTypeAnnotation,\n) {\n  this.word(node.value ? \"true\" : \"false\");\n}\n\nexport function NullLiteralTypeAnnotation(this: Printer) {\n  this.word(\"null\");\n}\n\nexport function DeclareClass(\n  this: Printer,\n  node: t.DeclareClass,\n  parent: t.Node,\n) {\n  if (!isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.word(\"class\");\n  this.space();\n  this._interfaceish(node);\n}\n\nexport function DeclareFunction(\n  this: Printer,\n  node: t.DeclareFunction,\n  parent: t.Node,\n) {\n  if (!isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.word(\"function\");\n  this.space();\n  this.print(node.id, node);\n  // @ts-ignore(Babel 7 vs Babel 8) TODO(Babel 8) Remove this comment, since we'll remove the Noop node\n  this.print(node.id.typeAnnotation.typeAnnotation, node);\n\n  if (node.predicate) {\n    this.space();\n    this.print(node.predicate, node);\n  }\n\n  this.semicolon();\n}\n\nexport function InferredPredicate(this: Printer) {\n  this.token(\"%\");\n  this.word(\"checks\");\n}\n\nexport function DeclaredPredicate(this: Printer, node: t.DeclaredPredicate) {\n  this.token(\"%\");\n  this.word(\"checks\");\n  this.token(\"(\");\n  this.print(node.value, node);\n  this.token(\")\");\n}\n\nexport function DeclareInterface(this: Printer, node: t.DeclareInterface) {\n  this.word(\"declare\");\n  this.space();\n  this.InterfaceDeclaration(node);\n}\n\nexport function DeclareModule(this: Printer, node: t.DeclareModule) {\n  this.word(\"declare\");\n  this.space();\n  this.word(\"module\");\n  this.space();\n  this.print(node.id, node);\n  this.space();\n  this.print(node.body, node);\n}\n\nexport function DeclareModuleExports(\n  this: Printer,\n  node: t.DeclareModuleExports,\n) {\n  this.word(\"declare\");\n  this.space();\n  this.word(\"module\");\n  this.token(\".\");\n  this.word(\"exports\");\n  this.print(node.typeAnnotation, node);\n}\n\nexport function DeclareTypeAlias(this: Printer, node: t.DeclareTypeAlias) {\n  this.word(\"declare\");\n  this.space();\n  this.TypeAlias(node);\n}\n\nexport function DeclareOpaqueType(\n  this: Printer,\n  node: t.DeclareOpaqueType,\n  parent: t.Node,\n) {\n  if (!isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.OpaqueType(node);\n}\n\nexport function DeclareVariable(\n  this: Printer,\n  node: t.DeclareVariable,\n  parent: t.Node,\n) {\n  if (!isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.word(\"var\");\n  this.space();\n  this.print(node.id, node);\n  this.print(node.id.typeAnnotation, node);\n  this.semicolon();\n}\n\nexport function DeclareExportDeclaration(\n  this: Printer,\n  node: t.DeclareExportDeclaration,\n) {\n  this.word(\"declare\");\n  this.space();\n  this.word(\"export\");\n  this.space();\n  if (node.default) {\n    this.word(\"default\");\n    this.space();\n  }\n\n  FlowExportDeclaration.call(this, node);\n}\n\nexport function DeclareExportAllDeclaration(\n  this: Printer,\n  node: t.DeclareExportAllDeclaration,\n) {\n  this.word(\"declare\");\n  this.space();\n  ExportAllDeclaration.call(this, node);\n}\n\nexport function EnumDeclaration(this: Printer, node: t.EnumDeclaration) {\n  const { id, body } = node;\n  this.word(\"enum\");\n  this.space();\n  this.print(id, node);\n  this.print(body, node);\n}\n\nfunction enumExplicitType(\n  context: Printer,\n  name: string,\n  hasExplicitType: boolean,\n) {\n  if (hasExplicitType) {\n    context.space();\n    context.word(\"of\");\n    context.space();\n    context.word(name);\n  }\n  context.space();\n}\n\nfunction enumBody(context: Printer, node: t.EnumBody) {\n  const { members } = node;\n  context.token(\"{\");\n  context.indent();\n  context.newline();\n  for (const member of members) {\n    context.print(member, node);\n    context.newline();\n  }\n  if (node.hasUnknownMembers) {\n    context.token(\"...\");\n    context.newline();\n  }\n  context.dedent();\n  context.token(\"}\");\n}\n\nexport function EnumBooleanBody(this: Printer, node: t.EnumBooleanBody) {\n  const { explicitType } = node;\n  enumExplicitType(this, \"boolean\", explicitType);\n  enumBody(this, node);\n}\n\nexport function EnumNumberBody(this: Printer, node: t.EnumNumberBody) {\n  const { explicitType } = node;\n  enumExplicitType(this, \"number\", explicitType);\n  enumBody(this, node);\n}\n\nexport function EnumStringBody(this: Printer, node: t.EnumStringBody) {\n  const { explicitType } = node;\n  enumExplicitType(this, \"string\", explicitType);\n  enumBody(this, node);\n}\n\nexport function EnumSymbolBody(this: Printer, node: t.EnumSymbolBody) {\n  enumExplicitType(this, \"symbol\", true);\n  enumBody(this, node);\n}\n\nexport function EnumDefaultedMember(\n  this: Printer,\n  node: t.EnumDefaultedMember,\n) {\n  const { id } = node;\n  this.print(id, node);\n  this.token(\",\");\n}\n\nfunction enumInitializedMember(\n  context: Printer,\n  node: t.EnumBooleanMember | t.EnumNumberMember | t.EnumStringMember,\n) {\n  const { id, init } = node;\n  context.print(id, node);\n  context.space();\n  context.token(\"=\");\n  context.space();\n  context.print(init, node);\n  context.token(\",\");\n}\n\nexport function EnumBooleanMember(this: Printer, node: t.EnumBooleanMember) {\n  enumInitializedMember(this, node);\n}\n\nexport function EnumNumberMember(this: Printer, node: t.EnumNumberMember) {\n  enumInitializedMember(this, node);\n}\n\nexport function EnumStringMember(this: Printer, node: t.EnumStringMember) {\n  enumInitializedMember(this, node);\n}\n\nfunction FlowExportDeclaration(\n  this: Printer,\n  node: t.DeclareExportDeclaration,\n) {\n  if (node.declaration) {\n    const declar = node.declaration;\n    this.print(declar, node);\n    if (!isStatement(declar)) this.semicolon();\n  } else {\n    this.token(\"{\");\n    if (node.specifiers.length) {\n      this.space();\n      this.printList(node.specifiers, node);\n      this.space();\n    }\n    this.token(\"}\");\n\n    if (node.source) {\n      this.space();\n      this.word(\"from\");\n      this.space();\n      this.print(node.source, node);\n    }\n\n    this.semicolon();\n  }\n}\n\nexport function ExistsTypeAnnotation(this: Printer) {\n  this.token(\"*\");\n}\n\nexport function FunctionTypeAnnotation(\n  this: Printer,\n  node: t.FunctionTypeAnnotation,\n  parent?: t.Node,\n) {\n  this.print(node.typeParameters, node);\n  this.token(\"(\");\n\n  if (node.this) {\n    this.word(\"this\");\n    this.token(\":\");\n    this.space();\n    this.print(node.this.typeAnnotation, node);\n    if (node.params.length || node.rest) {\n      this.token(\",\");\n      this.space();\n    }\n  }\n\n  this.printList(node.params, node);\n\n  if (node.rest) {\n    if (node.params.length) {\n      this.token(\",\");\n      this.space();\n    }\n    this.token(\"...\");\n    this.print(node.rest, node);\n  }\n\n  this.token(\")\");\n\n  // this node type is overloaded, not sure why but it makes it EXTREMELY annoying\n\n  const type = parent?.type;\n  if (\n    type != null &&\n    (type === \"ObjectTypeCallProperty\" ||\n      type === \"ObjectTypeInternalSlot\" ||\n      type === \"DeclareFunction\" ||\n      (type === \"ObjectTypeProperty\" && parent.method))\n  ) {\n    this.token(\":\");\n  } else {\n    this.space();\n    this.token(\"=>\");\n  }\n\n  this.space();\n  this.print(node.returnType, node);\n}\n\nexport function FunctionTypeParam(this: Printer, node: t.FunctionTypeParam) {\n  this.print(node.name, node);\n  if (node.optional) this.token(\"?\");\n  if (node.name) {\n    this.token(\":\");\n    this.space();\n  }\n  this.print(node.typeAnnotation, node);\n}\n\nexport function InterfaceExtends(this: Printer, node: t.InterfaceExtends) {\n  this.print(node.id, node);\n  this.print(node.typeParameters, node, true);\n}\n\nexport {\n  InterfaceExtends as ClassImplements,\n  InterfaceExtends as GenericTypeAnnotation,\n};\n\nexport function _interfaceish(\n  this: Printer,\n  node: t.InterfaceDeclaration | t.DeclareInterface | t.DeclareClass,\n) {\n  this.print(node.id, node);\n  this.print(node.typeParameters, node);\n  if (node.extends?.length) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.printList(node.extends, node);\n  }\n  if (node.type === \"DeclareClass\") {\n    if (node.mixins?.length) {\n      this.space();\n      this.word(\"mixins\");\n      this.space();\n      this.printList(node.mixins, node);\n    }\n    if (node.implements?.length) {\n      this.space();\n      this.word(\"implements\");\n      this.space();\n      this.printList(node.implements, node);\n    }\n  }\n  this.space();\n  this.print(node.body, node);\n}\n\nexport function _variance(\n  this: Printer,\n  node:\n    | t.TypeParameter\n    | t.ObjectTypeIndexer\n    | t.ObjectTypeProperty\n    | t.ClassProperty\n    | t.ClassPrivateProperty\n    | t.ClassAccessorProperty,\n) {\n  const kind = node.variance?.kind;\n  if (kind != null) {\n    if (kind === \"plus\") {\n      this.token(\"+\");\n    } else if (kind === \"minus\") {\n      this.token(\"-\");\n    }\n  }\n}\n\nexport function InterfaceDeclaration(\n  this: Printer,\n  node: t.InterfaceDeclaration | t.DeclareInterface,\n) {\n  this.word(\"interface\");\n  this.space();\n  this._interfaceish(node);\n}\n\nfunction andSeparator(this: Printer) {\n  this.space();\n  this.token(\"&\");\n  this.space();\n}\n\nexport function InterfaceTypeAnnotation(\n  this: Printer,\n  node: t.InterfaceTypeAnnotation,\n) {\n  this.word(\"interface\");\n  if (node.extends?.length) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.printList(node.extends, node);\n  }\n  this.space();\n  this.print(node.body, node);\n}\n\nexport function IntersectionTypeAnnotation(\n  this: Printer,\n  node: t.IntersectionTypeAnnotation,\n) {\n  this.printJoin(node.types, node, { separator: andSeparator });\n}\n\nexport function MixedTypeAnnotation(this: Printer) {\n  this.word(\"mixed\");\n}\n\nexport function EmptyTypeAnnotation(this: Printer) {\n  this.word(\"empty\");\n}\n\nexport function NullableTypeAnnotation(\n  this: Printer,\n  node: t.NullableTypeAnnotation,\n) {\n  this.token(\"?\");\n  this.print(node.typeAnnotation, node);\n}\n\nexport {\n  NumericLiteral as NumberLiteralTypeAnnotation,\n  StringLiteral as StringLiteralTypeAnnotation,\n} from \"./types.ts\";\n\nexport function NumberTypeAnnotation(this: Printer) {\n  this.word(\"number\");\n}\n\nexport function StringTypeAnnotation(this: Printer) {\n  this.word(\"string\");\n}\n\nexport function ThisTypeAnnotation(this: Printer) {\n  this.word(\"this\");\n}\n\nexport function TupleTypeAnnotation(\n  this: Printer,\n  node: t.TupleTypeAnnotation,\n) {\n  this.token(\"[\");\n  this.printList(node.types, node);\n  this.token(\"]\");\n}\n\nexport function TypeofTypeAnnotation(\n  this: Printer,\n  node: t.TypeofTypeAnnotation,\n) {\n  this.word(\"typeof\");\n  this.space();\n  this.print(node.argument, node);\n}\n\nexport function TypeAlias(\n  this: Printer,\n  node: t.TypeAlias | t.DeclareTypeAlias,\n) {\n  this.word(\"type\");\n  this.space();\n  this.print(node.id, node);\n  this.print(node.typeParameters, node);\n  this.space();\n  this.token(\"=\");\n  this.space();\n  this.print(node.right, node);\n  this.semicolon();\n}\n\nexport function TypeAnnotation(this: Printer, node: t.TypeAnnotation) {\n  this.token(\":\");\n  this.space();\n  // @ts-expect-error todo(flow->ts) can this be removed? `.optional` looks to be not existing property\n  if (node.optional) this.token(\"?\");\n  this.print(node.typeAnnotation, node);\n}\n\nexport function TypeParameterInstantiation(\n  this: Printer,\n  node: t.TypeParameterInstantiation,\n): void {\n  this.token(\"<\");\n  this.printList(node.params, node, {});\n  this.token(\">\");\n}\n\nexport { TypeParameterInstantiation as TypeParameterDeclaration };\n\nexport function TypeParameter(this: Printer, node: t.TypeParameter) {\n  this._variance(node);\n\n  this.word(node.name);\n\n  if (node.bound) {\n    this.print(node.bound, node);\n  }\n\n  if (node.default) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(node.default, node);\n  }\n}\n\nexport function OpaqueType(\n  this: Printer,\n  node: t.OpaqueType | t.DeclareOpaqueType,\n) {\n  this.word(\"opaque\");\n  this.space();\n  this.word(\"type\");\n  this.space();\n  this.print(node.id, node);\n  this.print(node.typeParameters, node);\n  if (node.supertype) {\n    this.token(\":\");\n    this.space();\n    this.print(node.supertype, node);\n  }\n\n  if (node.impltype) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(node.impltype, node);\n  }\n  this.semicolon();\n}\n\nexport function ObjectTypeAnnotation(\n  this: Printer,\n  node: t.ObjectTypeAnnotation,\n) {\n  if (node.exact) {\n    this.token(\"{|\");\n  } else {\n    this.token(\"{\");\n  }\n\n  // TODO: remove the array fallbacks and instead enforce the types to require an array\n  const props = [\n    ...node.properties,\n    ...(node.callProperties || []),\n    ...(node.indexers || []),\n    ...(node.internalSlots || []),\n  ];\n\n  if (props.length) {\n    this.newline();\n\n    this.space();\n\n    this.printJoin(props, node, {\n      addNewlines(leading) {\n        if (leading && !props[0]) return 1;\n      },\n      indent: true,\n      statement: true,\n      iterator: () => {\n        if (props.length !== 1 || node.inexact) {\n          this.token(\",\");\n          this.space();\n        }\n      },\n    });\n\n    this.space();\n  }\n\n  if (node.inexact) {\n    this.indent();\n    this.token(\"...\");\n    if (props.length) {\n      this.newline();\n    }\n    this.dedent();\n  }\n\n  if (node.exact) {\n    this.token(\"|}\");\n  } else {\n    this.token(\"}\");\n  }\n}\n\nexport function ObjectTypeInternalSlot(\n  this: Printer,\n  node: t.ObjectTypeInternalSlot,\n) {\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  this.token(\"[\");\n  this.token(\"[\");\n  this.print(node.id, node);\n  this.token(\"]\");\n  this.token(\"]\");\n  if (node.optional) this.token(\"?\");\n  if (!node.method) {\n    this.token(\":\");\n    this.space();\n  }\n  this.print(node.value, node);\n}\n\nexport function ObjectTypeCallProperty(\n  this: Printer,\n  node: t.ObjectTypeCallProperty,\n) {\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  this.print(node.value, node);\n}\n\nexport function ObjectTypeIndexer(this: Printer, node: t.ObjectTypeIndexer) {\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  this._variance(node);\n  this.token(\"[\");\n  if (node.id) {\n    this.print(node.id, node);\n    this.token(\":\");\n    this.space();\n  }\n  this.print(node.key, node);\n  this.token(\"]\");\n  this.token(\":\");\n  this.space();\n  this.print(node.value, node);\n}\n\nexport function ObjectTypeProperty(this: Printer, node: t.ObjectTypeProperty) {\n  if (node.proto) {\n    this.word(\"proto\");\n    this.space();\n  }\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  if (node.kind === \"get\" || node.kind === \"set\") {\n    this.word(node.kind);\n    this.space();\n  }\n  this._variance(node);\n  this.print(node.key, node);\n  if (node.optional) this.token(\"?\");\n  if (!node.method) {\n    this.token(\":\");\n    this.space();\n  }\n  this.print(node.value, node);\n}\n\nexport function ObjectTypeSpreadProperty(\n  this: Printer,\n  node: t.ObjectTypeSpreadProperty,\n) {\n  this.token(\"...\");\n  this.print(node.argument, node);\n}\n\nexport function QualifiedTypeIdentifier(\n  this: Printer,\n  node: t.QualifiedTypeIdentifier,\n) {\n  this.print(node.qualification, node);\n  this.token(\".\");\n  this.print(node.id, node);\n}\n\nexport function SymbolTypeAnnotation(this: Printer) {\n  this.word(\"symbol\");\n}\n\nfunction orSeparator(this: Printer) {\n  this.space();\n  this.token(\"|\");\n  this.space();\n}\n\nexport function UnionTypeAnnotation(\n  this: Printer,\n  node: t.UnionTypeAnnotation,\n) {\n  this.printJoin(node.types, node, { separator: orSeparator });\n}\n\nexport function TypeCastExpression(this: Printer, node: t.TypeCastExpression) {\n  this.token(\"(\");\n  this.print(node.expression, node);\n  this.print(node.typeAnnotation, node);\n  this.token(\")\");\n}\n\nexport function Variance(this: Printer, node: t.Variance) {\n  if (node.kind === \"plus\") {\n    this.token(\"+\");\n  } else {\n    this.token(\"-\");\n  }\n}\n\nexport function VoidTypeAnnotation(this: Printer) {\n  this.word(\"void\");\n}\n\nexport function IndexedAccessType(this: Printer, node: t.IndexedAccessType) {\n  this.print(node.objectType, node, true);\n  this.token(\"[\");\n  this.print(node.indexType, node);\n  this.token(\"]\");\n}\n\nexport function OptionalIndexedAccessType(\n  this: Printer,\n  node: t.OptionalIndexedAccessType,\n) {\n  this.print(node.objectType, node);\n  if (node.optional) {\n    this.token(\"?.\");\n  }\n  this.token(\"[\");\n  this.print(node.indexType, node);\n  this.token(\"]\");\n}\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BlockStatement = BlockStatement;\nexports.Directive = Directive;\nexports.DirectiveLiteral = DirectiveLiteral;\nexports.File = File;\nexports.InterpreterDirective = InterpreterDirective;\nexports.Placeholder = Placeholder;\nexports.Program = Program;\nfunction File(node) {\n  if (node.program) {\n    this.print(node.program.interpreter, node);\n  }\n  this.print(node.program, node);\n}\nfunction Program(node) {\n  var _node$directives;\n  this.noIndentInnerCommentsHere();\n  this.printInnerComments();\n  const directivesLen = (_node$directives = node.directives) == null ? void 0 : _node$directives.length;\n  if (directivesLen) {\n    var _node$directives$trai;\n    const newline = node.body.length ? 2 : 1;\n    this.printSequence(node.directives, node, {\n      trailingCommentsLineOffset: newline\n    });\n    if (!((_node$directives$trai = node.directives[directivesLen - 1].trailingComments) != null && _node$directives$trai.length)) {\n      this.newline(newline);\n    }\n  }\n  this.printSequence(node.body, node);\n}\nfunction BlockStatement(node) {\n  var _node$directives2;\n  this.tokenChar(123);\n  const directivesLen = (_node$directives2 = node.directives) == null ? void 0 : _node$directives2.length;\n  if (directivesLen) {\n    var _node$directives$trai2;\n    const newline = node.body.length ? 2 : 1;\n    this.printSequence(node.directives, node, {\n      indent: true,\n      trailingCommentsLineOffset: newline\n    });\n    if (!((_node$directives$trai2 = node.directives[directivesLen - 1].trailingComments) != null && _node$directives$trai2.length)) {\n      this.newline(newline);\n    }\n  }\n  this.printSequence(node.body, node, {\n    indent: true\n  });\n  this.rightBrace(node);\n}\nfunction Directive(node) {\n  this.print(node.value, node);\n  this.semicolon();\n}\nconst unescapedSingleQuoteRE = /(?:^|[^\\\\])(?:\\\\\\\\)*'/;\nconst unescapedDoubleQuoteRE = /(?:^|[^\\\\])(?:\\\\\\\\)*\"/;\nfunction DirectiveLiteral(node) {\n  const raw = this.getPossibleRaw(node);\n  if (!this.format.minified && raw !== undefined) {\n    this.token(raw);\n    return;\n  }\n  const {\n    value\n  } = node;\n  if (!unescapedDoubleQuoteRE.test(value)) {\n    this.token(`\"${value}\"`);\n  } else if (!unescapedSingleQuoteRE.test(value)) {\n    this.token(`'${value}'`);\n  } else {\n    throw new Error(\"Malformed AST: it is not possible to print a directive containing\" + \" both unescaped single and double quotes.\");\n  }\n}\nfunction InterpreterDirective(node) {\n  this.token(`#!${node.value}`);\n  this.newline(1, true);\n}\nfunction Placeholder(node) {\n  this.token(\"%%\");\n  this.print(node.name);\n  this.token(\"%%\");\n  if (node.expectedNode === \"Statement\") {\n    this.semicolon();\n  }\n}\n\n//# sourceMappingURL=base.js.map\n","import type Printer from \"../printer.ts\";\nimport type * as t from \"@babel/types\";\n\nexport function File(this: Printer, node: t.File) {\n  if (node.program) {\n    // Print this here to ensure that Program node 'leadingComments' still\n    // get printed after the hashbang.\n    this.print(node.program.interpreter, node);\n  }\n\n  this.print(node.program, node);\n}\n\nexport function Program(this: Printer, node: t.Program) {\n  // An empty Program doesn't have any inner tokens, so\n  // we must explicitly print its inner comments.\n  this.noIndentInnerCommentsHere();\n  this.printInnerComments();\n\n  const directivesLen = node.directives?.length;\n  if (directivesLen) {\n    const newline = node.body.length ? 2 : 1;\n    this.printSequence(node.directives, node, {\n      trailingCommentsLineOffset: newline,\n    });\n    if (!node.directives[directivesLen - 1].trailingComments?.length) {\n      this.newline(newline);\n    }\n  }\n\n  this.printSequence(node.body, node);\n}\n\nexport function BlockStatement(this: Printer, node: t.BlockStatement) {\n  this.token(\"{\");\n\n  const directivesLen = node.directives?.length;\n  if (directivesLen) {\n    const newline = node.body.length ? 2 : 1;\n    this.printSequence(node.directives, node, {\n      indent: true,\n      trailingCommentsLineOffset: newline,\n    });\n    if (!node.directives[directivesLen - 1].trailingComments?.length) {\n      this.newline(newline);\n    }\n  }\n\n  this.printSequence(node.body, node, { indent: true });\n\n  this.rightBrace(node);\n}\n\nexport function Directive(this: Printer, node: t.Directive) {\n  this.print(node.value, node);\n  this.semicolon();\n}\n\n// These regexes match an even number of \\ followed by a quote\nconst unescapedSingleQuoteRE = /(?:^|[^\\\\])(?:\\\\\\\\)*'/;\nconst unescapedDoubleQuoteRE = /(?:^|[^\\\\])(?:\\\\\\\\)*\"/;\n\nexport function DirectiveLiteral(this: Printer, node: t.DirectiveLiteral) {\n  const raw = this.getPossibleRaw(node);\n  if (!this.format.minified && raw !== undefined) {\n    this.token(raw);\n    return;\n  }\n\n  const { value } = node;\n\n  // NOTE: In directives we can't change escapings,\n  // because they change the behavior.\n  // e.g. \"us\\x65 strict\" (\\x65 is e) is not a \"use strict\" directive.\n\n  if (!unescapedDoubleQuoteRE.test(value)) {\n    this.token(`\"${value}\"`);\n  } else if (!unescapedSingleQuoteRE.test(value)) {\n    this.token(`'${value}'`);\n  } else {\n    throw new Error(\n      \"Malformed AST: it is not possible to print a directive containing\" +\n        \" both unescaped single and double quotes.\",\n    );\n  }\n}\n\nexport function InterpreterDirective(\n  this: Printer,\n  node: t.InterpreterDirective,\n) {\n  this.token(`#!${node.value}`);\n  this.newline(1, true);\n}\n\nexport function Placeholder(this: Printer, node: t.Placeholder) {\n  this.token(\"%%\");\n  this.print(node.name);\n  this.token(\"%%\");\n\n  if (node.expectedNode === \"Statement\") {\n    this.semicolon();\n  }\n}\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.JSXAttribute = JSXAttribute;\nexports.JSXClosingElement = JSXClosingElement;\nexports.JSXClosingFragment = JSXClosingFragment;\nexports.JSXElement = JSXElement;\nexports.JSXEmptyExpression = JSXEmptyExpression;\nexports.JSXExpressionContainer = JSXExpressionContainer;\nexports.JSXFragment = JSXFragment;\nexports.JSXIdentifier = JSXIdentifier;\nexports.JSXMemberExpression = JSXMemberExpression;\nexports.JSXNamespacedName = JSXNamespacedName;\nexports.JSXOpeningElement = JSXOpeningElement;\nexports.JSXOpeningFragment = JSXOpeningFragment;\nexports.JSXSpreadAttribute = JSXSpreadAttribute;\nexports.JSXSpreadChild = JSXSpreadChild;\nexports.JSXText = JSXText;\nfunction JSXAttribute(node) {\n  this.print(node.name, node);\n  if (node.value) {\n    this.tokenChar(61);\n    this.print(node.value, node);\n  }\n}\nfunction JSXIdentifier(node) {\n  this.word(node.name);\n}\nfunction JSXNamespacedName(node) {\n  this.print(node.namespace, node);\n  this.tokenChar(58);\n  this.print(node.name, node);\n}\nfunction JSXMemberExpression(node) {\n  this.print(node.object, node);\n  this.tokenChar(46);\n  this.print(node.property, node);\n}\nfunction JSXSpreadAttribute(node) {\n  this.tokenChar(123);\n  this.token(\"...\");\n  this.print(node.argument, node);\n  this.tokenChar(125);\n}\nfunction JSXExpressionContainer(node) {\n  this.tokenChar(123);\n  this.print(node.expression, node);\n  this.tokenChar(125);\n}\nfunction JSXSpreadChild(node) {\n  this.tokenChar(123);\n  this.token(\"...\");\n  this.print(node.expression, node);\n  this.tokenChar(125);\n}\nfunction JSXText(node) {\n  const raw = this.getPossibleRaw(node);\n  if (raw !== undefined) {\n    this.token(raw, true);\n  } else {\n    this.token(node.value, true);\n  }\n}\nfunction JSXElement(node) {\n  const open = node.openingElement;\n  this.print(open, node);\n  if (open.selfClosing) return;\n  this.indent();\n  for (const child of node.children) {\n    this.print(child, node);\n  }\n  this.dedent();\n  this.print(node.closingElement, node);\n}\nfunction spaceSeparator() {\n  this.space();\n}\nfunction JSXOpeningElement(node) {\n  this.tokenChar(60);\n  this.print(node.name, node);\n  this.print(node.typeParameters, node);\n  if (node.attributes.length > 0) {\n    this.space();\n    this.printJoin(node.attributes, node, {\n      separator: spaceSeparator\n    });\n  }\n  if (node.selfClosing) {\n    this.space();\n    this.token(\"/>\");\n  } else {\n    this.tokenChar(62);\n  }\n}\nfunction JSXClosingElement(node) {\n  this.token(\"</\");\n  this.print(node.name, node);\n  this.tokenChar(62);\n}\nfunction JSXEmptyExpression() {\n  this.printInnerComments();\n}\nfunction JSXFragment(node) {\n  this.print(node.openingFragment, node);\n  this.indent();\n  for (const child of node.children) {\n    this.print(child, node);\n  }\n  this.dedent();\n  this.print(node.closingFragment, node);\n}\nfunction JSXOpeningFragment() {\n  this.tokenChar(60);\n  this.tokenChar(62);\n}\nfunction JSXClosingFragment() {\n  this.token(\"</\");\n  this.tokenChar(62);\n}\n\n//# sourceMappingURL=jsx.js.map\n","import type Printer from \"../printer.ts\";\nimport type * as t from \"@babel/types\";\n\nexport function JSXAttribute(this: Printer, node: t.JSXAttribute) {\n  this.print(node.name, node);\n  if (node.value) {\n    this.token(\"=\");\n    this.print(node.value, node);\n  }\n}\n\nexport function JSXIdentifier(this: Printer, node: t.JSXIdentifier) {\n  this.word(node.name);\n}\n\nexport function JSXNamespacedName(this: Printer, node: t.JSXNamespacedName) {\n  this.print(node.namespace, node);\n  this.token(\":\");\n  this.print(node.name, node);\n}\n\nexport function JSXMemberExpression(\n  this: Printer,\n  node: t.JSXMemberExpression,\n) {\n  this.print(node.object, node);\n  this.token(\".\");\n  this.print(node.property, node);\n}\n\nexport function JSXSpreadAttribute(this: Printer, node: t.JSXSpreadAttribute) {\n  this.token(\"{\");\n  this.token(\"...\");\n  this.print(node.argument, node);\n  this.token(\"}\");\n}\n\nexport function JSXExpressionContainer(\n  this: Printer,\n  node: t.JSXExpressionContainer,\n) {\n  this.token(\"{\");\n  this.print(node.expression, node);\n  this.token(\"}\");\n}\n\nexport function JSXSpreadChild(this: Printer, node: t.JSXSpreadChild) {\n  this.token(\"{\");\n  this.token(\"...\");\n  this.print(node.expression, node);\n  this.token(\"}\");\n}\n\nexport function JSXText(this: Printer, node: t.JSXText) {\n  const raw = this.getPossibleRaw(node);\n\n  if (raw !== undefined) {\n    this.token(raw, true);\n  } else {\n    this.token(node.value, true);\n  }\n}\n\nexport function JSXElement(this: Printer, node: t.JSXElement) {\n  const open = node.openingElement;\n  this.print(open, node);\n  if (open.selfClosing) return;\n\n  this.indent();\n  for (const child of node.children) {\n    this.print(child, node);\n  }\n  this.dedent();\n\n  this.print(node.closingElement, node);\n}\n\nfunction spaceSeparator(this: Printer) {\n  this.space();\n}\n\nexport function JSXOpeningElement(this: Printer, node: t.JSXOpeningElement) {\n  this.token(\"<\");\n  this.print(node.name, node);\n  this.print(node.typeParameters, node); // TS\n  if (node.attributes.length > 0) {\n    this.space();\n    this.printJoin(node.attributes, node, { separator: spaceSeparator });\n  }\n  if (node.selfClosing) {\n    this.space();\n    this.token(\"/>\");\n  } else {\n    this.token(\">\");\n  }\n}\n\nexport function JSXClosingElement(this: Printer, node: t.JSXClosingElement) {\n  this.token(\"</\");\n  this.print(node.name, node);\n  this.token(\">\");\n}\n\nexport function JSXEmptyExpression(this: Printer) {\n  // This node is empty, so forcefully print its inner comments.\n  this.printInnerComments();\n}\n\nexport function JSXFragment(this: Printer, node: t.JSXFragment) {\n  this.print(node.openingFragment, node);\n\n  this.indent();\n  for (const child of node.children) {\n    this.print(child, node);\n  }\n  this.dedent();\n\n  this.print(node.closingFragment, node);\n}\n\nexport function JSXOpeningFragment(this: Printer) {\n  this.token(\"<\");\n  this.token(\">\");\n}\n\nexport function JSXClosingFragment(this: Printer) {\n  this.token(\"</\");\n  this.token(\">\");\n}\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TSAnyKeyword = TSAnyKeyword;\nexports.TSArrayType = TSArrayType;\nexports.TSSatisfiesExpression = exports.TSAsExpression = TSTypeExpression;\nexports.TSBigIntKeyword = TSBigIntKeyword;\nexports.TSBooleanKeyword = TSBooleanKeyword;\nexports.TSCallSignatureDeclaration = TSCallSignatureDeclaration;\nexports.TSConditionalType = TSConditionalType;\nexports.TSConstructSignatureDeclaration = TSConstructSignatureDeclaration;\nexports.TSConstructorType = TSConstructorType;\nexports.TSDeclareFunction = TSDeclareFunction;\nexports.TSDeclareMethod = TSDeclareMethod;\nexports.TSEnumDeclaration = TSEnumDeclaration;\nexports.TSEnumMember = TSEnumMember;\nexports.TSExportAssignment = TSExportAssignment;\nexports.TSExpressionWithTypeArguments = TSExpressionWithTypeArguments;\nexports.TSExternalModuleReference = TSExternalModuleReference;\nexports.TSFunctionType = TSFunctionType;\nexports.TSImportEqualsDeclaration = TSImportEqualsDeclaration;\nexports.TSImportType = TSImportType;\nexports.TSIndexSignature = TSIndexSignature;\nexports.TSIndexedAccessType = TSIndexedAccessType;\nexports.TSInferType = TSInferType;\nexports.TSInstantiationExpression = TSInstantiationExpression;\nexports.TSInterfaceBody = TSInterfaceBody;\nexports.TSInterfaceDeclaration = TSInterfaceDeclaration;\nexports.TSIntersectionType = TSIntersectionType;\nexports.TSIntrinsicKeyword = TSIntrinsicKeyword;\nexports.TSLiteralType = TSLiteralType;\nexports.TSMappedType = TSMappedType;\nexports.TSMethodSignature = TSMethodSignature;\nexports.TSModuleBlock = TSModuleBlock;\nexports.TSModuleDeclaration = TSModuleDeclaration;\nexports.TSNamedTupleMember = TSNamedTupleMember;\nexports.TSNamespaceExportDeclaration = TSNamespaceExportDeclaration;\nexports.TSNeverKeyword = TSNeverKeyword;\nexports.TSNonNullExpression = TSNonNullExpression;\nexports.TSNullKeyword = TSNullKeyword;\nexports.TSNumberKeyword = TSNumberKeyword;\nexports.TSObjectKeyword = TSObjectKeyword;\nexports.TSOptionalType = TSOptionalType;\nexports.TSParameterProperty = TSParameterProperty;\nexports.TSParenthesizedType = TSParenthesizedType;\nexports.TSPropertySignature = TSPropertySignature;\nexports.TSQualifiedName = TSQualifiedName;\nexports.TSRestType = TSRestType;\nexports.TSStringKeyword = TSStringKeyword;\nexports.TSSymbolKeyword = TSSymbolKeyword;\nexports.TSThisType = TSThisType;\nexports.TSTupleType = TSTupleType;\nexports.TSTypeAliasDeclaration = TSTypeAliasDeclaration;\nexports.TSTypeAnnotation = TSTypeAnnotation;\nexports.TSTypeAssertion = TSTypeAssertion;\nexports.TSTypeLiteral = TSTypeLiteral;\nexports.TSTypeOperator = TSTypeOperator;\nexports.TSTypeParameter = TSTypeParameter;\nexports.TSTypeParameterDeclaration = exports.TSTypeParameterInstantiation = TSTypeParameterInstantiation;\nexports.TSTypePredicate = TSTypePredicate;\nexports.TSTypeQuery = TSTypeQuery;\nexports.TSTypeReference = TSTypeReference;\nexports.TSUndefinedKeyword = TSUndefinedKeyword;\nexports.TSUnionType = TSUnionType;\nexports.TSUnknownKeyword = TSUnknownKeyword;\nexports.TSVoidKeyword = TSVoidKeyword;\nexports.tsPrintClassMemberModifiers = tsPrintClassMemberModifiers;\nexports.tsPrintFunctionOrConstructorType = tsPrintFunctionOrConstructorType;\nexports.tsPrintPropertyOrMethodName = tsPrintPropertyOrMethodName;\nexports.tsPrintSignatureDeclarationBase = tsPrintSignatureDeclarationBase;\nexports.tsPrintTypeLiteralOrInterfaceBody = tsPrintTypeLiteralOrInterfaceBody;\nfunction TSTypeAnnotation(node) {\n  this.tokenChar(58);\n  this.space();\n  if (node.optional) this.tokenChar(63);\n  this.print(node.typeAnnotation, node);\n}\nfunction TSTypeParameterInstantiation(node, parent) {\n  this.tokenChar(60);\n  this.printList(node.params, node, {});\n  if (parent.type === \"ArrowFunctionExpression\" && node.params.length === 1) {\n    this.tokenChar(44);\n  }\n  this.tokenChar(62);\n}\nfunction TSTypeParameter(node) {\n  if (node.in) {\n    this.word(\"in\");\n    this.space();\n  }\n  if (node.out) {\n    this.word(\"out\");\n    this.space();\n  }\n  this.word(node.name);\n  if (node.constraint) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.print(node.constraint, node);\n  }\n  if (node.default) {\n    this.space();\n    this.tokenChar(61);\n    this.space();\n    this.print(node.default, node);\n  }\n}\nfunction TSParameterProperty(node) {\n  if (node.accessibility) {\n    this.word(node.accessibility);\n    this.space();\n  }\n  if (node.readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n  this._param(node.parameter);\n}\nfunction TSDeclareFunction(node, parent) {\n  if (node.declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this._functionHead(node, parent);\n  this.tokenChar(59);\n}\nfunction TSDeclareMethod(node) {\n  this._classMethodHead(node);\n  this.tokenChar(59);\n}\nfunction TSQualifiedName(node) {\n  this.print(node.left, node);\n  this.tokenChar(46);\n  this.print(node.right, node);\n}\nfunction TSCallSignatureDeclaration(node) {\n  this.tsPrintSignatureDeclarationBase(node);\n  this.tokenChar(59);\n}\nfunction TSConstructSignatureDeclaration(node) {\n  this.word(\"new\");\n  this.space();\n  this.tsPrintSignatureDeclarationBase(node);\n  this.tokenChar(59);\n}\nfunction TSPropertySignature(node) {\n  const {\n    readonly,\n    initializer\n  } = node;\n  if (readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n  this.tsPrintPropertyOrMethodName(node);\n  this.print(node.typeAnnotation, node);\n  if (initializer) {\n    this.space();\n    this.tokenChar(61);\n    this.space();\n    this.print(initializer, node);\n  }\n  this.tokenChar(59);\n}\nfunction tsPrintPropertyOrMethodName(node) {\n  if (node.computed) {\n    this.tokenChar(91);\n  }\n  this.print(node.key, node);\n  if (node.computed) {\n    this.tokenChar(93);\n  }\n  if (node.optional) {\n    this.tokenChar(63);\n  }\n}\nfunction TSMethodSignature(node) {\n  const {\n    kind\n  } = node;\n  if (kind === \"set\" || kind === \"get\") {\n    this.word(kind);\n    this.space();\n  }\n  this.tsPrintPropertyOrMethodName(node);\n  this.tsPrintSignatureDeclarationBase(node);\n  this.tokenChar(59);\n}\nfunction TSIndexSignature(node) {\n  const {\n    readonly,\n    static: isStatic\n  } = node;\n  if (isStatic) {\n    this.word(\"static\");\n    this.space();\n  }\n  if (readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n  this.tokenChar(91);\n  this._parameters(node.parameters, node);\n  this.tokenChar(93);\n  this.print(node.typeAnnotation, node);\n  this.tokenChar(59);\n}\nfunction TSAnyKeyword() {\n  this.word(\"any\");\n}\nfunction TSBigIntKeyword() {\n  this.word(\"bigint\");\n}\nfunction TSUnknownKeyword() {\n  this.word(\"unknown\");\n}\nfunction TSNumberKeyword() {\n  this.word(\"number\");\n}\nfunction TSObjectKeyword() {\n  this.word(\"object\");\n}\nfunction TSBooleanKeyword() {\n  this.word(\"boolean\");\n}\nfunction TSStringKeyword() {\n  this.word(\"string\");\n}\nfunction TSSymbolKeyword() {\n  this.word(\"symbol\");\n}\nfunction TSVoidKeyword() {\n  this.word(\"void\");\n}\nfunction TSUndefinedKeyword() {\n  this.word(\"undefined\");\n}\nfunction TSNullKeyword() {\n  this.word(\"null\");\n}\nfunction TSNeverKeyword() {\n  this.word(\"never\");\n}\nfunction TSIntrinsicKeyword() {\n  this.word(\"intrinsic\");\n}\nfunction TSThisType() {\n  this.word(\"this\");\n}\nfunction TSFunctionType(node) {\n  this.tsPrintFunctionOrConstructorType(node);\n}\nfunction TSConstructorType(node) {\n  if (node.abstract) {\n    this.word(\"abstract\");\n    this.space();\n  }\n  this.word(\"new\");\n  this.space();\n  this.tsPrintFunctionOrConstructorType(node);\n}\nfunction tsPrintFunctionOrConstructorType(node) {\n  const {\n    typeParameters\n  } = node;\n  const parameters = node.parameters;\n  this.print(typeParameters, node);\n  this.tokenChar(40);\n  this._parameters(parameters, node);\n  this.tokenChar(41);\n  this.space();\n  this.token(\"=>\");\n  this.space();\n  const returnType = node.typeAnnotation;\n  this.print(returnType.typeAnnotation, node);\n}\nfunction TSTypeReference(node) {\n  this.print(node.typeName, node, true);\n  this.print(node.typeParameters, node, true);\n}\nfunction TSTypePredicate(node) {\n  if (node.asserts) {\n    this.word(\"asserts\");\n    this.space();\n  }\n  this.print(node.parameterName);\n  if (node.typeAnnotation) {\n    this.space();\n    this.word(\"is\");\n    this.space();\n    this.print(node.typeAnnotation.typeAnnotation);\n  }\n}\nfunction TSTypeQuery(node) {\n  this.word(\"typeof\");\n  this.space();\n  this.print(node.exprName);\n  if (node.typeParameters) {\n    this.print(node.typeParameters, node);\n  }\n}\nfunction TSTypeLiteral(node) {\n  this.tsPrintTypeLiteralOrInterfaceBody(node.members, node);\n}\nfunction tsPrintTypeLiteralOrInterfaceBody(members, node) {\n  tsPrintBraced(this, members, node);\n}\nfunction tsPrintBraced(printer, members, node) {\n  printer.token(\"{\");\n  if (members.length) {\n    printer.indent();\n    printer.newline();\n    for (const member of members) {\n      printer.print(member, node);\n      printer.newline();\n    }\n    printer.dedent();\n  }\n  printer.rightBrace(node);\n}\nfunction TSArrayType(node) {\n  this.print(node.elementType, node, true);\n  this.token(\"[]\");\n}\nfunction TSTupleType(node) {\n  this.tokenChar(91);\n  this.printList(node.elementTypes, node);\n  this.tokenChar(93);\n}\nfunction TSOptionalType(node) {\n  this.print(node.typeAnnotation, node);\n  this.tokenChar(63);\n}\nfunction TSRestType(node) {\n  this.token(\"...\");\n  this.print(node.typeAnnotation, node);\n}\nfunction TSNamedTupleMember(node) {\n  this.print(node.label, node);\n  if (node.optional) this.tokenChar(63);\n  this.tokenChar(58);\n  this.space();\n  this.print(node.elementType, node);\n}\nfunction TSUnionType(node) {\n  tsPrintUnionOrIntersectionType(this, node, \"|\");\n}\nfunction TSIntersectionType(node) {\n  tsPrintUnionOrIntersectionType(this, node, \"&\");\n}\nfunction tsPrintUnionOrIntersectionType(printer, node, sep) {\n  printer.printJoin(node.types, node, {\n    separator() {\n      this.space();\n      this.token(sep);\n      this.space();\n    }\n  });\n}\nfunction TSConditionalType(node) {\n  this.print(node.checkType);\n  this.space();\n  this.word(\"extends\");\n  this.space();\n  this.print(node.extendsType);\n  this.space();\n  this.tokenChar(63);\n  this.space();\n  this.print(node.trueType);\n  this.space();\n  this.tokenChar(58);\n  this.space();\n  this.print(node.falseType);\n}\nfunction TSInferType(node) {\n  this.token(\"infer\");\n  this.space();\n  this.print(node.typeParameter);\n}\nfunction TSParenthesizedType(node) {\n  this.tokenChar(40);\n  this.print(node.typeAnnotation, node);\n  this.tokenChar(41);\n}\nfunction TSTypeOperator(node) {\n  this.word(node.operator);\n  this.space();\n  this.print(node.typeAnnotation, node);\n}\nfunction TSIndexedAccessType(node) {\n  this.print(node.objectType, node, true);\n  this.tokenChar(91);\n  this.print(node.indexType, node);\n  this.tokenChar(93);\n}\nfunction TSMappedType(node) {\n  const {\n    nameType,\n    optional,\n    readonly,\n    typeParameter\n  } = node;\n  this.tokenChar(123);\n  this.space();\n  if (readonly) {\n    tokenIfPlusMinus(this, readonly);\n    this.word(\"readonly\");\n    this.space();\n  }\n  this.tokenChar(91);\n  this.word(typeParameter.name);\n  this.space();\n  this.word(\"in\");\n  this.space();\n  this.print(typeParameter.constraint, typeParameter);\n  if (nameType) {\n    this.space();\n    this.word(\"as\");\n    this.space();\n    this.print(nameType, node);\n  }\n  this.tokenChar(93);\n  if (optional) {\n    tokenIfPlusMinus(this, optional);\n    this.tokenChar(63);\n  }\n  this.tokenChar(58);\n  this.space();\n  this.print(node.typeAnnotation, node);\n  this.space();\n  this.tokenChar(125);\n}\nfunction tokenIfPlusMinus(self, tok) {\n  if (tok !== true) {\n    self.token(tok);\n  }\n}\nfunction TSLiteralType(node) {\n  this.print(node.literal, node);\n}\nfunction TSExpressionWithTypeArguments(node) {\n  this.print(node.expression, node);\n  this.print(node.typeParameters, node);\n}\nfunction TSInterfaceDeclaration(node) {\n  const {\n    declare,\n    id,\n    typeParameters,\n    extends: extendz,\n    body\n  } = node;\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.word(\"interface\");\n  this.space();\n  this.print(id, node);\n  this.print(typeParameters, node);\n  if (extendz != null && extendz.length) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.printList(extendz, node);\n  }\n  this.space();\n  this.print(body, node);\n}\nfunction TSInterfaceBody(node) {\n  this.tsPrintTypeLiteralOrInterfaceBody(node.body, node);\n}\nfunction TSTypeAliasDeclaration(node) {\n  const {\n    declare,\n    id,\n    typeParameters,\n    typeAnnotation\n  } = node;\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.word(\"type\");\n  this.space();\n  this.print(id, node);\n  this.print(typeParameters, node);\n  this.space();\n  this.tokenChar(61);\n  this.space();\n  this.print(typeAnnotation, node);\n  this.tokenChar(59);\n}\nfunction TSTypeExpression(node) {\n  var _expression$trailingC;\n  const {\n    type,\n    expression,\n    typeAnnotation\n  } = node;\n  const forceParens = !!((_expression$trailingC = expression.trailingComments) != null && _expression$trailingC.length);\n  this.print(expression, node, true, undefined, forceParens);\n  this.space();\n  this.word(type === \"TSAsExpression\" ? \"as\" : \"satisfies\");\n  this.space();\n  this.print(typeAnnotation, node);\n}\nfunction TSTypeAssertion(node) {\n  const {\n    typeAnnotation,\n    expression\n  } = node;\n  this.tokenChar(60);\n  this.print(typeAnnotation, node);\n  this.tokenChar(62);\n  this.space();\n  this.print(expression, node);\n}\nfunction TSInstantiationExpression(node) {\n  this.print(node.expression, node);\n  this.print(node.typeParameters, node);\n}\nfunction TSEnumDeclaration(node) {\n  const {\n    declare,\n    const: isConst,\n    id,\n    members\n  } = node;\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n  if (isConst) {\n    this.word(\"const\");\n    this.space();\n  }\n  this.word(\"enum\");\n  this.space();\n  this.print(id, node);\n  this.space();\n  tsPrintBraced(this, members, node);\n}\nfunction TSEnumMember(node) {\n  const {\n    id,\n    initializer\n  } = node;\n  this.print(id, node);\n  if (initializer) {\n    this.space();\n    this.tokenChar(61);\n    this.space();\n    this.print(initializer, node);\n  }\n  this.tokenChar(44);\n}\nfunction TSModuleDeclaration(node) {\n  const {\n    declare,\n    id\n  } = node;\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n  if (!node.global) {\n    this.word(id.type === \"Identifier\" ? \"namespace\" : \"module\");\n    this.space();\n  }\n  this.print(id, node);\n  if (!node.body) {\n    this.tokenChar(59);\n    return;\n  }\n  let body = node.body;\n  while (body.type === \"TSModuleDeclaration\") {\n    this.tokenChar(46);\n    this.print(body.id, body);\n    body = body.body;\n  }\n  this.space();\n  this.print(body, node);\n}\nfunction TSModuleBlock(node) {\n  tsPrintBraced(this, node.body, node);\n}\nfunction TSImportType(node) {\n  const {\n    argument,\n    qualifier,\n    typeParameters\n  } = node;\n  this.word(\"import\");\n  this.tokenChar(40);\n  this.print(argument, node);\n  this.tokenChar(41);\n  if (qualifier) {\n    this.tokenChar(46);\n    this.print(qualifier, node);\n  }\n  if (typeParameters) {\n    this.print(typeParameters, node);\n  }\n}\nfunction TSImportEqualsDeclaration(node) {\n  const {\n    isExport,\n    id,\n    moduleReference\n  } = node;\n  if (isExport) {\n    this.word(\"export\");\n    this.space();\n  }\n  this.word(\"import\");\n  this.space();\n  this.print(id, node);\n  this.space();\n  this.tokenChar(61);\n  this.space();\n  this.print(moduleReference, node);\n  this.tokenChar(59);\n}\nfunction TSExternalModuleReference(node) {\n  this.token(\"require(\");\n  this.print(node.expression, node);\n  this.tokenChar(41);\n}\nfunction TSNonNullExpression(node) {\n  this.print(node.expression, node);\n  this.tokenChar(33);\n}\nfunction TSExportAssignment(node) {\n  this.word(\"export\");\n  this.space();\n  this.tokenChar(61);\n  this.space();\n  this.print(node.expression, node);\n  this.tokenChar(59);\n}\nfunction TSNamespaceExportDeclaration(node) {\n  this.word(\"export\");\n  this.space();\n  this.word(\"as\");\n  this.space();\n  this.word(\"namespace\");\n  this.space();\n  this.print(node.id, node);\n}\nfunction tsPrintSignatureDeclarationBase(node) {\n  const {\n    typeParameters\n  } = node;\n  const parameters = node.parameters;\n  this.print(typeParameters, node);\n  this.tokenChar(40);\n  this._parameters(parameters, node);\n  this.tokenChar(41);\n  const returnType = node.typeAnnotation;\n  this.print(returnType, node);\n}\nfunction tsPrintClassMemberModifiers(node) {\n  const isField = node.type === \"ClassAccessorProperty\" || node.type === \"ClassProperty\";\n  if (isField && node.declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n  if (node.accessibility) {\n    this.word(node.accessibility);\n    this.space();\n  }\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  if (node.override) {\n    this.word(\"override\");\n    this.space();\n  }\n  if (node.abstract) {\n    this.word(\"abstract\");\n    this.space();\n  }\n  if (isField && node.readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n}\n\n//# sourceMappingURL=typescript.js.map\n","import type Printer from \"../printer.ts\";\nimport type * as t from \"@babel/types\";\nimport type { NodePath } from \"@babel/traverse\";\n\nexport function TSTypeAnnotation(this: Printer, node: t.TSTypeAnnotation) {\n  this.token(\":\");\n  this.space();\n  // @ts-expect-error todo(flow->ts) can this be removed? `.optional` looks to be not existing property\n  if (node.optional) this.token(\"?\");\n  this.print(node.typeAnnotation, node);\n}\n\nexport function TSTypeParameterInstantiation(\n  this: Printer,\n  node: t.TSTypeParameterInstantiation,\n  parent: t.Node,\n): void {\n  this.token(\"<\");\n  this.printList(node.params, node, {});\n  if (parent.type === \"ArrowFunctionExpression\" && node.params.length === 1) {\n    this.token(\",\");\n  }\n  this.token(\">\");\n}\n\nexport { TSTypeParameterInstantiation as TSTypeParameterDeclaration };\n\nexport function TSTypeParameter(this: Printer, node: t.TSTypeParameter) {\n  if (node.in) {\n    this.word(\"in\");\n    this.space();\n  }\n\n  if (node.out) {\n    this.word(\"out\");\n    this.space();\n  }\n\n  this.word(\n    !process.env.BABEL_8_BREAKING\n      ? (node.name as unknown as string)\n      : (node.name as unknown as t.Identifier).name,\n  );\n\n  if (node.constraint) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.print(node.constraint, node);\n  }\n\n  if (node.default) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(node.default, node);\n  }\n}\n\nexport function TSParameterProperty(\n  this: Printer,\n  node: t.TSParameterProperty,\n) {\n  if (node.accessibility) {\n    this.word(node.accessibility);\n    this.space();\n  }\n\n  if (node.readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n\n  this._param(node.parameter);\n}\n\nexport function TSDeclareFunction(\n  this: Printer,\n  node: t.TSDeclareFunction,\n  parent: NodePath<t.TSDeclareFunction>[\"parent\"],\n) {\n  if (node.declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this._functionHead(node, parent);\n  this.token(\";\");\n}\n\nexport function TSDeclareMethod(this: Printer, node: t.TSDeclareMethod) {\n  this._classMethodHead(node);\n  this.token(\";\");\n}\n\nexport function TSQualifiedName(this: Printer, node: t.TSQualifiedName) {\n  this.print(node.left, node);\n  this.token(\".\");\n  this.print(node.right, node);\n}\n\nexport function TSCallSignatureDeclaration(\n  this: Printer,\n  node: t.TSCallSignatureDeclaration,\n) {\n  this.tsPrintSignatureDeclarationBase(node);\n  this.token(\";\");\n}\n\nexport function TSConstructSignatureDeclaration(\n  this: Printer,\n  node: t.TSConstructSignatureDeclaration,\n) {\n  this.word(\"new\");\n  this.space();\n  this.tsPrintSignatureDeclarationBase(node);\n  this.token(\";\");\n}\n\nexport function TSPropertySignature(\n  this: Printer,\n  node: t.TSPropertySignature,\n) {\n  const { readonly, initializer } = node;\n  if (readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n  this.tsPrintPropertyOrMethodName(node);\n  this.print(node.typeAnnotation, node);\n  if (initializer) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(initializer, node);\n  }\n  this.token(\";\");\n}\n\nexport function tsPrintPropertyOrMethodName(\n  this: Printer,\n  node: t.TSPropertySignature | t.TSMethodSignature,\n) {\n  if (node.computed) {\n    this.token(\"[\");\n  }\n  this.print(node.key, node);\n  if (node.computed) {\n    this.token(\"]\");\n  }\n  if (node.optional) {\n    this.token(\"?\");\n  }\n}\n\nexport function TSMethodSignature(this: Printer, node: t.TSMethodSignature) {\n  const { kind } = node;\n  if (kind === \"set\" || kind === \"get\") {\n    this.word(kind);\n    this.space();\n  }\n  this.tsPrintPropertyOrMethodName(node);\n  this.tsPrintSignatureDeclarationBase(node);\n  this.token(\";\");\n}\n\nexport function TSIndexSignature(this: Printer, node: t.TSIndexSignature) {\n  const { readonly, static: isStatic } = node;\n  if (isStatic) {\n    this.word(\"static\");\n    this.space();\n  }\n  if (readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n  this.token(\"[\");\n  this._parameters(node.parameters, node);\n  this.token(\"]\");\n  this.print(node.typeAnnotation, node);\n  this.token(\";\");\n}\n\nexport function TSAnyKeyword(this: Printer) {\n  this.word(\"any\");\n}\nexport function TSBigIntKeyword(this: Printer) {\n  this.word(\"bigint\");\n}\nexport function TSUnknownKeyword(this: Printer) {\n  this.word(\"unknown\");\n}\nexport function TSNumberKeyword(this: Printer) {\n  this.word(\"number\");\n}\nexport function TSObjectKeyword(this: Printer) {\n  this.word(\"object\");\n}\nexport function TSBooleanKeyword(this: Printer) {\n  this.word(\"boolean\");\n}\nexport function TSStringKeyword(this: Printer) {\n  this.word(\"string\");\n}\nexport function TSSymbolKeyword(this: Printer) {\n  this.word(\"symbol\");\n}\nexport function TSVoidKeyword(this: Printer) {\n  this.word(\"void\");\n}\nexport function TSUndefinedKeyword(this: Printer) {\n  this.word(\"undefined\");\n}\nexport function TSNullKeyword(this: Printer) {\n  this.word(\"null\");\n}\nexport function TSNeverKeyword(this: Printer) {\n  this.word(\"never\");\n}\nexport function TSIntrinsicKeyword(this: Printer) {\n  this.word(\"intrinsic\");\n}\n\nexport function TSThisType(this: Printer) {\n  this.word(\"this\");\n}\n\nexport function TSFunctionType(this: Printer, node: t.TSFunctionType) {\n  this.tsPrintFunctionOrConstructorType(node);\n}\n\nexport function TSConstructorType(this: Printer, node: t.TSConstructorType) {\n  if (node.abstract) {\n    this.word(\"abstract\");\n    this.space();\n  }\n  this.word(\"new\");\n  this.space();\n  this.tsPrintFunctionOrConstructorType(node);\n}\n\nexport function tsPrintFunctionOrConstructorType(\n  this: Printer,\n  node: t.TSFunctionType | t.TSConstructorType,\n) {\n  const { typeParameters } = node;\n  const parameters = process.env.BABEL_8_BREAKING\n    ? // @ts-ignore(Babel 7 vs Babel 8) Babel 8 AST shape\n      node.params\n    : // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST shape\n      node.parameters;\n  this.print(typeParameters, node);\n  this.token(\"(\");\n  this._parameters(parameters, node);\n  this.token(\")\");\n  this.space();\n  this.token(\"=>\");\n  this.space();\n  const returnType = process.env.BABEL_8_BREAKING\n    ? // @ts-ignore(Babel 7 vs Babel 8) Babel 8 AST shape\n      node.returnType\n    : // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST shape\n      node.typeAnnotation;\n  this.print(returnType.typeAnnotation, node);\n}\n\nexport function TSTypeReference(this: Printer, node: t.TSTypeReference) {\n  this.print(node.typeName, node, true);\n  this.print(node.typeParameters, node, true);\n}\n\nexport function TSTypePredicate(this: Printer, node: t.TSTypePredicate) {\n  if (node.asserts) {\n    this.word(\"asserts\");\n    this.space();\n  }\n  this.print(node.parameterName);\n  if (node.typeAnnotation) {\n    this.space();\n    this.word(\"is\");\n    this.space();\n    this.print(node.typeAnnotation.typeAnnotation);\n  }\n}\n\nexport function TSTypeQuery(this: Printer, node: t.TSTypeQuery) {\n  this.word(\"typeof\");\n  this.space();\n  this.print(node.exprName);\n\n  if (node.typeParameters) {\n    this.print(node.typeParameters, node);\n  }\n}\n\nexport function TSTypeLiteral(this: Printer, node: t.TSTypeLiteral) {\n  this.tsPrintTypeLiteralOrInterfaceBody(node.members, node);\n}\n\nexport function tsPrintTypeLiteralOrInterfaceBody(\n  this: Printer,\n  members: t.TSTypeElement[],\n  node: t.TSType | t.TSInterfaceBody,\n) {\n  tsPrintBraced(this, members, node);\n}\n\nfunction tsPrintBraced(printer: Printer, members: t.Node[], node: t.Node) {\n  printer.token(\"{\");\n  if (members.length) {\n    printer.indent();\n    printer.newline();\n    for (const member of members) {\n      printer.print(member, node);\n      //this.token(sep);\n      printer.newline();\n    }\n    printer.dedent();\n  }\n\n  printer.rightBrace(node);\n}\n\nexport function TSArrayType(this: Printer, node: t.TSArrayType) {\n  this.print(node.elementType, node, true);\n\n  this.token(\"[]\");\n}\n\nexport function TSTupleType(this: Printer, node: t.TSTupleType) {\n  this.token(\"[\");\n  this.printList(node.elementTypes, node);\n  this.token(\"]\");\n}\n\nexport function TSOptionalType(this: Printer, node: t.TSOptionalType) {\n  this.print(node.typeAnnotation, node);\n  this.token(\"?\");\n}\n\nexport function TSRestType(this: Printer, node: t.TSRestType) {\n  this.token(\"...\");\n  this.print(node.typeAnnotation, node);\n}\n\nexport function TSNamedTupleMember(this: Printer, node: t.TSNamedTupleMember) {\n  this.print(node.label, node);\n  if (node.optional) this.token(\"?\");\n  this.token(\":\");\n  this.space();\n  this.print(node.elementType, node);\n}\n\nexport function TSUnionType(this: Printer, node: t.TSUnionType) {\n  tsPrintUnionOrIntersectionType(this, node, \"|\");\n}\n\nexport function TSIntersectionType(this: Printer, node: t.TSIntersectionType) {\n  tsPrintUnionOrIntersectionType(this, node, \"&\");\n}\n\nfunction tsPrintUnionOrIntersectionType(\n  printer: Printer,\n  node: t.TSUnionType | t.TSIntersectionType,\n  sep: \"|\" | \"&\",\n) {\n  printer.printJoin(node.types, node, {\n    separator() {\n      this.space();\n      this.token(sep);\n      this.space();\n    },\n  });\n}\n\nexport function TSConditionalType(this: Printer, node: t.TSConditionalType) {\n  this.print(node.checkType);\n  this.space();\n  this.word(\"extends\");\n  this.space();\n  this.print(node.extendsType);\n  this.space();\n  this.token(\"?\");\n  this.space();\n  this.print(node.trueType);\n  this.space();\n  this.token(\":\");\n  this.space();\n  this.print(node.falseType);\n}\n\nexport function TSInferType(this: Printer, node: t.TSInferType) {\n  this.token(\"infer\");\n  this.space();\n  this.print(node.typeParameter);\n}\n\nexport function TSParenthesizedType(\n  this: Printer,\n  node: t.TSParenthesizedType,\n) {\n  this.token(\"(\");\n  this.print(node.typeAnnotation, node);\n  this.token(\")\");\n}\n\nexport function TSTypeOperator(this: Printer, node: t.TSTypeOperator) {\n  this.word(node.operator);\n  this.space();\n  this.print(node.typeAnnotation, node);\n}\n\nexport function TSIndexedAccessType(\n  this: Printer,\n  node: t.TSIndexedAccessType,\n) {\n  this.print(node.objectType, node, true);\n  this.token(\"[\");\n  this.print(node.indexType, node);\n  this.token(\"]\");\n}\n\nexport function TSMappedType(this: Printer, node: t.TSMappedType) {\n  const { nameType, optional, readonly, typeParameter } = node;\n  this.token(\"{\");\n  this.space();\n  if (readonly) {\n    tokenIfPlusMinus(this, readonly);\n    this.word(\"readonly\");\n    this.space();\n  }\n\n  this.token(\"[\");\n  this.word(\n    !process.env.BABEL_8_BREAKING\n      ? (typeParameter.name as unknown as string)\n      : (typeParameter.name as unknown as t.Identifier).name,\n  );\n  this.space();\n  this.word(\"in\");\n  this.space();\n  this.print(typeParameter.constraint, typeParameter);\n\n  if (nameType) {\n    this.space();\n    this.word(\"as\");\n    this.space();\n    this.print(nameType, node);\n  }\n\n  this.token(\"]\");\n\n  if (optional) {\n    tokenIfPlusMinus(this, optional);\n    this.token(\"?\");\n  }\n  this.token(\":\");\n  this.space();\n  this.print(node.typeAnnotation, node);\n  this.space();\n  this.token(\"}\");\n}\n\nfunction tokenIfPlusMinus(self: Printer, tok: true | \"+\" | \"-\") {\n  if (tok !== true) {\n    self.token(tok);\n  }\n}\n\nexport function TSLiteralType(this: Printer, node: t.TSLiteralType) {\n  this.print(node.literal, node);\n}\n\nexport function TSExpressionWithTypeArguments(\n  this: Printer,\n  node: t.TSExpressionWithTypeArguments,\n) {\n  this.print(node.expression, node);\n  this.print(node.typeParameters, node);\n}\n\nexport function TSInterfaceDeclaration(\n  this: Printer,\n  node: t.TSInterfaceDeclaration,\n) {\n  const { declare, id, typeParameters, extends: extendz, body } = node;\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.word(\"interface\");\n  this.space();\n  this.print(id, node);\n  this.print(typeParameters, node);\n  if (extendz?.length) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.printList(extendz, node);\n  }\n  this.space();\n  this.print(body, node);\n}\n\nexport function TSInterfaceBody(this: Printer, node: t.TSInterfaceBody) {\n  this.tsPrintTypeLiteralOrInterfaceBody(node.body, node);\n}\n\nexport function TSTypeAliasDeclaration(\n  this: Printer,\n  node: t.TSTypeAliasDeclaration,\n) {\n  const { declare, id, typeParameters, typeAnnotation } = node;\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.word(\"type\");\n  this.space();\n  this.print(id, node);\n  this.print(typeParameters, node);\n  this.space();\n  this.token(\"=\");\n  this.space();\n  this.print(typeAnnotation, node);\n  this.token(\";\");\n}\n\nfunction TSTypeExpression(\n  this: Printer,\n  node: t.TSAsExpression | t.TSSatisfiesExpression,\n) {\n  const { type, expression, typeAnnotation } = node;\n  const forceParens = !!expression.trailingComments?.length;\n  this.print(expression, node, true, undefined, forceParens);\n  this.space();\n  this.word(type === \"TSAsExpression\" ? \"as\" : \"satisfies\");\n  this.space();\n  this.print(typeAnnotation, node);\n}\n\nexport {\n  TSTypeExpression as TSAsExpression,\n  TSTypeExpression as TSSatisfiesExpression,\n};\n\nexport function TSTypeAssertion(this: Printer, node: t.TSTypeAssertion) {\n  const { typeAnnotation, expression } = node;\n  this.token(\"<\");\n  this.print(typeAnnotation, node);\n  this.token(\">\");\n  this.space();\n  this.print(expression, node);\n}\n\nexport function TSInstantiationExpression(\n  this: Printer,\n  node: t.TSInstantiationExpression,\n) {\n  this.print(node.expression, node);\n  this.print(node.typeParameters, node);\n}\n\nexport function TSEnumDeclaration(this: Printer, node: t.TSEnumDeclaration) {\n  const { declare, const: isConst, id, members } = node;\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n  if (isConst) {\n    this.word(\"const\");\n    this.space();\n  }\n  this.word(\"enum\");\n  this.space();\n  this.print(id, node);\n  this.space();\n  tsPrintBraced(this, members, node);\n}\n\nexport function TSEnumMember(this: Printer, node: t.TSEnumMember) {\n  const { id, initializer } = node;\n  this.print(id, node);\n  if (initializer) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(initializer, node);\n  }\n  this.token(\",\");\n}\n\nexport function TSModuleDeclaration(\n  this: Printer,\n  node: t.TSModuleDeclaration,\n) {\n  const { declare, id } = node;\n\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  if (!node.global) {\n    this.word(id.type === \"Identifier\" ? \"namespace\" : \"module\");\n    this.space();\n  }\n  this.print(id, node);\n\n  if (!node.body) {\n    this.token(\";\");\n    return;\n  }\n\n  let body = node.body;\n  while (body.type === \"TSModuleDeclaration\") {\n    this.token(\".\");\n    this.print(body.id, body);\n    body = body.body;\n  }\n\n  this.space();\n  this.print(body, node);\n}\n\nexport function TSModuleBlock(this: Printer, node: t.TSModuleBlock) {\n  tsPrintBraced(this, node.body, node);\n}\n\nexport function TSImportType(this: Printer, node: t.TSImportType) {\n  const { argument, qualifier, typeParameters } = node;\n  this.word(\"import\");\n  this.token(\"(\");\n  this.print(argument, node);\n  this.token(\")\");\n  if (qualifier) {\n    this.token(\".\");\n    this.print(qualifier, node);\n  }\n  if (typeParameters) {\n    this.print(typeParameters, node);\n  }\n}\n\nexport function TSImportEqualsDeclaration(\n  this: Printer,\n  node: t.TSImportEqualsDeclaration,\n) {\n  const { isExport, id, moduleReference } = node;\n  if (isExport) {\n    this.word(\"export\");\n    this.space();\n  }\n  this.word(\"import\");\n  this.space();\n  this.print(id, node);\n  this.space();\n  this.token(\"=\");\n  this.space();\n  this.print(moduleReference, node);\n  this.token(\";\");\n}\n\nexport function TSExternalModuleReference(\n  this: Printer,\n  node: t.TSExternalModuleReference,\n) {\n  this.token(\"require(\");\n  this.print(node.expression, node);\n  this.token(\")\");\n}\n\nexport function TSNonNullExpression(\n  this: Printer,\n  node: t.TSNonNullExpression,\n) {\n  this.print(node.expression, node);\n  this.token(\"!\");\n}\n\nexport function TSExportAssignment(this: Printer, node: t.TSExportAssignment) {\n  this.word(\"export\");\n  this.space();\n  this.token(\"=\");\n  this.space();\n  this.print(node.expression, node);\n  this.token(\";\");\n}\n\nexport function TSNamespaceExportDeclaration(\n  this: Printer,\n  node: t.TSNamespaceExportDeclaration,\n) {\n  this.word(\"export\");\n  this.space();\n  this.word(\"as\");\n  this.space();\n  this.word(\"namespace\");\n  this.space();\n  this.print(node.id, node);\n}\n\nexport function tsPrintSignatureDeclarationBase(this: Printer, node: any) {\n  const { typeParameters } = node;\n  const parameters = process.env.BABEL_8_BREAKING\n    ? node.params\n    : node.parameters;\n  this.print(typeParameters, node);\n  this.token(\"(\");\n  this._parameters(parameters, node);\n  this.token(\")\");\n  const returnType = process.env.BABEL_8_BREAKING\n    ? node.returnType\n    : node.typeAnnotation;\n  this.print(returnType, node);\n}\n\nexport function tsPrintClassMemberModifiers(\n  this: Printer,\n  node:\n    | t.ClassProperty\n    | t.ClassAccessorProperty\n    | t.ClassMethod\n    | t.ClassPrivateMethod\n    | t.TSDeclareMethod,\n) {\n  const isField =\n    node.type === \"ClassAccessorProperty\" || node.type === \"ClassProperty\";\n  if (isField && node.declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n  if (node.accessibility) {\n    this.word(node.accessibility);\n    this.space();\n  }\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  if (node.override) {\n    this.word(\"override\");\n    this.space();\n  }\n  if (node.abstract) {\n    this.word(\"abstract\");\n    this.space();\n  }\n  if (isField && node.readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n}\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"ImportInjector\", {\n  enumerable: true,\n  get: function () {\n    return _importInjector.default;\n  }\n});\nexports.addDefault = addDefault;\nexports.addNamed = addNamed;\nexports.addNamespace = addNamespace;\nexports.addSideEffect = addSideEffect;\nObject.defineProperty(exports, \"isModule\", {\n  enumerable: true,\n  get: function () {\n    return _isModule.default;\n  }\n});\nvar _importInjector = require(\"./import-injector.js\");\nvar _isModule = require(\"./is-module.js\");\nfunction addDefault(path, importedSource, opts) {\n  return new _importInjector.default(path).addDefault(importedSource, opts);\n}\nfunction addNamed(path, name, importedSource, opts) {\n  return new _importInjector.default(path).addNamed(name, importedSource, opts);\n}\nfunction addNamespace(path, importedSource, opts) {\n  return new _importInjector.default(path).addNamespace(importedSource, opts);\n}\nfunction addSideEffect(path, importedSource, opts) {\n  return new _importInjector.default(path).addSideEffect(importedSource, opts);\n}\n\n//# sourceMappingURL=index.js.map\n","import ImportInjector, { type ImportOptions } from \"./import-injector.ts\";\nimport type { NodePath } from \"@babel/traverse\";\nimport type * as t from \"@babel/types\";\n\nexport { ImportInjector };\n\nexport { default as isModule } from \"./is-module.ts\";\n\nexport function addDefault(\n  path: NodePath,\n  importedSource: string,\n  opts?: Partial<ImportOptions>,\n) {\n  return new ImportInjector(path).addDefault(importedSource, opts);\n}\n\nfunction addNamed(\n  path: NodePath,\n  name: string,\n  importedSource: string,\n  opts?: Omit<\n    Partial<ImportOptions>,\n    \"ensureLiveReference\" | \"ensureNoContext\"\n  >,\n): t.Identifier;\nfunction addNamed(\n  path: NodePath,\n  name: string,\n  importedSource: string,\n  opts?: Omit<Partial<ImportOptions>, \"ensureLiveReference\"> & {\n    ensureLiveReference: true;\n  },\n): t.MemberExpression;\nfunction addNamed(\n  path: NodePath,\n  name: string,\n  importedSource: string,\n  opts?: Omit<Partial<ImportOptions>, \"ensureNoContext\"> & {\n    ensureNoContext: true;\n  },\n): t.SequenceExpression;\n/**\n * add a named import to the program path of given path\n *\n * @export\n * @param {NodePath} path The starting path to find a program path\n * @param {string} name The name of the generated binding. Babel will prefix it with `_`\n * @param {string} importedSource The source of the import\n * @param {Partial<ImportOptions>} [opts]\n * @returns {t.Identifier | t.MemberExpression | t.SequenceExpression} If opts.ensureNoContext is true, returns a SequenceExpression,\n *   else if opts.ensureLiveReference is true, returns a MemberExpression, else returns an Identifier\n */\nfunction addNamed(\n  path: NodePath,\n  name: string,\n  importedSource: string,\n  opts?: Partial<ImportOptions>,\n) {\n  return new ImportInjector(path).addNamed(name, importedSource, opts);\n}\nexport { addNamed };\n\nexport function addNamespace(\n  path: NodePath,\n  importedSource: string,\n  opts?: Partial<ImportOptions>,\n) {\n  return new ImportInjector(path).addNamespace(importedSource, opts);\n}\n\nexport function addSideEffect(\n  path: NodePath,\n  importedSource: string,\n  opts?: Partial<ImportOptions>,\n) {\n  return new ImportInjector(path).addSideEffect(importedSource, opts);\n}\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _assert = require(\"assert\");\nvar _t = require(\"@babel/types\");\nvar _importBuilder = require(\"./import-builder.js\");\nvar _isModule = require(\"./is-module.js\");\nconst {\n  numericLiteral,\n  sequenceExpression\n} = _t;\nclass ImportInjector {\n  constructor(path, importedSource, opts) {\n    this._defaultOpts = {\n      importedSource: null,\n      importedType: \"commonjs\",\n      importedInterop: \"babel\",\n      importingInterop: \"babel\",\n      ensureLiveReference: false,\n      ensureNoContext: false,\n      importPosition: \"before\"\n    };\n    const programPath = path.find(p => p.isProgram());\n    this._programPath = programPath;\n    this._programScope = programPath.scope;\n    this._hub = programPath.hub;\n    this._defaultOpts = this._applyDefaults(importedSource, opts, true);\n  }\n  addDefault(importedSourceIn, opts) {\n    return this.addNamed(\"default\", importedSourceIn, opts);\n  }\n  addNamed(importName, importedSourceIn, opts) {\n    _assert(typeof importName === \"string\");\n    return this._generateImport(this._applyDefaults(importedSourceIn, opts), importName);\n  }\n  addNamespace(importedSourceIn, opts) {\n    return this._generateImport(this._applyDefaults(importedSourceIn, opts), null);\n  }\n  addSideEffect(importedSourceIn, opts) {\n    return this._generateImport(this._applyDefaults(importedSourceIn, opts), void 0);\n  }\n  _applyDefaults(importedSource, opts, isInit = false) {\n    let newOpts;\n    if (typeof importedSource === \"string\") {\n      newOpts = Object.assign({}, this._defaultOpts, {\n        importedSource\n      }, opts);\n    } else {\n      _assert(!opts, \"Unexpected secondary arguments.\");\n      newOpts = Object.assign({}, this._defaultOpts, importedSource);\n    }\n    if (!isInit && opts) {\n      if (opts.nameHint !== undefined) newOpts.nameHint = opts.nameHint;\n      if (opts.blockHoist !== undefined) newOpts.blockHoist = opts.blockHoist;\n    }\n    return newOpts;\n  }\n  _generateImport(opts, importName) {\n    const isDefault = importName === \"default\";\n    const isNamed = !!importName && !isDefault;\n    const isNamespace = importName === null;\n    const {\n      importedSource,\n      importedType,\n      importedInterop,\n      importingInterop,\n      ensureLiveReference,\n      ensureNoContext,\n      nameHint,\n      importPosition,\n      blockHoist\n    } = opts;\n    let name = nameHint || importName;\n    const isMod = (0, _isModule.default)(this._programPath);\n    const isModuleForNode = isMod && importingInterop === \"node\";\n    const isModuleForBabel = isMod && importingInterop === \"babel\";\n    if (importPosition === \"after\" && !isMod) {\n      throw new Error(`\"importPosition\": \"after\" is only supported in modules`);\n    }\n    const builder = new _importBuilder.default(importedSource, this._programScope, this._hub);\n    if (importedType === \"es6\") {\n      if (!isModuleForNode && !isModuleForBabel) {\n        throw new Error(\"Cannot import an ES6 module from CommonJS\");\n      }\n      builder.import();\n      if (isNamespace) {\n        builder.namespace(nameHint || importedSource);\n      } else if (isDefault || isNamed) {\n        builder.named(name, importName);\n      }\n    } else if (importedType !== \"commonjs\") {\n      throw new Error(`Unexpected interopType \"${importedType}\"`);\n    } else if (importedInterop === \"babel\") {\n      if (isModuleForNode) {\n        name = name !== \"default\" ? name : importedSource;\n        const es6Default = `${importedSource}$es6Default`;\n        builder.import();\n        if (isNamespace) {\n          builder.default(es6Default).var(name || importedSource).wildcardInterop();\n        } else if (isDefault) {\n          if (ensureLiveReference) {\n            builder.default(es6Default).var(name || importedSource).defaultInterop().read(\"default\");\n          } else {\n            builder.default(es6Default).var(name).defaultInterop().prop(importName);\n          }\n        } else if (isNamed) {\n          builder.default(es6Default).read(importName);\n        }\n      } else if (isModuleForBabel) {\n        builder.import();\n        if (isNamespace) {\n          builder.namespace(name || importedSource);\n        } else if (isDefault || isNamed) {\n          builder.named(name, importName);\n        }\n      } else {\n        builder.require();\n        if (isNamespace) {\n          builder.var(name || importedSource).wildcardInterop();\n        } else if ((isDefault || isNamed) && ensureLiveReference) {\n          if (isDefault) {\n            name = name !== \"default\" ? name : importedSource;\n            builder.var(name).read(importName);\n            builder.defaultInterop();\n          } else {\n            builder.var(importedSource).read(importName);\n          }\n        } else if (isDefault) {\n          builder.var(name).defaultInterop().prop(importName);\n        } else if (isNamed) {\n          builder.var(name).prop(importName);\n        }\n      }\n    } else if (importedInterop === \"compiled\") {\n      if (isModuleForNode) {\n        builder.import();\n        if (isNamespace) {\n          builder.default(name || importedSource);\n        } else if (isDefault || isNamed) {\n          builder.default(importedSource).read(name);\n        }\n      } else if (isModuleForBabel) {\n        builder.import();\n        if (isNamespace) {\n          builder.namespace(name || importedSource);\n        } else if (isDefault || isNamed) {\n          builder.named(name, importName);\n        }\n      } else {\n        builder.require();\n        if (isNamespace) {\n          builder.var(name || importedSource);\n        } else if (isDefault || isNamed) {\n          if (ensureLiveReference) {\n            builder.var(importedSource).read(name);\n          } else {\n            builder.prop(importName).var(name);\n          }\n        }\n      }\n    } else if (importedInterop === \"uncompiled\") {\n      if (isDefault && ensureLiveReference) {\n        throw new Error(\"No live reference for commonjs default\");\n      }\n      if (isModuleForNode) {\n        builder.import();\n        if (isNamespace) {\n          builder.default(name || importedSource);\n        } else if (isDefault) {\n          builder.default(name);\n        } else if (isNamed) {\n          builder.default(importedSource).read(name);\n        }\n      } else if (isModuleForBabel) {\n        builder.import();\n        if (isNamespace) {\n          builder.default(name || importedSource);\n        } else if (isDefault) {\n          builder.default(name);\n        } else if (isNamed) {\n          builder.named(name, importName);\n        }\n      } else {\n        builder.require();\n        if (isNamespace) {\n          builder.var(name || importedSource);\n        } else if (isDefault) {\n          builder.var(name);\n        } else if (isNamed) {\n          if (ensureLiveReference) {\n            builder.var(importedSource).read(name);\n          } else {\n            builder.var(name).prop(importName);\n          }\n        }\n      }\n    } else {\n      throw new Error(`Unknown importedInterop \"${importedInterop}\".`);\n    }\n    const {\n      statements,\n      resultName\n    } = builder.done();\n    this._insertStatements(statements, importPosition, blockHoist);\n    if ((isDefault || isNamed) && ensureNoContext && resultName.type !== \"Identifier\") {\n      return sequenceExpression([numericLiteral(0), resultName]);\n    }\n    return resultName;\n  }\n  _insertStatements(statements, importPosition = \"before\", blockHoist = 3) {\n    const body = this._programPath.get(\"body\");\n    if (importPosition === \"after\") {\n      for (let i = body.length - 1; i >= 0; i--) {\n        if (body[i].isImportDeclaration()) {\n          body[i].insertAfter(statements);\n          return;\n        }\n      }\n    } else {\n      statements.forEach(node => {\n        node._blockHoist = blockHoist;\n      });\n      const targetPath = body.find(p => {\n        const val = p.node._blockHoist;\n        return Number.isFinite(val) && val < 4;\n      });\n      if (targetPath) {\n        targetPath.insertBefore(statements);\n        return;\n      }\n    }\n    this._programPath.unshiftContainer(\"body\", statements);\n  }\n}\nexports.default = ImportInjector;\n\n//# sourceMappingURL=import-injector.js.map\n","import assert from \"assert\";\nimport { numericLiteral, sequenceExpression } from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport type { NodePath, Scope } from \"@babel/traverse\";\nimport type { File } from \"@babel/core\";\n\nimport ImportBuilder from \"./import-builder.ts\";\nimport isModule from \"./is-module.ts\";\n\nexport type ImportOptions = {\n  /**\n   * The module being referenced.\n   */\n  importedSource: string | null;\n  /**\n   * The type of module being imported:\n   *\n   *  * 'es6'      - An ES6 module.\n   *  * 'commonjs' - A CommonJS module. (Default)\n   */\n  importedType: \"es6\" | \"commonjs\";\n  /**\n   * The type of interop behavior for namespace/default/named when loading\n   * CommonJS modules.\n   *\n   * ## 'babel' (Default)\n   *\n   * Load using Babel's interop.\n   *\n   * If '.__esModule' is true, treat as 'compiled', else:\n   *\n   * * Namespace: A copy of the module.exports with .default\n   *     populated by the module.exports object.\n   * * Default: The module.exports value.\n   * * Named: The .named property of module.exports.\n   *\n   * The 'ensureLiveReference' has no effect on the liveness of these.\n   *\n   * ## 'compiled'\n   *\n   * Assume the module is ES6 compiled to CommonJS. Useful to avoid injecting\n   * interop logic if you are confident that the module is a certain format.\n   *\n   * * Namespace: The root module.exports object.\n   * * Default: The .default property of the namespace.\n   * * Named: The .named property of the namespace.\n   *\n   * Will return erroneous results if the imported module is _not_ compiled\n   * from ES6 with Babel.\n   *\n   * ## 'uncompiled'\n   *\n   * Assume the module is _not_ ES6 compiled to CommonJS. Used a simplified\n   * access pattern that doesn't require additional function calls.\n   *\n   * Will return erroneous results if the imported module _is_ compiled\n   * from ES6 with Babel.\n   *\n   * * Namespace: The module.exports object.\n   * * Default: The module.exports object.\n   * * Named: The .named property of module.exports.\n   */\n  importedInterop: \"babel\" | \"node\" | \"compiled\" | \"uncompiled\";\n  /**\n   * The type of CommonJS interop included in the environment that will be\n   * loading the output code.\n   *\n   *  * 'babel' - CommonJS modules load with Babel's interop. (Default)\n   *  * 'node'  - CommonJS modules load with Node's interop.\n   *\n   * See descriptions in 'importedInterop' for more details.\n   */\n  importingInterop: \"babel\" | \"node\";\n  /**\n   * Define whether we explicitly care that the import be a live reference.\n   * Only applies when importing default and named imports, not the namespace.\n   *\n   *  * true  - Force imported values to be live references.\n   *  * false - No particular requirements. Keeps the code simplest. (Default)\n   */\n  ensureLiveReference: boolean;\n  /**\n   * Define if we explicitly care that the result not be a property reference.\n   *\n   *  * true  - Force calls to exclude context. Useful if the value is going to\n   *            be used as function callee.\n   *  * false - No particular requirements for context of the access. (Default)\n   */\n  ensureNoContext: boolean;\n  /**\n   * Define whether the import should be loaded before or after the existing imports.\n   * \"after\" is only allowed inside ECMAScript modules, since it's not possible to\n   * reliably pick the location _after_ require() calls but _before_ other code in CJS.\n   */\n  importPosition: \"before\" | \"after\";\n\n  nameHint?: string;\n  blockHoist?: number;\n};\n\n/**\n * A general helper classes add imports via transforms. See README for usage.\n */\nexport default class ImportInjector {\n  /**\n   * The path used for manipulation.\n   */\n  declare _programPath: NodePath<t.Program>;\n\n  /**\n   * The scope used to generate unique variable names.\n   */\n  declare _programScope: Scope;\n\n  /**\n   * The file used to inject helpers and resolve paths.\n   */\n  declare _hub: File[\"hub\"];\n\n  /**\n   * The default options to use with this instance when imports are added.\n   */\n  _defaultOpts: ImportOptions = {\n    importedSource: null,\n    importedType: \"commonjs\",\n    importedInterop: \"babel\",\n    importingInterop: \"babel\",\n    ensureLiveReference: false,\n    ensureNoContext: false,\n    importPosition: \"before\",\n  };\n\n  constructor(\n    path: NodePath,\n    importedSource?: string,\n    opts?: Partial<ImportOptions>,\n  ) {\n    const programPath = path.find(p => p.isProgram()) as NodePath<t.Program>;\n\n    this._programPath = programPath;\n    this._programScope = programPath.scope;\n    this._hub = programPath.hub as File[\"hub\"];\n\n    this._defaultOpts = this._applyDefaults(importedSource, opts, true);\n  }\n\n  addDefault(importedSourceIn: string, opts: Partial<ImportOptions>) {\n    return this.addNamed(\"default\", importedSourceIn, opts);\n  }\n\n  addNamed(\n    importName: string,\n    importedSourceIn: string,\n    opts: Partial<ImportOptions>,\n  ) {\n    assert(typeof importName === \"string\");\n\n    return this._generateImport(\n      this._applyDefaults(importedSourceIn, opts),\n      importName,\n    );\n  }\n\n  addNamespace(importedSourceIn: string, opts: Partial<ImportOptions>) {\n    return this._generateImport(\n      this._applyDefaults(importedSourceIn, opts),\n      null,\n    );\n  }\n\n  addSideEffect(importedSourceIn: string, opts: Partial<ImportOptions>) {\n    return this._generateImport(\n      this._applyDefaults(importedSourceIn, opts),\n      void 0,\n    );\n  }\n\n  _applyDefaults(\n    importedSource: string | Partial<ImportOptions>,\n    opts: Partial<ImportOptions> | undefined,\n    isInit = false,\n  ) {\n    let newOpts: ImportOptions;\n    if (typeof importedSource === \"string\") {\n      newOpts = { ...this._defaultOpts, importedSource, ...opts };\n    } else {\n      assert(!opts, \"Unexpected secondary arguments.\");\n      newOpts = { ...this._defaultOpts, ...importedSource };\n    }\n\n    if (!isInit && opts) {\n      if (opts.nameHint !== undefined) newOpts.nameHint = opts.nameHint;\n      if (opts.blockHoist !== undefined) newOpts.blockHoist = opts.blockHoist;\n    }\n    return newOpts;\n  }\n\n  _generateImport(\n    opts: Partial<ImportOptions>,\n    importName: string | null | undefined,\n  ) {\n    const isDefault = importName === \"default\";\n    const isNamed = !!importName && !isDefault;\n    const isNamespace = importName === null;\n\n    const {\n      importedSource,\n      importedType,\n      importedInterop,\n      importingInterop,\n      ensureLiveReference,\n      ensureNoContext,\n      nameHint,\n      importPosition,\n\n      // Not meant for public usage. Allows code that absolutely must control\n      // ordering to set a specific hoist value on the import nodes.\n      // This is ignored when \"importPosition\" is \"after\".\n      blockHoist,\n    } = opts;\n\n    // Provide a hint for generateUidIdentifier for the local variable name\n    // to use for the import, if the code will generate a simple assignment\n    // to a variable.\n    let name = nameHint || importName;\n\n    const isMod = isModule(this._programPath);\n    const isModuleForNode = isMod && importingInterop === \"node\";\n    const isModuleForBabel = isMod && importingInterop === \"babel\";\n\n    if (importPosition === \"after\" && !isMod) {\n      throw new Error(`\"importPosition\": \"after\" is only supported in modules`);\n    }\n\n    const builder = new ImportBuilder(\n      importedSource,\n      this._programScope,\n      this._hub,\n    );\n\n    if (importedType === \"es6\") {\n      if (!isModuleForNode && !isModuleForBabel) {\n        throw new Error(\"Cannot import an ES6 module from CommonJS\");\n      }\n\n      // import * as namespace from ''; namespace\n      // import def from ''; def\n      // import { named } from ''; named\n      builder.import();\n      if (isNamespace) {\n        builder.namespace(nameHint || importedSource);\n      } else if (isDefault || isNamed) {\n        builder.named(name, importName);\n      }\n    } else if (importedType !== \"commonjs\") {\n      throw new Error(`Unexpected interopType \"${importedType}\"`);\n    } else if (importedInterop === \"babel\") {\n      if (isModuleForNode) {\n        // import _tmp from ''; var namespace = interopRequireWildcard(_tmp); namespace\n        // import _tmp from ''; var def = interopRequireDefault(_tmp).default; def\n        // import _tmp from ''; _tmp.named\n        name = name !== \"default\" ? name : importedSource;\n        const es6Default = `${importedSource}$es6Default`;\n\n        builder.import();\n        if (isNamespace) {\n          builder\n            .default(es6Default)\n            .var(name || importedSource)\n            .wildcardInterop();\n        } else if (isDefault) {\n          if (ensureLiveReference) {\n            builder\n              .default(es6Default)\n              .var(name || importedSource)\n              .defaultInterop()\n              .read(\"default\");\n          } else {\n            builder\n              .default(es6Default)\n              .var(name)\n              .defaultInterop()\n              .prop(importName);\n          }\n        } else if (isNamed) {\n          builder.default(es6Default).read(importName);\n        }\n      } else if (isModuleForBabel) {\n        // import * as namespace from ''; namespace\n        // import def from ''; def\n        // import { named } from ''; named\n        builder.import();\n        if (isNamespace) {\n          builder.namespace(name || importedSource);\n        } else if (isDefault || isNamed) {\n          builder.named(name, importName);\n        }\n      } else {\n        // var namespace = interopRequireWildcard(require(''));\n        // var def = interopRequireDefault(require('')).default; def\n        // var named = require('').named; named\n        builder.require();\n        if (isNamespace) {\n          builder.var(name || importedSource).wildcardInterop();\n        } else if ((isDefault || isNamed) && ensureLiveReference) {\n          if (isDefault) {\n            name = name !== \"default\" ? name : importedSource;\n            builder.var(name).read(importName);\n            builder.defaultInterop();\n          } else {\n            builder.var(importedSource).read(importName);\n          }\n        } else if (isDefault) {\n          builder.var(name).defaultInterop().prop(importName);\n        } else if (isNamed) {\n          builder.var(name).prop(importName);\n        }\n      }\n    } else if (importedInterop === \"compiled\") {\n      if (isModuleForNode) {\n        // import namespace from ''; namespace\n        // import namespace from ''; namespace.default\n        // import namespace from ''; namespace.named\n\n        builder.import();\n        if (isNamespace) {\n          builder.default(name || importedSource);\n        } else if (isDefault || isNamed) {\n          builder.default(importedSource).read(name);\n        }\n      } else if (isModuleForBabel) {\n        // import * as namespace from ''; namespace\n        // import def from ''; def\n        // import { named } from ''; named\n        // Note: These lookups will break if the module has no __esModule set,\n        // hence the warning that 'compiled' will not work on standard CommonJS.\n\n        builder.import();\n        if (isNamespace) {\n          builder.namespace(name || importedSource);\n        } else if (isDefault || isNamed) {\n          builder.named(name, importName);\n        }\n      } else {\n        // var namespace = require(''); namespace\n        // var namespace = require(''); namespace.default\n        // var namespace = require(''); namespace.named\n        // var named = require('').named;\n        builder.require();\n        if (isNamespace) {\n          builder.var(name || importedSource);\n        } else if (isDefault || isNamed) {\n          if (ensureLiveReference) {\n            builder.var(importedSource).read(name);\n          } else {\n            builder.prop(importName).var(name);\n          }\n        }\n      }\n    } else if (importedInterop === \"uncompiled\") {\n      if (isDefault && ensureLiveReference) {\n        throw new Error(\"No live reference for commonjs default\");\n      }\n\n      if (isModuleForNode) {\n        // import namespace from ''; namespace\n        // import def from ''; def;\n        // import namespace from ''; namespace.named\n        builder.import();\n        if (isNamespace) {\n          builder.default(name || importedSource);\n        } else if (isDefault) {\n          builder.default(name);\n        } else if (isNamed) {\n          builder.default(importedSource).read(name);\n        }\n      } else if (isModuleForBabel) {\n        // import namespace from '';\n        // import def from '';\n        // import { named } from ''; named;\n        // Note: These lookups will break if the module has __esModule set,\n        // hence the warning that 'uncompiled' will not work on ES6 transpiled\n        // to CommonJS.\n\n        builder.import();\n        if (isNamespace) {\n          builder.default(name || importedSource);\n        } else if (isDefault) {\n          builder.default(name);\n        } else if (isNamed) {\n          builder.named(name, importName);\n        }\n      } else {\n        // var namespace = require(''); namespace\n        // var def = require(''); def\n        // var namespace = require(''); namespace.named\n        // var named = require('').named;\n        builder.require();\n        if (isNamespace) {\n          builder.var(name || importedSource);\n        } else if (isDefault) {\n          builder.var(name);\n        } else if (isNamed) {\n          if (ensureLiveReference) {\n            builder.var(importedSource).read(name);\n          } else {\n            builder.var(name).prop(importName);\n          }\n        }\n      }\n    } else {\n      throw new Error(`Unknown importedInterop \"${importedInterop}\".`);\n    }\n\n    const { statements, resultName } = builder.done();\n\n    this._insertStatements(statements, importPosition, blockHoist);\n\n    if (\n      (isDefault || isNamed) &&\n      ensureNoContext &&\n      resultName.type !== \"Identifier\"\n    ) {\n      return sequenceExpression([numericLiteral(0), resultName]);\n    }\n    return resultName;\n  }\n\n  _insertStatements(\n    statements: t.Statement[],\n    importPosition = \"before\",\n    blockHoist = 3,\n  ) {\n    const body = this._programPath.get(\"body\");\n\n    if (importPosition === \"after\") {\n      for (let i = body.length - 1; i >= 0; i--) {\n        if (body[i].isImportDeclaration()) {\n          body[i].insertAfter(statements);\n          return;\n        }\n      }\n    } else {\n      statements.forEach(node => {\n        // @ts-expect-error handle _blockHoist\n        node._blockHoist = blockHoist;\n      });\n\n      const targetPath = body.find(p => {\n        // @ts-expect-error todo(flow->ts): avoid mutations\n        const val = p.node._blockHoist;\n        return Number.isFinite(val) && val < 4;\n      });\n\n      if (targetPath) {\n        targetPath.insertBefore(statements);\n        return;\n      }\n    }\n\n    this._programPath.unshiftContainer(\"body\", statements);\n  }\n}\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _assert = require(\"assert\");\nvar _t = require(\"@babel/types\");\nconst {\n  callExpression,\n  cloneNode,\n  expressionStatement,\n  identifier,\n  importDeclaration,\n  importDefaultSpecifier,\n  importNamespaceSpecifier,\n  importSpecifier,\n  memberExpression,\n  stringLiteral,\n  variableDeclaration,\n  variableDeclarator\n} = _t;\nclass ImportBuilder {\n  constructor(importedSource, scope, hub) {\n    this._statements = [];\n    this._resultName = null;\n    this._importedSource = void 0;\n    this._scope = scope;\n    this._hub = hub;\n    this._importedSource = importedSource;\n  }\n  done() {\n    return {\n      statements: this._statements,\n      resultName: this._resultName\n    };\n  }\n  import() {\n    this._statements.push(importDeclaration([], stringLiteral(this._importedSource)));\n    return this;\n  }\n  require() {\n    this._statements.push(expressionStatement(callExpression(identifier(\"require\"), [stringLiteral(this._importedSource)])));\n    return this;\n  }\n  namespace(name = \"namespace\") {\n    const local = this._scope.generateUidIdentifier(name);\n    const statement = this._statements[this._statements.length - 1];\n    _assert(statement.type === \"ImportDeclaration\");\n    _assert(statement.specifiers.length === 0);\n    statement.specifiers = [importNamespaceSpecifier(local)];\n    this._resultName = cloneNode(local);\n    return this;\n  }\n  default(name) {\n    const id = this._scope.generateUidIdentifier(name);\n    const statement = this._statements[this._statements.length - 1];\n    _assert(statement.type === \"ImportDeclaration\");\n    _assert(statement.specifiers.length === 0);\n    statement.specifiers = [importDefaultSpecifier(id)];\n    this._resultName = cloneNode(id);\n    return this;\n  }\n  named(name, importName) {\n    if (importName === \"default\") return this.default(name);\n    const id = this._scope.generateUidIdentifier(name);\n    const statement = this._statements[this._statements.length - 1];\n    _assert(statement.type === \"ImportDeclaration\");\n    _assert(statement.specifiers.length === 0);\n    statement.specifiers = [importSpecifier(id, identifier(importName))];\n    this._resultName = cloneNode(id);\n    return this;\n  }\n  var(name) {\n    const id = this._scope.generateUidIdentifier(name);\n    let statement = this._statements[this._statements.length - 1];\n    if (statement.type !== \"ExpressionStatement\") {\n      _assert(this._resultName);\n      statement = expressionStatement(this._resultName);\n      this._statements.push(statement);\n    }\n    this._statements[this._statements.length - 1] = variableDeclaration(\"var\", [variableDeclarator(id, statement.expression)]);\n    this._resultName = cloneNode(id);\n    return this;\n  }\n  defaultInterop() {\n    return this._interop(this._hub.addHelper(\"interopRequireDefault\"));\n  }\n  wildcardInterop() {\n    return this._interop(this._hub.addHelper(\"interopRequireWildcard\"));\n  }\n  _interop(callee) {\n    const statement = this._statements[this._statements.length - 1];\n    if (statement.type === \"ExpressionStatement\") {\n      statement.expression = callExpression(callee, [statement.expression]);\n    } else if (statement.type === \"VariableDeclaration\") {\n      _assert(statement.declarations.length === 1);\n      statement.declarations[0].init = callExpression(callee, [statement.declarations[0].init]);\n    } else {\n      _assert.fail(\"Unexpected type.\");\n    }\n    return this;\n  }\n  prop(name) {\n    const statement = this._statements[this._statements.length - 1];\n    if (statement.type === \"ExpressionStatement\") {\n      statement.expression = memberExpression(statement.expression, identifier(name));\n    } else if (statement.type === \"VariableDeclaration\") {\n      _assert(statement.declarations.length === 1);\n      statement.declarations[0].init = memberExpression(statement.declarations[0].init, identifier(name));\n    } else {\n      _assert.fail(\"Unexpected type:\" + statement.type);\n    }\n    return this;\n  }\n  read(name) {\n    this._resultName = memberExpression(this._resultName, identifier(name));\n  }\n}\nexports.default = ImportBuilder;\n\n//# sourceMappingURL=import-builder.js.map\n","import assert from \"assert\";\nimport {\n  callExpression,\n  cloneNode,\n  expressionStatement,\n  identifier,\n  importDeclaration,\n  importDefaultSpecifier,\n  importNamespaceSpecifier,\n  importSpecifier,\n  memberExpression,\n  stringLiteral,\n  variableDeclaration,\n  variableDeclarator,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport type { Scope } from \"@babel/traverse\";\nimport type { File } from \"@babel/core\";\n\n/**\n * A class to track and accumulate mutations to the AST that will eventually\n * output a new require/import statement list.\n */\nexport default class ImportBuilder {\n  private _statements: t.Statement[] = [];\n  private _resultName: t.Identifier | t.MemberExpression = null;\n\n  declare _scope: Scope;\n  declare _hub: File[\"hub\"];\n  private _importedSource: string;\n\n  constructor(importedSource: string, scope: Scope, hub: File[\"hub\"]) {\n    this._scope = scope;\n    this._hub = hub;\n    this._importedSource = importedSource;\n  }\n\n  done() {\n    return {\n      statements: this._statements,\n      resultName: this._resultName,\n    };\n  }\n\n  import() {\n    this._statements.push(\n      importDeclaration([], stringLiteral(this._importedSource)),\n    );\n    return this;\n  }\n\n  require() {\n    this._statements.push(\n      expressionStatement(\n        callExpression(identifier(\"require\"), [\n          stringLiteral(this._importedSource),\n        ]),\n      ),\n    );\n    return this;\n  }\n\n  namespace(name = \"namespace\") {\n    const local = this._scope.generateUidIdentifier(name);\n\n    const statement = this._statements[this._statements.length - 1];\n    assert(statement.type === \"ImportDeclaration\");\n    assert(statement.specifiers.length === 0);\n    statement.specifiers = [importNamespaceSpecifier(local)];\n    this._resultName = cloneNode(local);\n    return this;\n  }\n  default(name: string) {\n    const id = this._scope.generateUidIdentifier(name);\n    const statement = this._statements[this._statements.length - 1];\n    assert(statement.type === \"ImportDeclaration\");\n    assert(statement.specifiers.length === 0);\n    statement.specifiers = [importDefaultSpecifier(id)];\n    this._resultName = cloneNode(id);\n    return this;\n  }\n  named(name: string, importName: string) {\n    if (importName === \"default\") return this.default(name);\n\n    const id = this._scope.generateUidIdentifier(name);\n    const statement = this._statements[this._statements.length - 1];\n    assert(statement.type === \"ImportDeclaration\");\n    assert(statement.specifiers.length === 0);\n    statement.specifiers = [importSpecifier(id, identifier(importName))];\n    this._resultName = cloneNode(id);\n    return this;\n  }\n\n  var(name: string) {\n    const id = this._scope.generateUidIdentifier(name);\n    let statement = this._statements[this._statements.length - 1];\n    if (statement.type !== \"ExpressionStatement\") {\n      assert(this._resultName);\n      statement = expressionStatement(this._resultName);\n      this._statements.push(statement);\n    }\n    this._statements[this._statements.length - 1] = variableDeclaration(\"var\", [\n      variableDeclarator(id, statement.expression),\n    ]);\n    this._resultName = cloneNode(id);\n    return this;\n  }\n\n  defaultInterop() {\n    return this._interop(this._hub.addHelper(\"interopRequireDefault\"));\n  }\n  wildcardInterop() {\n    return this._interop(this._hub.addHelper(\"interopRequireWildcard\"));\n  }\n\n  _interop(callee: t.Expression) {\n    const statement = this._statements[this._statements.length - 1];\n    if (statement.type === \"ExpressionStatement\") {\n      statement.expression = callExpression(callee, [statement.expression]);\n    } else if (statement.type === \"VariableDeclaration\") {\n      assert(statement.declarations.length === 1);\n      statement.declarations[0].init = callExpression(callee, [\n        statement.declarations[0].init,\n      ]);\n    } else {\n      assert.fail(\"Unexpected type.\");\n    }\n    return this;\n  }\n\n  prop(name: string) {\n    const statement = this._statements[this._statements.length - 1];\n    if (statement.type === \"ExpressionStatement\") {\n      statement.expression = memberExpression(\n        statement.expression,\n        identifier(name),\n      );\n    } else if (statement.type === \"VariableDeclaration\") {\n      assert(statement.declarations.length === 1);\n      statement.declarations[0].init = memberExpression(\n        statement.declarations[0].init,\n        identifier(name),\n      );\n    } else {\n      assert.fail(\"Unexpected type:\" + statement.type);\n    }\n    return this;\n  }\n\n  read(name: string) {\n    this._resultName = memberExpression(this._resultName, identifier(name));\n  }\n}\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = isModule;\nfunction isModule(path) {\n  return path.node.sourceType === \"module\";\n}\n\n//# sourceMappingURL=is-module.js.map\n","import type { NodePath } from \"@babel/traverse\";\nimport type * as t from \"@babel/types\";\n\n/**\n * A small utility to check if a file qualifies as a module.\n */\nexport default function isModule(path: NodePath<t.Program>) {\n  return path.node.sourceType === \"module\";\n}\n"],"names":["modules","entry","mainEntry","parcelRequireName","globalName","globalObject","globalThis","self","window","global","previousRequire","cache","nodeRequire","module","require","bind","newRequire","name","jumped","currentRequire","err","Error","code","localRequire","resolve","x","id","Module","call","exports","res","isParcelRequire","moduleName","bundle","parent","register","Object","defineProperty","get","i","length","value","CodeGenerator","default","ast","opts","gen","Generator","generate","_sourceMap","_printer","constructor","normalizeOptions","_opts$recordAndTupleS","format","auxiliaryCommentBefore","auxiliaryCommentAfter","shouldPrintComment","retainLines","retainFunctionParens","comments","compact","minified","concise","indent","adjustMultilineComment","style","jsescOption","assign","quotes","wrap","minimal","recordAndTupleSyntaxType","topicToken","importAttributesKeyword","decoratorsBeforeExport","json","jsonCompatibleStrings","includes","console","error","filename","undefined","sourceMaps","_generator","_genMapping","_traceMapping","_opts$sourceFileName","_this$_inputMap$sourc","_map","_rawMappings","_sourceFileName","_lastGenLine","_lastSourceLine","_lastSourceColumn","_inputMap","map","GenMapping","sourceRoot","sourceFileName","replace","inputSourceMap","TraceMap","resolvedSources","setSourceContent","sourcesContent","keys","toEncodedMap","getDecoded","toDecodedMap","getRawMappings","allMappings","mark","generated","line","column","identifierName","identifierNamePos","_originalMapping","originalMapping","originalPositionFor","originalIdentifierMapping","source","maybeAddMapping","original","addSegment","addMapping","maybeAddSegment","fromMap","addSegmentInternal","parcelHelpers","defineInteropFlag","export","_setArray","_sourcemapCodec","file","_names","SetArray","_sources","_sourcesContent","_mappings","insert","array","index","putAll","strarr","put","addMappingInternal","skipable","mapping","content","genLine","genColumn","sourceLine","sourceColumn","sources","mappings","names","removeEmptyFinalLines","len","version","decoded","encode","out","j","seg","push","input","decodedMappings","getLine","getColumnIndex","current","prev","sourcesIndex","namesIndex","skipSource","pop","_indexes","__proto__","key","indexes","decode","Buffer","chars","intToChar","Uint8Array","charToInt","c","charCodeAt","td","TextDecoder","buf","from","buffer","byteOffset","byteLength","toString","String","fromCharCode","state","Int32Array","semi","indexOf","idx","sorted","lastCol","decodeInteger","col","hasMoreVlq","sort","sortComparator","pos","shift","integer","shouldNegate","a","b","sub","subarray","bufLength","segment","copyWithin","encodeInteger","next","num","clamped","encodedMappings","traceSegment","generatedPositionFor","allGeneratedPositionsFor","eachMapping","sourceContentFor","presortedDecodedMap","decodedMap","encodedMap","AnyMap","GREATEST_LOWER_BOUND","LEAST_UPPER_BOUND","_resolveUri","_resolveUriDefault","interopDefault","base","endsWith","nextUnsortedSegmentLine","start","isSorted","found","upperBound","haystack","needle","lowerBound","memoizedState","lastKey","lastNeedle","lastIndex","memoizedBinarySearch","low","high","binarySearch","mid","cmp","buildNullArray","mapUrl","parsed","JSON","parse","recurse","lineOffset","columnOffset","stopLine","stopColumn","sections","offset","sl","sc","nextOffset","Math","min","addSection","arguments","sourcesOffset","namesOffset","contents","append","lineI","arr","cOffset","Infinity","joined","other","LINE_GTR_ZERO","COL_GTR_EQ_ZERO","isString","_decodedMemo","stripFilename","path","lastIndexOf","slice","s","_encoded","_decoded","maybeSort","owned","unsortedIndex","_bySources","_bySourceMemos","clone","OMapping","GMapping","traceSegmentInternal","segments","memo","bias","generatedPosition","all","sourceIndex","buildBySources","memos","originalSource","originalLine","sliceGeneratedPositions","matchedColumn","max","result","_a","cb","generatedLine","generatedColumn","originalColumn","tracer","UrlType","schemeRegex","urlRegex","fileRegex","isAbsolutePath","startsWith","isRelative","test","parseAbsoluteUrl","match","exec","makeUrl","scheme","user","host","port","query","hash","type","Absolute","parseUrl","url","SchemeRelative","AbsolutePath","parseFileUrl","Query","Hash","RelativePath","Empty","normalizePath","rel","pieces","split","pointer","positive","addTrailingSlash","piece","inputType","baseUrl","baseType","stripPathFilename","queryHash","_buffer","n","_t","generatorFunctions","isFunction","isStatement","isClassBody","isTSInterfaceBody","isTSEnumDeclaration","SCIENTIFIC_NOTATION","ZERO_DECIMAL_INTEGER","NON_DECIMAL_LITERAL","PURE_ANNOTATION_RE","HAS_NEWLINE","HAS_BlOCK_COMMENT_END","needsParens","Printer","inForStatementInitCounter","_printStack","_indent","_indentChar","_indentRepeat","_insideAux","_parenPushNewlineState","_noLineTerminator","_printAuxAfterOnNextUserNode","_printedComments","Set","_endsWithInteger","_endsWithWord","_lastCommentLine","_endsWithInnerRaw","_indentInnerComments","_buf","print","_maybeAddAuxComment","dedent","semicolon","force","_appendChar","_queue","rightBrace","node","removeLastSemicolon","sourceWithOffset","loc","tokenChar","rightParens","space","_space","hasContent","lastCp","getLastChar","word","str","noLineTerminatorAfter","_maybePrintInnerComments","_append","number","Number","isInteger","token","maybeNewline","lastChar","strFirst","char","newline","getNewlineCount","_newline","endsWithCharAndNewline","removeTrailingNewline","exactSource","_catchUp","prop","withSource","sourceIdentifierName","_canMarkIdName","sourcePosition","_sourcePosition","_maybeAddParen","_maybeIndent","_maybeAddParenChar","appendChar","queue","firstChar","queueIndentation","_getIndent","_shouldIndent","parenPushNewlineState","printed","cha","chaPost","catchUp","count","getCurrentLine","_loc$prop","printTerminatorless","isLabel","terminatorState","trailingCommentsLineOffset","forceParens","_node$extra","nodeType","oldConcise","_compact","printMethod","ReferenceError","stringify","oldInAux","shouldPrintParens","extra","parenthesized","_printLeadingComments","_printTrailingComments","enteredPositionlessNode","_printAuxBeforeComment","_printAuxAfterComment","comment","_printComment","getPossibleRaw","raw","rawValue","printJoin","nodes","_nodes$0$loc","_nextNode$loc","startLine","newlineOpts","addNewlines","nextNodeStartLine","separator","statement","_printNewline","iterator","nextNode","printAndIndentOnComments","leadingComments","printBlock","body","innerComments","trailingComments","_printComments","printInnerComments","hasSpace","printedCommentsCount","size","noIndentInnerCommentsHere","printSequence","printList","items","commaSeparator","newLine","lastCommentLine","_shouldPrintComment","ignore","has","add","skipNewLines","val","noLineTerminator","isBlockComment","printNewLines","lastCharCode","_comment$loc","newlineRegex","RegExp","indentSize","getCurrentColumn","repeat","nodeLoc","hasLoc","nodeStartLine","nodeEndLine","end","lastLine","leadingCommentNewline","shouldPrint","commentStartLine","commentEndLine","singleLine","shouldSkipNewline","properties","prototype","Noop","_str","_appendCount","_last","_queueCursor","_position","_allocQueue","_pushQueue","cursor","item","_popQueue","_flush","trimRight","__mergedMap","resultMap","writable","rawMappings","queueCursor","sourcePos","_mark","position","last","_this$_map","_normalizePosition","target","printStack","isNewExpression","callee","isOrHasCallExpression","isCallExpression","isMemberExpression","object","find","expandedParens","needsWhitespace","needsWhitespaceAfter","needsWhitespaceBefore","whitespace","parens","FLIPPED_ALIAS_KEYS","isExpressionStatement","expandAliases","obj","newObj","func","fn","stack","aliases","alias","expandedWhitespaceNodes","expression","flag","isArrayExpression","isAssignmentExpression","isBinary","isBlockStatement","isIdentifier","isLiteral","isObjectExpression","isOptionalCallExpression","isOptionalMemberExpression","isStringLiteral","crawl","crawlInternal","computed","property","left","right","hasCall","hasFunction","hasHelper","isHelper","AssignmentExpression","SwitchCase","consequent","cases","LogicalExpression","Literal","CallExpression","OptionalCallExpression","VariableDeclaration","declarations","declar","enabled","init","IfStatement","ObjectProperty","ObjectTypeProperty","ObjectMethod","ObjectTypeCallProperty","_parent$properties","callProperties","ObjectTypeIndexer","_parent$properties2","_parent$callPropertie","indexers","ObjectTypeInternalSlot","_parent$properties3","_parent$callPropertie2","_parent$indexers","internalSlots","forEach","amounts","concat","ret","ArrowFunctionExpression","isExportDeclaration","ConditionalExpression","isObjectPattern","Binary","operator","isBinaryExpression","isClassExtendsClause","hasPostfixPart","isUnaryLike","isAwaitExpression","parentPos","PRECEDENCE","nodePos","isLogicalExpression","BinaryExpression","isVariableDeclarator","isFor","ClassExpression","isFirstInContext","DoExpression","async","FunctionExpression","FunctionTypeAnnotation","isUnionTypeAnnotation","isIntersectionTypeAnnotation","isArrayTypeAnnotation","isTypeAnnotation","isArrowFunctionExpression","Identifier","isFunctionExpression","isClassExpression","isFollowedByBracket","optional","isForOfStatement","isTSTypeExpression","NullableTypeAnnotation","ObjectExpression","OptionalIndexedAccessType","isIndexedAccessType","objectType","OptionalMemberExpression","SequenceExpression","isForStatement","isThrowStatement","isReturnStatement","isIfStatement","isWhileStatement","isForInStatement","isSwitchStatement","discriminant","TSTypeAssertion","TSSatisfiesExpression","TSAsExpression","TSInferType","isTSArrayType","isTSOptionalType","TSInstantiationExpression","isTSInstantiationExpression","typeParameters","TSIntersectionType","TSUnionType","isTSIntersectionType","isTSUnionType","isTSRestType","UnaryLike","IntersectionTypeAnnotation","UnionTypeAnnotation","isNullableTypeAnnotation","UpdateExpression","AwaitExpression","YieldExpression","isYieldExpression","isConditionalExpression","isUpdateExpression","isClass","isConditional","isExportDefaultDeclaration","isSequenceExpression","isTSAsExpression","isTSNonNullExpression","isTSTypeAssertion","isTaggedTemplateExpression","isTSSatisfiesExpression","in","instanceof","superClass","tag","checkParam","expressionStatement","arrowBody","exportDefault","forHead","forInHead","forOfHead","declaration","expressions","prefix","_templateLiterals","enumerable","_expressions","_statements","_classes","_methods","_modules","_types","_flow","_base","_jsx","_typescript","TaggedTemplateExpression","quasi","TemplateElement","isFirst","quasis","isLast","TemplateLiteral","AssignmentPattern","typeAnnotation","argument","BindExpression","typeArguments","alternate","Decorator","isDecoratorMemberExpression","EmptyStatement","ExpressionStatement","Import","MemberExpression","TypeError","MetaProperty","meta","ModuleExpression","directives","NewExpression","ParenthesizedExpression","PrivateName","Super","ThisExpression","UnaryExpression","V8IntrinsicIdentifier","delegate","_shouldPrintDecoratorsBeforeExport","BreakStatement","printStatementAfterKeyword","label","CatchClause","param","ContinueStatement","DebuggerStatement","DoWhileStatement","ForOfStatement","ForInStatement","ForStatement","update","needsBlock","getLastStatement","LabeledStatement","ReturnStatement","SwitchStatement","leading","cas","ThrowStatement","TryStatement","block","handlers","handler","finalizer","declare","kind","hasInits","VariableDeclarator","definite","WhileStatement","WithStatement","ForXStatement","isForOf","await","printer","ClassAccessorProperty","_node$key$loc2","decorators","endLine","tsPrintClassMemberModifiers","_variance","ClassBody","ClassDeclaration","isExportNamedDeclaration","abstract","superTypeParameters","implements","ClassMethod","_classMethodHead","ClassPrivateMethod","ClassPrivateProperty","static","ClassProperty","_node$key$loc","StaticBlock","_node$key$loc3","_methodHead","_param$leadingComment","_param$trailingCommen","firstParam","params","returnType","predicate","_params","_predicate","FunctionDeclaration","_functionHead","generator","_param","parameter","_parameters","parameters","paramLength","idNode","parentNode","nameInfo","_getFuncIdName","_id$loc","_id$loc2","_id$loc3","_id$loc4","parentType","ExportAllDeclaration","_node$attributes","_node$assertions","exportKind","attributes","assertions","_printAttributes","ExportDefaultDeclaration","maybePrintDecoratorsBeforeExport","ExportDefaultSpecifier","exported","ExportNamedDeclaration","specifiers","hasSpecial","first","isExportDefaultSpecifier","isExportNamespaceSpecifier","_node$attributes2","_node$assertions2","ExportNamespaceSpecifier","ExportSpecifier","local","ImportAttribute","ImportDeclaration","_node$attributes3","_node$assertions3","isTypeKind","importKind","phase","hasSpecifiers","isImportDefaultSpecifier","isImportNamespaceSpecifier","ImportDefaultSpecifier","ImportExpression","options","ImportNamespaceSpecifier","ImportSpecifier","imported","warningShown","warn","useAssertKeyword","isClassDeclaration","ArgumentPlaceholder","ArrayPattern","ArrayExpression","elems","elements","elem","BigIntLiteral","BooleanLiteral","DecimalLiteral","_node$loc","NullLiteral","NumericLiteral","numbers","_jsesc","ObjectPattern","props","isAssignmentPattern","shorthand","PipelineBareFunction","PipelinePrimaryTopicReference","PipelineTopicExpression","RecordExpression","startToken","endToken","RegExpLiteral","pattern","flags","SpreadElement","RestElement","StringLiteral","TopicReference","validTopicTokenSet","givenTopicTokenJSON","validTopics","Array","v","join","TupleExpression","hasOwnProperty","forOwn","callback","extend","destination","isArray","isBuffer","isObject","isNumber","isMap","isSet","singleEscapes","regexSingleEscape","regexDigit","regexWhitelist","jsesc","increaseIndentation","oldIndent","indentLevel","defaults","quote","lowercaseHex","inline1","__inline1__","inline2","__inline2__","isEmpty","useBinNumbers","useOctNumbers","useDecNumbers","useHexNumbers","toJSON","hexadecimal","toUpperCase","string","character","charAt","es6","second","codePoint","escapeEverything","charCode","longhand","escaped","isScriptContext","AnyTypeAnnotation","ArrayTypeAnnotation","elementType","BooleanLiteralTypeAnnotation","BooleanTypeAnnotation","DeclareClass","isDeclareExportDeclaration","_interfaceish","DeclareExportAllDeclaration","DeclareExportDeclaration","FlowExportDeclaration","DeclareFunction","DeclareInterface","InterfaceDeclaration","DeclareModule","DeclareModuleExports","DeclareOpaqueType","OpaqueType","DeclareTypeAlias","TypeAlias","DeclareVariable","DeclaredPredicate","EmptyTypeAnnotation","EnumBooleanBody","explicitType","enumExplicitType","enumBody","EnumBooleanMember","enumInitializedMember","EnumDeclaration","EnumDefaultedMember","EnumNumberBody","EnumNumberMember","EnumStringBody","EnumStringMember","EnumSymbolBody","ExistsTypeAnnotation","this","rest","method","FunctionTypeParam","IndexedAccessType","indexType","InferredPredicate","GenericTypeAnnotation","ClassImplements","InterfaceExtends","InterfaceTypeAnnotation","_node$extends2","extends","types","andSeparator","MixedTypeAnnotation","NullLiteralTypeAnnotation","_types2","NumberTypeAnnotation","ObjectTypeAnnotation","exact","inexact","proto","ObjectTypeSpreadProperty","supertype","impltype","QualifiedTypeIdentifier","qualification","StringTypeAnnotation","SymbolTypeAnnotation","ThisTypeAnnotation","TupleTypeAnnotation","TypeAnnotation","TypeCastExpression","TypeParameter","bound","TypeParameterDeclaration","TypeParameterInstantiation","TypeofTypeAnnotation","orSeparator","Variance","VoidTypeAnnotation","_node$extends","_node$mixins","_node$implements","mixins","_node$variance","variance","context","hasExplicitType","members","member","hasUnknownMembers","BlockStatement","_node$directives2","_node$directives$trai2","directivesLen","Directive","DirectiveLiteral","unescapedDoubleQuoteRE","unescapedSingleQuoteRE","File","program","interpreter","InterpreterDirective","Placeholder","expectedNode","Program","_node$directives","_node$directives$trai","JSXAttribute","JSXClosingElement","JSXClosingFragment","JSXElement","open","openingElement","selfClosing","child","children","closingElement","JSXEmptyExpression","JSXExpressionContainer","JSXFragment","openingFragment","closingFragment","JSXIdentifier","JSXMemberExpression","JSXNamespacedName","namespace","JSXOpeningElement","spaceSeparator","JSXOpeningFragment","JSXSpreadAttribute","JSXSpreadChild","JSXText","tsPrintBraced","tsPrintUnionOrIntersectionType","sep","tokenIfPlusMinus","tok","TSAnyKeyword","TSArrayType","_expression$trailingC","TSBigIntKeyword","TSBooleanKeyword","TSCallSignatureDeclaration","tsPrintSignatureDeclarationBase","TSConditionalType","checkType","extendsType","trueType","falseType","TSConstructSignatureDeclaration","TSConstructorType","tsPrintFunctionOrConstructorType","TSDeclareFunction","TSDeclareMethod","TSEnumDeclaration","const","isConst","TSEnumMember","initializer","TSExportAssignment","TSExpressionWithTypeArguments","TSExternalModuleReference","TSFunctionType","TSImportEqualsDeclaration","isExport","moduleReference","TSImportType","qualifier","TSIndexSignature","readonly","isStatic","TSIndexedAccessType","typeParameter","TSInterfaceBody","tsPrintTypeLiteralOrInterfaceBody","TSInterfaceDeclaration","extendz","TSIntrinsicKeyword","TSLiteralType","literal","TSMappedType","nameType","constraint","TSMethodSignature","tsPrintPropertyOrMethodName","TSModuleBlock","TSModuleDeclaration","TSNamedTupleMember","TSNamespaceExportDeclaration","TSNeverKeyword","TSNonNullExpression","TSNullKeyword","TSNumberKeyword","TSObjectKeyword","TSOptionalType","TSParameterProperty","accessibility","TSParenthesizedType","TSPropertySignature","TSQualifiedName","TSRestType","TSStringKeyword","TSSymbolKeyword","TSThisType","TSTupleType","elementTypes","TSTypeAliasDeclaration","TSTypeAnnotation","TSTypeLiteral","TSTypeOperator","TSTypeParameter","TSTypeParameterDeclaration","TSTypeParameterInstantiation","TSTypePredicate","asserts","parameterName","TSTypeQuery","exprName","TSTypeReference","typeName","TSUndefinedKeyword","TSUnknownKeyword","TSVoidKeyword","isField","override","_importInjector","addDefault","importedSource","addNamed","addNamespace","addSideEffect","_isModule","_assert","_importBuilder","numericLiteral","sequenceExpression","_defaultOpts","importedType","importedInterop","importingInterop","ensureLiveReference","ensureNoContext","importPosition","programPath","p","isProgram","_programPath","_programScope","scope","_hub","hub","_applyDefaults","importedSourceIn","importName","_generateImport","isInit","newOpts","nameHint","blockHoist","isDefault","isNamed","isNamespace","isMod","isModuleForNode","isModuleForBabel","builder","import","named","es6Default","var","wildcardInterop","defaultInterop","read","statements","resultName","done","_insertStatements","isImportDeclaration","insertAfter","_blockHoist","targetPath","isFinite","insertBefore","unshiftContainer","callExpression","cloneNode","identifier","importDeclaration","importDefaultSpecifier","importNamespaceSpecifier","importSpecifier","memberExpression","stringLiteral","variableDeclaration","variableDeclarator","_resultName","_importedSource","_scope","generateUidIdentifier","_interop","addHelper","fail","sourceType","SourceMap","bsFound","_opts$indent","_default","isType","parentOp","nodeOp","shouldParenthesizeDecoratorExpression","inExport","hasTypesOrComments","TSTypeExpression","ImportInjector","assert","isModule","ImportBuilder"],"version":3,"file":"babel.5fb614ff.js.map"}