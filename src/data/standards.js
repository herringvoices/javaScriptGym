/**
 * @type {Record<string, import("../types").StandardMeta>}
 */
const standards = {
  overview: {
    id: "overview",
    title: "How to use the handbook",
    short: "Read this first when onboarding to the practice playground.",
    // Content migrated to src/handbook/overview.mdx
  },
  "JS.PF.CON": {
    id: "JS.PF.CON",
    title: "Program Flow · Conditionals",
    short: "Branch logic with if/else and switch statements.",
    bodyMd: `### Standards\n\n- **JS.PF.CON.1** Use \`if/else\` to branch behavior based on input, state, or user actions.\n- **JS.PF.CON.2** Choose between \`if/else\` and \`switch\` and justify the choice for readability and intent.\n- **JS.PF.CON.3** Combine conditions with comparison and logical operators (\`===\`, \`>\`, \`&&\`, \`||\`, \`!\`) and correctly reason about truthy/falsy and short-circuiting.`,
  },
  "JS.PF.ITR": {
    id: "JS.PF.ITR",
    title: "Program Flow · Iteration",
    short: "Loop through data safely without off-by-one bugs.",
    bodyMd: `### Standards\n\n- **JS.PF.ITR.1** Iterate through arrays and DOM collections using loops such as \`for\` and \`for…of\` to access items and update state or UI as needed.\n- **JS.PF.ITR.2** Use loops to perform an action for each item in a collection (e.g., render elements, attach the same event listener to multiple elements).\n- **JS.PF.ITR.3** Identify and fix common loop errors (off-by-one, infinite loops, unintended mutation during iteration).`,
  },
  "JS.VDT.PRM": {
    id: "JS.VDT.PRM",
    title: "Variables & Data Types · Primitives",
    short: "Store and evaluate primitive values with clarity.",
    bodyMd: `### Standards\n\n- **JS.VDT.PRM.1** Declare and assign variables using \`let\` and \`const\` appropriately.\n- **JS.VDT.PRM.2** Store and use primitive values (\`string\`, \`number\`, \`boolean\`, \`null\`, \`undefined\`) in web applications.\n- **JS.VDT.PRM.3** Combine primitive values with operators (arithmetic, concatenation, comparison, logical) and template literals to produce and evaluate expressions.\n- **JS.VDT.PRM.4** Determine the appropriate primitive data type to use for a given situation (e.g., string vs number vs boolean).`,
  },
  "JS.VDT.COL": {
    id: "JS.VDT.COL",
    title: "Variables & Data Types · Collections",
    short: "Choose and manage objects and arrays for structured data.",
    bodyMd: `### Standards\n\n- **JS.VDT.COL.1** Create and access objects to group related data using key–value pairs.\n- **JS.VDT.COL.2** Create and access arrays to store ordered lists of values.\n- **JS.VDT.COL.3** Work with arrays of objects to represent structured data, such as API responses.\n- **JS.VDT.COL.4** Determine the appropriate collection type (object, array, array of objects, or object of array of objects) for a given situation.`,
  },
  "JS.VDT.MTH": {
    id: "JS.VDT.MTH",
    title: "Variables & Data Types · Methods & Properties",
    short: "Leverage built-in helpers to shape strings, numbers, and objects.",
    bodyMd: `### Standards\n\n- **JS.VDT.MTH.1** Use string properties and methods (e.g., \`.length\`, \`.trim()\`, \`.toLowerCase()\`, \`.split()\`, \`.replace()\`).\n- **JS.VDT.MTH.2** Use number parsing and formatting methods (e.g., \`Number()\`, \`parseInt()\`, \`parseFloat()\`, \`Number.isNaN()\`, \`.toFixed()\`).\n- **JS.VDT.MTH.3** Use object utilities and shaping methods (e.g., \`Object.keys()\`, \`Object.values()\`, \`Object.entries()\`).`,
  },
  "JS.FN.BAS": {
    id: "JS.FN.BAS",
    title: "Functions · Basics",
    short: "Write focused functions that accept inputs and return results.",
    bodyMd: `### Standards\n\n- **JS.FN.BAS.1** Declare and invoke functions, recognizing that some use parameters and/or return values while others do not.\n- **JS.FN.BAS.2** Write functions with both the \`function\` keyword and arrow syntax using both named and anonymous functions appropriately (e.g., named for reuse/clarity; anonymous for inline use).\n- **JS.FN.BAS.3** Use parameters and return values to pass data in and out of a function; prefer passing data over relying on outer variables when feasible.\n- **JS.FN.BAS.4** Compose small, single-purpose functions to build larger features (i.e. break a problem into helper functions).`,
  },
  "JS.FN.HOF": {
    id: "JS.FN.HOF",
    title: "Functions · Higher-Order Functions",
    short: "Pass functions as values and supply well-shaped callbacks.",
    bodyMd: `### Standards\n\n- **JS.FN.HOF.1** Determine when to pass a function reference and when to invoke a function, such as in event listeners where a named handler can be passed directly or an anonymous function used to supply arguments.\n- **JS.FN.HOF.2** Provide callbacks to functions (such as array methods, event listeners, or timers) that use the correct parameters and return or perform the expected behavior.`,
  },
  "JS.AR.ACC": {
    id: "JS.AR.ACC",
    title: "Arrays · Access & Updates",
    short: "Update arrays and objects without losing track of mutations.",
    bodyMd: `### Standards\n\n- **JS.AR.ACC.1** Update arrays and objects by adding, changing, or removing elements and properties using appropriate syntax.\n- **JS.AR.ACC.2** Distinguish between mutating and non-mutating operations, and choose the appropriate approach for a given task.\n- **JS.AR.ACC.3** Use arrays of objects to represent and manipulate structured data (e.g., datasets from an API, or state used to render lists).`,
  },
  "JS.AR.MTH": {
    id: "JS.AR.MTH",
    title: "Arrays · Array Methods",
    short: "Shape data with map, filter, reduce, and friends.",
    bodyMd: `### Standards\n\n- **JS.AR.MTH.1** Transform arrays using \`map\` to create new collections of values or elements.\n- **JS.AR.MTH.2** Filter arrays using \`filter\` to return subsets of values that match given criteria.\n- **JS.AR.MTH.3** Aggregate or summarize arrays using \`reduce\` to produce a single result (e.g., sum, count, lookup object).\n- **JS.AR.MTH.4** Search and validate arrays using \`find\`, \`some\`, and \`every\`.\n- **JS.AR.MTH.5** Chain methods together to perform complex array transformations efficiently.`,
  },
  "JS.DB.ERR": {
    id: "JS.DB.ERR",
    title: "Debugging · Error Messages & Stack Traces",
    short: "Read stack traces and understand root causes before fixing.",
    bodyMd: `### Standards\n\n- **JS.DB.ERR.1** Read browser/Node error messages and identify the error type (e.g., ReferenceError, TypeError, SyntaxError).\n- **JS.DB.ERR.2** Use stack traces to locate the file, line, and frame where an error originates.\n- **JS.DB.ERR.3** Reproduce an error reliably and describe the conditions that trigger it.`,
  },
  "JS.DB.TRC": {
    id: "JS.DB.TRC",
    title: "Debugging · Tracing & Inspection",
    short: "Trace program flow with logs and breakpoints.",
    bodyMd: `### Standards\n\n- **JS.DB.TRC.1** Insert \`console.log\` to trace control flow and data values at key points.\n- **JS.DB.TRC.2** Set breakpoints in DevTools, step through code, and inspect variables to monitor values, and track data in the program flow.`,
  },
  "JS.DB.BUG": {
    id: "JS.DB.BUG",
    title: "Debugging · Common Bugs & Fixes",
    short: "Recognize and resolve frequent JavaScript bugs.",
    bodyMd: `### Standards\n\n- **JS.DB.BUG.1** Diagnose and fix off-by-one and infinite loop errors in iteration.\n- **JS.DB.BUG.2** Diagnose and fix undefined/null and type errors arising from bad selectors, missing data, or wrong access paths.\n- **JS.DB.BUG.3** Resolve async timing issues (e.g., using values before fetch completes) by adding loading/error paths or moving dependent code.\n- **JS.DB.BUG.4** Identify and correct DOM sync issues (UI not updating or updating the wrong node) by checking selectors, event targets, and state.`,
  },
  "JS.SD.ELM": {
    id: "JS.SD.ELM",
    title: "State & DOM · Element Selection & Manipulation",
    short: "Select and update the DOM intentionally.",
    bodyMd: `### Standards\n\n- **JS.SD.ELM.1** Select DOM elements using \`getElementById\`, \`querySelector\`, and related methods.\n- **JS.SD.ELM.2** Read and update content and attributes of elements (e.g., \`textContent\`, \`innerHTML\`, \`src\`, \`classList\`).`,
  },
  "JS.SD.EVH": {
    id: "JS.SD.EVH",
    title: "State & DOM · Event Handling",
    short: "Attach event listeners that manage user interactions cleanly.",
    bodyMd: `### Standards\n\n- **JS.SD.EVH.1** Attach event listeners to elements using \`addEventListener\`.\n- **JS.SD.EVH.2** Access event object properties (e.g., \`event.target\`, \`preventDefault\`) to manage user interactions.\n- **JS.SD.EVH.3** Use event delegation by attaching a listener to a stable parent and handling dynamic child elements with \`event.target\` or \`closest()\`.`,
  },
  "JS.SD.STA": {
    id: "JS.SD.STA",
    title: "State & DOM · State Synchronization",
    short: "Keep UI and state aligned as users interact.",
    bodyMd: `### Standards\n\n- **JS.SD.STA.1** Maintain program state using variables/objects that reflect the current UI or user input.\n- **JS.SD.STA.2** Update the DOM when state changes to keep the UI consistent with data.\n- **JS.SD.STA.3** Read user input from form elements and update state accordingly.\n- **JS.SD.STA.4** Clear, reset, or toggle DOM elements in response to changes in state.`,
  },
  "JS.AS.PRO": {
    id: "JS.AS.PRO",
    title: "Async · Promises",
    short: "Manage asynchronous work with promise chains.",
    bodyMd: `### Standards\n\n- **JS.AS.PRO.1** Use \`.then()\` and \`.catch()\` to handle asynchronous results and errors.\n- **JS.AS.PRO.2** Explain the difference between synchronous and asynchronous code execution in simple terms (blocking vs non-blocking).`,
  },
  "JS.AS.AAW": {
    id: "JS.AS.AAW",
    title: "Async · Async/Await",
    short: "Refactor promise chains with async/await for clarity.",
    bodyMd: `### Standards\n\n- **JS.AS.AAW.1** Write functions declared with \`async\` and use \`await\` to pause until a Promise resolves.\n- **JS.AS.AAW.2** Refactor simple Promise chains into \`async/await\` for readability.`,
  },
  "JS.AS.FET": {
    id: "JS.AS.FET",
    title: "Async · Fetch & HTTP",
    short: "Fetch data and present loading and error states.",
    bodyMd: `### Standards\n\n- **JS.AS.FET.1** Use \`fetch\` to perform GET requests and display the resulting data in the DOM.\n- **JS.AS.FET.2** Use \`fetch\` with POST, PUT, and DELETE (and other methods) to send data to an API.\n- **JS.AS.FET.3** Handle loading states (e.g., “Loading…” message) while waiting for data.`,
  },
  "JS.AS.ERR": {
    id: "JS.AS.ERR",
    title: "Async · Error Handling",
    short: "Catch async errors and inform the user gracefully.",
    bodyMd: `### Standards\n\n- **JS.AS.ERR.1** Use \`.catch()\` and \`try/catch\` to handle errors in asynchronous code.\n- **JS.AS.ERR.2** Provide user feedback for common failure cases (e.g., display an error message if the API request fails).`,
  },
  "JS.DA.SCH": {
    id: "JS.DA.SCH",
    title: "Data & Applications · Schema Planning",
    short: "Plan data with ERDs, foreign keys, and join tables.",
    bodyMd: `### Standards\n\n- **JS.DA.SCH.1** Plan application data using **Entity Relationship Diagrams (ERDs)** to model entities and their relationships.\n- **JS.DA.SCH.2** Use **foreign keys** to model one-to-many relationships between entities.\n- **JS.DA.SCH.3** Use **join tables** to model many-to-many relationships between entities.`,
  },
  "JS.DA.SER": {
    id: "JS.DA.SER",
    title: "Data & Applications · Services & Handlers",
    short: "Centralize API requests in modular service files.",
    bodyMd: `### Standards\n\n- **JS.DA.SER.1** Write modular service functions organized by table that use \`fetch\` to interact with an API (e.g., \`getUsers()\`, \`createPost()\`).\n- **JS.DA.SER.2** Organize services in separate modules/files for reuse across the application.`,
  },
  "JS.DA.UTA": {
    id: "JS.DA.UTA",
    title: "Data & Applications · Utilizing Data in Apps",
    short: "Render and react to data changes in the UI.",
    bodyMd: `### Standards\n\n- **JS.DA.UTA.1** Render data from state or API responses into the DOM (e.g., displaying a list of items).\n- **JS.DA.UTA.2** Update the UI in response to changes made through services (e.g., reflect a new record, update an edited record, remove a deleted record).\n- **JS.DA.UTA.3** Handle empty, loading, and error states when working with application data.\n- **JS.DA.UTA.4** Provide simple filtering, sorting, or searching of data sets in response to user actions.`,
  },
  "JS.MO.STR": {
    id: "JS.MO.STR",
    title: "Modules & Organization · Project Structure",
    short: "Organize files so features are easy to find and maintain.",
    bodyMd: `### Standards\n\n- **JS.MO.STR.1** Organize code into feature-oriented directories (e.g., \`users/\`, \`posts/\`) or layer groups (e.g., \`services/\`, \`components/\`), and stick to one approach per project.\n- **JS.MO.STR.2** Use clear naming conventions for folders and files (lowercase-kebab or lowerCamelCase) so imports are predictable.\n- **JS.MO.STR.3** Keep assets (images, fonts, static data) in a dedicated \`assets/\` (or \`public/\`) folder and reference them consistently.`,
  },
  "JS.MO.IMP": {
    id: "JS.MO.IMP",
    title: "Modules & Organization · Import/Export",
    short: "Share code with clean ES module imports and exports.",
    bodyMd: `### Standards\n\n- **JS.MO.IMP.1** Use ES module **named** and **default** exports appropriately to share code across files.\n- **JS.MO.IMP.2** Import functions, objects, or data from other modules using ES module syntax, and keep imports organized and readable.\n- **JS.MO.IMP.3** Refactor code by moving functions or data into modules and reusing them via imports.`,
  },
};

export const standardOrder = [
  "overview",
  "JS.VDT.PRM",
  "JS.VDT.COL",
  "JS.VDT.MTH",
  "JS.FN.BAS",
  "JS.FN.HOF",
  "JS.PF.CON",
  "JS.PF.ITR",
  "JS.AR.ACC",
  "JS.AR.MTH",
  "JS.SD.ELM",
  "JS.SD.EVH",
  "JS.SD.STA",
  "JS.DB.ERR",
  "JS.DB.TRC",
  "JS.DB.BUG",
  "JS.MO.STR",
  "JS.MO.IMP",
  "JS.AS.PRO",
  "JS.AS.AAW",
  "JS.AS.FET",
  "JS.AS.ERR",
  "JS.DA.SCH",
  "JS.DA.SER",
  "JS.DA.UTA",
];

export default standards;
