# Chapter 1 — Variables: Boxes for Data (VDT.PRM)

Welcome\! Today you’ll meet the first big idea in JavaScript: **variables**. A variable is a *box* you make in code so your program can **remember** something—like a player’s score, a visitor’s name, or how many items are in a cart.

If you like plain-English mental models, keep this in your pocket:

**Variables are boxes.** You build a box, give it a label, and put something inside. Later, you use the label to look up what’s in the box.

We’ll gently turn that idea into real JavaScript.

### In this chapter, you’ll learn (VDT.PRM)

* **JS.VDT.PRM.1 — Build and label boxes (variables):** How to *declare* variables with `let` and `const`, when to choose a box you can change (`let`) vs. a box you promise not to re‑label (`const`).  
* **JS.VDT.PRM.2 — What goes in the box (primitives):** How to store and use **strings** (text), **numbers** (math), **booleans** (true/false), and the two kinds of “empty”: `(empty on purpose) and` (not assigned yet).  
* **JS.VDT.PRM.3 — Work with values using operators:** How to do **arithmetic** with numbers, **concatenation** and **interpolation** with strings, and a gentle peek at **comparisons** (`===`, `>`, etc.) and **logical operators** (`&&`, `||`, `!`) to produce `true`/`false`—without jumping into `if/else` yet.  
* **JS.VDT.PRM.4 — Pick the right type:** How to decide whether a value should be a **string**, **number**, or **boolean**, and when to use `null` for “nothing yet.”

---

## 1\) Building a box

To build a box in JavaScript, you use the word `let`. `let` is what's known as a **keyword** in JavaScript. A keyword is a reserved codeword that has a special meaning in the language—in this case, telling JavaScript, “Create a new box for me.”

```javascript
let score;

```

You just made a box named `score`. It’s empty right now. To put something inside, use the `=` sign (that’s called **assignment**):

```javascript
score = 0;

```

If you already know what should go inside when you build the box, you can do both in one step:

```javascript
let score = 0;

```

From now on, whenever you write `score` in your code, JavaScript will hand you whatever is inside that box at that moment.

### Technical Vocabulary

| Term Beginner-friendly definition Quick example |  |  |
| :---- | :---- | :---- |
| **Variable** | A named **box in memory** that holds a value you can use later. | `let score = 0;` |
| **Declare** | **Build the box.** In JS we declare with `let` or `const`. | `let score;` |
| **Assign** | **Put a value in the box** or replace what’s inside using `=`. | `score = 0;` |

---

## 2\) Labeling your box (naming)

Good labels make your code easier to read.

* Names use letters/numbers/`$`/`_`, but **must start with a letter**.  
* JavaScript cares about **capitalization**: `username` and `userName` are different.  
* Use **camelCase** for multi-word names: `totalPrice`, `firstName`.  
* Be specific: `cartTotal` is clearer than `x`.

```javascript
let userName = "Momo";
let cartTotal = 12.50;

```

---

## 3\) What can go in the box? (Primitive values)

JavaScript has five simple data types called **primitives**. A **data type** tells you what kind of value is in the box *and* what operations make sense for it—for example, **strings** are text you can concatenate, **numbers** are values you can do math with, **booleans** are true/false answers, and **null/undefined** represent “no value.” Think of each type as a different style of box with its own rules and tools.

### Strings: Your Word Boxes

Strings hold **text**—letters, numbers-as-characters, spaces, punctuation, even emoji. Put strings in quotes. You can use **double** quotes (`"Hello"`), **single** quotes (`'Hello'`), or **backticks** (\`like this\`—these are special and we'll talk more about them in a bit).

```javascript
let greeting = "Hello";

```

You can glue strings together with `+`. That’s called **concatenation**.

```javascript
let first = "Nick";
let message = "Hello, " + first + "!"; // "Hello, Nick!"

```

**Important:** `"2"` is a **string**, while `2` is a **number**. They look similar but behave differently. You can do math with 2, but not with "2".

```javascript
"2" + 2;                 // "22"  (string + number → string)
Number("2") + 2;         // 4      (convert string to number first)
parseInt("2", 10) + 2;   // 4      (another way)
parseFloat("2.99") + 1;  // 3.99

```

➡️ **A cleaner option: string interpolation** When you use **backticks** (`` ` ``), you can drop variables or even expressions straight into your string using `${ ... }`. This is called **string interpolation**.

```javascript
let first = "Nick";
let message = `Hello, ${first}!`; // "Hello, Nick!"

```

If you're looking for the backtick key, you can find it right under your Escape button. It's the same key as the tilde (\~).

It’s easier to read, especially with multi-line strings or when you’re combining lots of values:

```javascript
let price = 2;
let quantity = 3;
let total = `You bought ${quantity} items for ${price * quantity} dollars.`;

```

*When to use strings:* Names, labels, messages, IDs that aren’t used for math.

### Numbers: Your Math Boxes

Numbers are for math. They shouldn't have any quotes around them. JavaScript uses one number type for whole numbers and decimals.

```javascript
let lives = 3;          // whole number
let price = 2.99;       // decimal (floating‑point)
let quantity = 3;
let total = price * quantity; // 8.97

```

Tip: Computers store decimals in a way that can cause tiny rounding quirks (you might see `0.1 + 0.2` show `0.30000000000000004`). Don’t stress. There are formatting tricks you can learn about later.

*When to use numbers:* Counts, prices, scores, measurements.

### Booleans: Your Light Switch Boxes

Booleans answer **yes/no** questions. They’re either **true** or **false**. Imagine a light in this box that's either on or off. When you use a variable with a Boolean, the JavaScript engine looks it up and checks inside to see if the light is on or off (true or false), and reports back with the answer.

```javascript
let isLoggedIn = false;     // starts off not logged in
let isGameOver = true;      // the game ended

```

You can also **compute** booleans (no branching yet):

```javascript
let total = 41.25;
let isFreeShipping = total >= 35; // true

```

And you can **toggle** a boolean (flip it):

```javascript
let isMuted = false;
isMuted = !isMuted; // now true

```

*When to use:* Logged in or not? Checkbox checked? Dark mode on?

### Null and Undefined: Your Empty Boxes

Both mean “no value,” but they’re used differently:

* `null` — **Empty on purpose.** You set it yourself when you mean “nothing here yet.”  
* `undefined` — **Not assigned yet.** JavaScript uses this when a variable has been declared but no value was put in.

```javascript
let selectedItem = null; // we’ll fill this after the user chooses
let nextThing;           // undefined (declared, not assigned)

```

Common patterns:

* Start a variable at `null` when you expect to set it later.  
* You rarely assign `undefined` yourself; it usually happens automatically.

*When to use:* `null` when you’re intentionally waiting for a value; `undefined` is what you get by default before assignment.

---

### Technical Vocabulary

| Term Beginner-friendly definition Quick example |  |  |
| :---- | :---- | :---- |
| **String** | Text inside quotes. Use for names, messages, IDs. | `"Hello"`, `'Ari'` |
| **String interpolation** | A way to build strings by putting variables/expressions directly inside backticks with `${ }`. | `` `Hello, ${name}!` `` |
| **Number** | A numeric value you can do math with. | `42`, `3.14`, `-7` |
| **Boolean** | A true/false value. Use for yes/no, on/off. | `true`, `false` |
| **null** | An intentional empty value: “nothing yet, on purpose.” | `let item = null;` |
| **undefined** | The default nothing-here when a box hasn’t been assigned yet. | `let x; // undefined` |
| **Data type** | The kind of value in a box (string, number, etc.). | “`lives` is a number.” |

---

### Practice: Which box would you use?

* A person’s name → ?  
* The price of a candy bar → ?  
* Whether or not a checkbox is checked → ?  
* A loading screen that hasn’t picked an image yet → ?  
* Daily high temperature in °F → ?  
* “Are we in dark mode?” → ?  
* Middle initial (like "A.") → ?  
* Remaining lives in a game → ?  
* Not‑yet‑chosen shipping method → ?

**Mini challenge:** Which type is each of these? `"42"`, `42`, `true`, `null`, `undefined`. **Bonus:** Rewrite this concatenation using interpolation:

```javascript
let name = "Momo";
let greeting = "Hello, " + name + "!";

```

# Chapter 2 — Collections: Playlists & Contact Cards (JS.VDT.COL)

Welcome back\! In Chapter 1 you learned how to store single values in variables (your data **boxes**). Now we’ll learn how to store **groups** of values using **collections**. There are two main collection types in JavaScript:

* **Arrays** — like a **playlist**: an **ordered list** of items. You look things up by **position** (track 0, track 1, track 2…).  
* **Objects** — like a **contact card**: a **bag of labeled fields** (name, email, address). You look things up by **label** (called a **key**).

You can put almost anything inside them—numbers, strings, booleans, even **other arrays** and **other objects**. In day‑to‑day dev work, the most common shape you’ll see is an **array of objects** (for example, a list of products from an API).

### In this chapter, you'll learn (JS.VDT.COL)

* **JS.VDT.COL.1** **— Objects (key → value):** How to build an object with labeled fields (keys) and read values using **dot** and **bracket** notation.  
* **JS.VDT.COL.2** **— Arrays (ordered lists):** How to make arrays, access items by **index** (remember index 0\!), and understand why **order** matters.  
* **JS.VDT.COL.3** **— Arrays of objects:** How to model real‑world data (like API results) as a list where **each item is an object** with its own fields.  
* **JS.VDT.COL.4** **— Modify collections:** How to **add**, **update**, and **remove** items using the right syntax (objects: `obj.key =`, `delete`; arrays: `.push()`, `.pop()`, `.unshift()`, `.shift()`, `.splice()`).  
* **JS.VDT.COL.5** **— Choose the right shape:** How to pick between an **object**, **array**, **array of objects**, or **object of arrays** based on how you’ll look things up (by **label** or by **order**) and how the data is used.

---

## 1\) Arrays — Your Playlist Boxes (VDT.COL.2)

### What is an Array?

An **array** is basically just a **list**. In this list, the **order matters**, so we’ll think of arrays like a **music playlist**. In a music app you see tracks listed 1, 2, 3… In code, we count from **0** instead—the first position is **index 0**.

**Why this helps:**

* Playlist → **array** (the whole list)  
* Song → **element** (one item in the list)  
* Track number → **index** (the position in the list)

### Creating an array

Use **square brackets** `[]` and separate items with commas.

```javascript
let colors = ["red", "green", "blue"]; // an array of strings
let scores = [10, 12, 8];                 // an array of numbers
// Tip: JavaScript *can* mix types in one array, but beginners should keep items the same kind.
```

### Accessing items by index (track number)

To access a single item in an array, you use its **index**. Write the array’s name and then the index in **square brackets**: `arrayName[index]`. Arrays use **zero‑based indexing**, so the first item is at index **0**.

* The **first** item is at index **0**  
* The **second** item is at index **1**  
* The **third** item is at index **2**, and so on

Let’s practice with a tiny playlist:

```javascript
let playlist = ["Shimmer", "Leaf Dance", "Night Run"];
playlist[0]; // "Shimmer"  (first track)
playlist[1]; // "Leaf Dance" (second track)
playlist[2]; // "Night Run"  (third track)
```

Change what’s at a position by assigning to that **index**:

```javascript
playlist[1] = "Green Sky"; // ["Shimmer", "Green Sky", "Night Run"]
```

Friendly rule of thumb: If your app shows something as “Track 3,” the code index is `2` (one less than the human number).

**Tiny practice:**

```javascript
let steps = ["mix", "bake", "cool", "frost"];
// 1) What is the first step?           → steps[0]
// 2) Change the second step to "blend" → steps[1] = "blend"
// 3) What index holds "frost"?        → 3
```

### Properties & Methods on Arrays — Read Facts, Do Actions

We’re about to learn some useful tools that come with arrays. Think of them in two groups: **properties** (facts you can read) and **methods** (actions you can do).

* **Array methods are tools you attach to the end of your array to do stuff.** You write the array name, a dot, then the tool’s name with parentheses: `arrayName.method()`. Example: `steps.push("eat")` adds another step to our steps array: the string "eat".  
* **Properties are facts you can read about the array.** They don’t use parentheses: `arrayName.property`.

One of the most useful properties (and one **every** array has) is **`length`** — it tells you how many items are in the list:

```javascript
playlist.length; // 3
```

We use **dot notation** (the `.` between names) to reach both properties and methods: `arrayName.property` or `arrayName.method()`.

#### Example using our playlist

```javascript
let playlist = ["Shimmer", "Leaf Dance", "Night Run"];
```

---

#### `.length` — How many items (property)

Think: “How many tracks are in this playlist?”

```javascript
playlist.length; // 3
```

* **Type:** property (no `()`)  
* **Does it change the array?** No — just reads a fact  
* **Returns:** a number (the count)

---

#### `.push()` — Add to the end (method)

Think: “Add a new track to the **end** of the playlist.”

```javascript
playlist.push("Green Sky");
// playlist is now ["Shimmer", "Leaf Dance", "Night Run", "Green Sky"]
```

* **Type:** method (has `()`)  
* **Does it change the array?** Yes — adds at the end  
* **Returns:** the new length (number of items)

#### `.pop()` — Remove from the end (method)

Think: “Take the last track **off** the playlist.”

```javascript
let last = playlist.pop();
// last -> "Green Sky"
// playlist -> ["Shimmer", "Leaf Dance", "Night Run"]
```

* **Changes array?** Yes — removes the last item  
* **Returns:** the item that was removed

---

#### `.unshift()` — Add to the start (method)

Think: “Put a new track at the **beginning**.”

```javascript
playlist.unshift("Intro");
// ["Intro", "Shimmer", "Leaf Dance", "Night Run"]
```

* **Changes array?** Yes — adds to the front  
* **Returns:** the new length

#### `.shift()` — Remove from the start (method)

Think: “Take the **first** track off.”

```javascript
let first = playlist.shift();
// first -> "Intro"
// playlist -> ["Shimmer", "Leaf Dance", "Night Run"]
```

* **Changes array?** Yes — removes the first item  
* **Returns:** the item that was removed

---

#### `.splice(start, deleteCount, ...items)` — Edit the middle

Think: “Cut or insert songs **in the middle**.”

```javascript
// Remove 1 item at index 1
playlist.splice(1, 1);
// playlist -> ["Shimmer", "Night Run"]

// Insert without removing: at index 1, add two tracks
playlist.splice(1, 0, "Green Sky", "Leaf Dance");
// playlist -> ["Shimmer", "Green Sky", "Leaf Dance", "Night Run"]
```

* **`start`** \= where to begin (index)  
* **`deleteCount`** \= how many to remove  
* **`...items`** \= any new items to insert  
* **Changes array?** Yes — it edits in place  
* **Returns:** an array of the items that were removed

**Beginner pattern:**

* **Property** → no parentheses → just **read** a fact (`playlist.length`).  
* **Method** → has parentheses → **do** something (`playlist.push("Intro")`).

---

### Other data types also have properties & methods

Arrays aren’t special here—**strings** and **numbers** have them too. The dot is the same idea: read a fact or do an action.

**Strings (text)**

```javascript
let name = "Ada";
name.length;       // 3 (property: number of characters)
name.toUpperCase(); // "ADA" (method: returns a new string)
```

* Many string methods **do not change** the original string; they **return** a new one.

**Numbers (math values)**

```javascript
let price = 2.5;
price.toFixed(2); // "2.50" (method: formats as a string)
```

### Technical Vocabulary — Properties & Methods

| Term | Beginner‑friendly definition | Quick example |
| :---- | :---- | :---- |
| **Property** | A **fact** you can read about a value. No parentheses. | `playlist.length` |
| **Method** | A built‑in **action** a value can do. Uses parentheses. | `playlist.push("Intro")` |
| **Dot notation** | The `.` used to reach a property or method on a value. | `arrayName.method()` |
| **Return value** | The result a method gives back after it runs. | `let removed = arr.pop()` |
| **Mutate** | To **change** the original value/array in place. | `arr.push("x")` mutates `arr` |

**Practice (quick wins):**

1. Start with `let letters = ["a","b","c"];` Use a method to add `"d"` to the end. What is `letters.length` now?  
2. Remove the last item and store it in a variable named `lastLetter`.  
3. Insert `"start"` at the beginning. Which method did you use?  
4. Using `splice`, remove 1 item at index 1\.

### Technical Vocabulary — Arrays

| Term | Beginner‑friendly definition | Quick example |
| :---- | :---- | :---- |
| **Array** | An **ordered list** of values. | `["red", "green"]` |
| **Element** | One value inside an array. | `colors[0]` is one element |
| **Index** | The **position number** of an element (starts at 0). | `items[0]` |
| **Zero‑based indexing** | Counting starts at **0** instead of 1\. | first → index 0 |
| **Length** | How many items are in the array. | `items.length` |

---

## 2\) Objects — Your Contact Card Boxes (VDT.COL.1)

### What is an Object?

An **object** is like a **contact card** for one thing. It stores related data as **key–value pairs**—the **key** is the label (like `name` or `address`), and the **value** is what’s stored under that label. We build objects with **curly braces** `{}`.

Think about your phone’s contacts: to find a friend’s address, you open their contact (that’s the **object**), then look for the **address** field (that’s the **key**) and read the text stored there (that’s the **value**). In code, you’d do the same lookup with `friend.address` (dot notation) or `friend["address"]` (bracket notation).

* Contact card → **object** (the one thing you’re describing)  
* Field label → **key** (like `email`)  
* Field contents → **value** (like `"hannah@example.com"`)

### Creating an object

```javascript
let contact = {
  name: "Hannah",
  email: "hannah@example.com",
  address: "123 River Rd"
};
```

This object **represents one person** and gives them labeled fields.

### Looking things up by label (dot vs bracket)

Use the **label (key)** to read a value. There are two ways:

```javascript
contact.name;       // "Hannah"  ← dot notation (simple key name)
contact["email"];  // "hannah@example.com" ← bracket notation
```

**When to use which?**

* Use **dot notation** when the key is a simple word you know in advance (`user.name`). This is how you'll access information in an object most of the time.  
* Use **bracket notation** when the key has spaces or is stored in a variable:

```javascript
let field = "home address";
let person = { "home address": "200 Ocean Ave" };
person[field];           // "200 Ocean Ave"
person["home address"]; // also works
```

### Adding, updating, removing fields

You can grow or change the card as you go:

```javascript
contact.phone = "555-1234";        // add a new field
contact.address = "200 Ocean Ave"; // update an existing field
delete contact.phone;               // remove a field
```

### Objects can hold anything

Values can be strings, numbers, booleans—**even arrays or other objects**:

```javascript
contact.tags = ["friend", "soccer"];
contact.location = { city: "Nashville", state: "TN" };
```

Now `contact` has an **array** under `tags` and a **nested object** under `location`.

Important: With objects, the **order** of keys isn’t what you rely on. What matters are the **labels** (keys) you choose. An object should **represent one thing** (a person, a product, a post) with its labeled details.

### Technical Vocabulary — Objects

| Term | Beginner‑friendly definition | Quick example |
| :---- | :---- | :---- |
| **Object** | A **bag of labeled fields** (key–value pairs). | `{ name: "Ari", city: "Nashville" }` |
| **Key / Property** | The **label** inside an object. | `name`, `address` |
| **Value** | The data stored under a key. | `"Ari"`, `6155045797` |
| **Dot notation** | Access with a dot when you know the key name. | `user.name` |
| **Bracket notation** | Access with brackets/quotes (needed for spaces or dynamic keys). | `user["home address"]`, `user[key]` |

---

## 3\) Arrays of Objects — The Everyday Dev Shape (VDT.COL.3)

Most APIs send back **arrays of objects**. Each object represents one item (a product, a song, a user).

```javascript
let playlist = [
  { id: 1, title: "Shimmer", artist: "The Bots" },
  { id: 2, title: "Leaf Dance", artist: "The Botany" }
];

// access
playlist[0].title;        // "Shimmer"

// add a new song
playlist.push({ id: 3, title: "Night Run", artist: "Dex & Co" });

// update a field on an item
playlist[1].artist = "Botany Club";

// remove the second item (index 1)
playlist.splice(1, 1);
```

Imagine this as a **playlist**: the array is the list; each object is a single **track** with labeled details. To grab info from a specific track, **chain** the array index and the object’s key: `arrayName[index].key`.

```javascript
playlist[1].artist; // the artist of the *second* track
playlist[0].title;  // the title of the *first* track
```

**Rule of thumb:** The **name on the left** (`playlist`) is the whole array (the playlist). The **number in brackets** (`[1]`) picks one object (a track) from the list. After that, use **dot \+ key** (`.artist`) to read a labeled field from that object.

**Common mix‑up:** Arrays know about **positions** (`[0]`, `.length`, `.push()`), while objects know about **labels** (`.title`, `.artist`). So:

* `playlist.length` ✅ (ask the array how many tracks)  
* `playlist.title` ❌ (the array doesn’t have a title)  
* `playlist[0].title` ✅ (ask the first track object for its title)

### Technical Vocabulary — Arrays of Objects

| Term | Beginner‑friendly definition | Quick example |
| :---- | :---- | :---- |
| **Array of objects** | A list where **each item is an object** with labeled fields. | `[ {id:1, name:"Ada"}, {id:2, name:"Grace"} ]` |
| **Record / Item** | One object in the list. | `{ id: 2, name: "Grace" }` |

---

## 4\) Add, Update, Remove (VDT.COL.4)

You’ll often need to **modify** collections. Here’s the beginner‑friendly toolkit:

**Objects**

```javascript
let user = { name: "Nick" };
user.age = 30;           // add
user.name = "Nicholas"; // update
delete user.age;         // remove
```

**Arrays**

```javascript
let cart = ["apple", "banana"];
cart.push("orange");   // add at end
cart[1] = "pear";      // update by index
cart.splice(0, 1);      // remove 1 item at index 0
```

Tip: Use **objects** when you care about **labels**; use **arrays** when you care about **order**.

### Technical Vocabulary — Mutating Collections

| Term | Beginner‑friendly definition | Quick example |
| :---- | :---- | :---- |
| **Add** | Put a new field/item in. | `obj.newKey = 7`, `arr.push(7)` |
| **Update** | Change an existing value. | `obj.name = "Ada"`, `arr[0] = 99` |
| **Remove** | Take a field/item out. | `delete obj.key`, `arr.splice(0,1)` |

---

## 5\) Choosing the Right Collection (VDT.COL.5)

Think about **how you’ll look things up** and **what you care about**:

* **Object** — When you have **one thing** with labeled fields (a contact card, a product, a settings object). Order doesn’t matter.  
* **Array** — When you have a **list** of items where **order matters** or you’ll loop through them (a playlist, a to‑do list).  
* **Array of Objects** — When you have a **list of things**, and each thing has multiple fields (most API results: products, users, posts).  
* **Object of Arrays** — When you’re grouping several related lists by label (e.g., `{ todo: [...], doing: [...], done: [...] }`).

### Quick Guide — What would you pick?

| Situation | Best fit | Why |
| :---- | :---- | :---- |
| One contact with name, email, address | **Object** | You’ll look up fields by label. |
| A playlist of song titles | **Array** | Order matters; items are similar. |
| A product catalog from an API | **Array of objects** | Many items; each has fields (id, name, price). |
| A kanban board with columns | **Object of arrays** | Each column label maps to its own list. |

---

## Short Story in Code — Building a Mini Address Book

```javascript
// One contact (object)
let contact = {
  name: "Ada Lovelace",
  email: "ada@example.com",
  tags: ["friend", "work"] // an array inside an object
};

// A list of contacts (array of objects)
let contacts = [
  contact,
  { name: "Grace Hopper", email: "grace@example.com", tags: ["mentor"] }
];

// Add a new contact
contacts.push({ name: "Hannah", email: "hannah@example.com", tags: [] });

// Look up the first contact’s email
let firstEmail = contacts[0].email; // "ada@example.com"

// Update a tag for the second contact
contacts[1].tags.push("inspo");

// Remove the first contact
contacts.splice(0, 1);
```

Read it like a story: objects represent **one person**, arrays hold **many people**, and arrays often hold **objects**.

---

## Practice — Which Collection Would You Use?

* A single user’s settings (theme, fontSize, language)  
* The order of steps in a recipe  
* Search results from an API, where each result has `title`, `url`, and `snippet`  
* A board with columns `todo`, `doing`, `done`, each containing its own list of cards  
* A store’s inventory count for `apples`, `bananas`, and `pears` (look up by fruit name)

**Mini‑challenge:** Starting with `let books = [];`, add two book objects with fields `title` and `author`. Then change the author of the first book and remove the second book.

---

## Quick Review — Collections (VDT.COL)

* **COL.1 Objects:** Group data with **key–value** pairs; access with dot/bracket.  
* **COL.2 Arrays:** Store **ordered lists**; access by **index**; know `length`.  
* **COL.3 Arrays of Objects:** The most common real‑world shape (e.g., API results).  
* **COL.4 Modify Collections:** Add, update, remove with the right syntax (`obj.key =`, `delete`, `push`, `splice`).  
* **COL.5 Choose Wisely:** Pick object vs array vs array‑of‑objects based on how you’ll look things up and whether order matters.

# Chapter 3 — Toolbelts for Your Data (VDT.MTH)

So far, you’ve built **boxes** (variables) that can hold any kind of value, including **arrays**  (like playlists) and **objects** (like contact cards). But here’s the secret: every data type—whether it’s a primitive, an array, or an object—comes with its own **toolbelt**: a set of built‑in tools (properties and methods) you can use to check facts, clean things up, or transform values. You don’t have to write all these tools yourself—JavaScript gives them to you.

Think of it like this:

* **Strings** come with tools like `.split()` (cut into parts), `.trim()` (remove extra spaces), and `.toUpperCase()` (change case).  
* **Numbers** have helpers like `parseFloat()` (turn text into a number), `.toFixed()` (format decimals), and `Number.isNaN()` (check if something is not a number).  
* **Objects** can be explored with `Object.keys()`, `Object.values()`, and `Object.entries()` to list out their labels and values.

Let’s open the toolbox and see what’s in there. This chapter is more of a reference than a story: you won’t memorize all these tools at once, and that’s perfectly normal. Think of it like a reference sheet you’ll revisit—each time you use these tools in a project, they’ll stick a little more in your brain.

---

### In this chapter, you’ll learn (JS.VDT.MTH)

* **JS.VDT.MTH.1 — Strings:** Use string properties and methods (`.length`, `.trim()`, `.toLowerCase()`, `.split()`, `.replace()`).  
* **JS.VDT.MTH.2 — Numbers:** Use number parsing and formatting methods (`Number()`, `parseInt()`, `parseFloat()`, `Number.isNaN()`, `.toFixed()`).  
* **JS.VDT.MTH.3 — Objects:** Use object utilities and shaping methods (`Object.keys()`, `Object.values()`, `Object.entries()`).

---

## 1\) Properties vs Methods

We're going to be using properties and methods:

* A **property** is a **fact** you can *read* about a value (no parentheses).  
* A **method** is an **action** you can *do* with a value (has parentheses).

```javascript
let name = "Ada";
name.length;        // property → 3 characters
name.toUpperCase(); // method → "ADA"
```

**Rule of thumb:** no `()` \= fact; `()` \= do something.

---

## 2\) String Toolbelt (VDT.MTH.1)

Strings are everywhere in web development—usernames, search boxes, error messages. Here are some tools you’ll actually use:

### `.length` — How many characters?

```javascript
let username = " nick ";
username.length; // 6 (yes, spaces count!)
```

### `.trim()` — Remove spaces from the ends

Useful for cleaning up form inputs.

```javascript
let username = "   nick   ";
username.trim(); // "nick"
```

### `.toLowerCase()` & `.toUpperCase()` — Change case

Handy for search (ignore case) or for display.

```javascript
let input = "HELLO";
input.toLowerCase(); // "hello"
```

### `.split()` — Cut a string into an array

When you use `.split()`, you put the character (or characters) you want to cut on (like a comma) inside the parentheses.

```javascript
let tags = "html,css,javascript";
tags.split(","); // ["html", "css", "javascript"]
```

### `.replace()` — Swap one bit of text for another

When you use `.replace()`, you put two things inside the parentheses: first the text you want to find, then the text you want to use instead.

```javascript
let message = "I love JabaScript!";
message.replace("Jaba", "Java"); // "I love JavaScript!"
```

---

## 3\) Number Toolbelt (VDT.MTH.2)

Websites often take numbers in as **strings** (because form inputs return text), such as `"2"`. These tools help you parse, validate, and format numbers.

### `Number()`, `parseInt()`, `parseFloat()` — Turn text into numbers

When you use these, you put the text you want to convert inside the parentheses.

```javascript
Number("42");      // 42
parseInt("42px");  // 42 (stops at non-numeric)
parseFloat("3.14"); // 3.14 (for numbers with decimals)
```

### `Number.isNaN()` — Check if something is Not‑a‑Number

When you use `Number.isNaN()`, you put the value you want to check inside the parentheses.

```javascript
Number.isNaN("hello"); // false (it’s a string)
Number.isNaN(NaN);      // true
```

### `.toFixed()` — Format decimals (great for prices)

When you use `.toFixed()`, you put the number of decimal places you want inside the parentheses.

```javascript
let price = 2.5;
price.toFixed(2); // "2.50" (note: result is a string)
```

---

## 4\) Object Toolbelt (VDT.MTH.3)

Objects are like contact cards. To use these utilities, you put the name of the object you’re peeking at inside the parentheses. They all return arrays, which makes it easy to list out the labels and values.

```javascript
let user = { name: "Nick", role: "Instructor" };
```

### `Object.keys()` — Get all the labels

```javascript
Object.keys(user); // ["name", "role"]
```

### `Object.values()` — Get all the values

```javascript
Object.values(user); // ["Nick", "Instructor"]
```

### `Object.entries()` — Get both as pairs

```javascript
Object.entries(user);
// [["name", "Nick"], ["role", "Instructor"]]
```

Useful for looping through an object to build a table or form.

---

## Technical Vocabulary — Methods & Properties

| Term | Beginner‑friendly definition | Quick example |
| :---- | :---- | :---- |
| **Property** | A **fact** about a value (no parentheses). | `username.length` |
| **Method** | A built‑in **action** a value can do (needs parentheses). | `username.trim()` |
| **Parse** | Convert from a string into a number you can use for math. | `parseInt("42")` |
| **NaN** | Special value meaning “Not a Number.” | `Number("hi") // NaN` |
| **Object.keys()** | Makes a list of an object’s labels. | `Object.keys(user)` |
| **Object.values()** | Makes a list of an object’s values. | `Object.values(user)` |
| **Object.entries()** | Makes a list of `[label, value]` pairs. | `Object.entries(user)` |

---

## Practice — Grab Some Tools

1. A user types in `"   Momo   "`. Clean it up and show it lowercase.  
2. Take the string `"2.99"` and show it on a page as `$2.99` (with two decimal places).  
3. Given `{ title: "Web Dev", level: "Beginner" }`, list all the keys and values separately.  
4. Take the sentence `"I love CSS"` and replace `"CSS"` with `"JavaScript"`.

---

## Quick Review — Toolbelts for Data (VDT.MTH)

* **Strings:** `.length`, `.trim()`, `.toLowerCase()`, `.split()`, `.replace()`.  
* **Numbers:** `Number()`, `parseInt()`, `parseFloat()`, `Number.isNaN()`, `.toFixed()`.  
* **Objects:** `Object.keys()`, `Object.values()`, `Object.entries()`.

Each data type brings its own **toolbelt**. Reach for these tools when you need to **clean text**, **format numbers**, or **peek inside objects** while building web pages.

# Chapter 4 — Basic Functions: Recipes for Your Code (FN.BAS)

Sometimes you want to run the same code more than once—for example, every time a user clicks a button, when a page loads, or whenever you need to format a price. **Functions** make that possible: a function is a named bundle of instructions you can run whenever you need.

---

### In this chapter, you’ll learn (JS.FN.BAS)

* **JS.FN.BAS.1 — Declare & invoke functions:** Write a recipe (declare), then cook the dish (invoke). Some recipes take **parameters** and/or **return** a value, some don’t.  
* **JS.FN.BAS.2 — Function forms:** Write functions with the `function` keyword and with **arrow syntax**; choose **named** functions for reuse/clarity and **anonymous** ones for quick, inline use.  
* **JS.FN.BAS.3 — Parameters & returns:** Pass data **in** (parameters) and **out** (return values). Prefer passing data **through** the function instead of relying on outside variables.  
* **JS.FN.BAS.4 — Compose small helpers:** Break bigger problems into **small, single-purpose functions** and combine them.

---

## 1\) What is a function? (The recipe card)

Think of the JavaScript engine as your **chef**. When you **declare** a function, you’re **writing a recipe** on an index card and **handing it to the chef**. You’ve saved the instructions under a name, but you have **not** made the dish yet—you’ve only saved the recipe.

Later, whenever you want that dish, you **call** (invoke) the function by writing its name followed by `()`, and the chef cooks it—if you want it made again, you just call it again.

```javascript
// Declare (write the recipe)
function greet() {
  console.log("Hello there!");
}

// Invoke (order the dish)
greet(); // prints: Hello there!
greet(); // you can call it again
```

#### How to write a function (syntax)

The **syntax** for writing a function uses the `function` keyword, a name, parentheses (for parameters), and **curly braces** `{ }`. The code you want to run goes **inside** those braces—this is the function’s **body**—and it runs each time you call the function.

```javascript
function greet() {
  console.log("Hello there!");
}
```

#### How to run (invoke) the function

Okay, but what if we want to have the chef cook the recipe? Well, we **call** (invoke) the function by writing its name followed by `()`. Notice how `greet` is just the name of the recipe, while `greet()` means “chef, make it now.”

#### Technical Vocabulary — Functions (core)

| Term | Beginner-friendly definition | Quick example |
| :---- | :---- | :---- |
| **Function** | A named recipe (reusable instructions). | `function greet(){}` |
| **Declare** | Write the recipe. No cooking yet. | `function greet(){}` |
| **Invoke / call** | Use the recipe **now** by adding parentheses. | `greet()` |
| **Body** | The steps inside the function’s `{ }`. | code between the braces |

---

## 2\) Parameters & arguments (customizing the dish)

Okay, we’ve got our recipe—but what if we don’t want the pasta to be the same every time? Maybe the customer chooses the protein (chicken, beef, tofu), the spice level, or the name to greet. Those changeable details are **parameters**—labeled blanks on the recipe card. When you actually place an order, you fill in those blanks with **arguments**—the specific choices for this run.

* **Parameters** are the labeled blanks **on the card** (in the function declaration).  
* **Arguments** are the **actual values** you shout when you call it.

```javascript
function greet(name) {                 // "name" is a parameter
  console.log("Hello, " + name + "!");
}

greet("Ada");   // "Ada" is an argument → prints: Hello, Ada!
greet("Grace"); // prints: Hello, Grace!
```

### Returning a value (handing a plated dish back to you)

Sometimes the chef should **give something back**—not just print. In JavaScript, that’s what `return` is for: when you invoke a function, whatever it `return`s comes **back to the call site** and **takes the place of the function call**. Think of it like shouting an order and getting a plated dish in your hands—now you can use that dish in a bigger meal.

```javascript
function fullName(first, last) {
  return first + " " + last; // send a value back to the caller
}

// The returned value replaces the call at the call site:
let label = "Customer: " + fullName("Ada", "Lovelace");
console.log(label); // "Customer: Ada Lovelace"

// Or capture it first:
let result = fullName("Ada", "Lovelace");
console.log(result); // "Ada Lovelace"
```

* `return` ends the function **and** hands a value back.  
* If you don’t `return`, the function returns `undefined`.

Friendly rule: **Prefer returning** a value over doing everything with `console.log`. You can always log the result later—return keeps your functions reusable.

#### Technical Vocabulary — Parameters & Returns

| Term | Beginner-friendly definition | Quick example |
| :---- | :---- | :---- |
| **Parameter** | A named input listed in the function’s parentheses. | `function greet(name){...}` |
| **Argument** | The actual value you pass **in** when calling the function. | `greet("Ada")` |
| **Return value** | The value a function hands back with `return`. | `return first + last` |
| **Side effect** | Anything a function does besides returning (e.g., logging). | `console.log(...)` |

---

## 3\) Two ways to write functions (declarations & arrows)

You’ll mainly see **two forms** of functions written out. You don’t have to pick a “forever favorite” yet—what matters is that you **recognize both** when you see them and know what they do.

### A) `function` declaration (great default for named, reusable helpers)

```javascript
function add(a, b) {
  return a + b;
}

add(2, 3); // 5
```

* **What it is:** A **named** function defined with the `function` keyword.  
* **Why it’s nice:** Clear name in code and error messages; available **before** its place in the file (that’s called **hoisting**); good for top‑level helpers you’ll reuse.

### B) Arrow function (short, great for inline helpers & callbacks)

```javascript
const subtract = (a, b) => {
  return a - b;
};
```

* **Plain English:** An arrow function is a function **stored in a variable**. Read it like: “take these parameters, then `=>` **do this work**.” The arrow **points to what the function will do**.  
* **Why it’s nice:** Shorter to write; can use the **single‑expression shortcut** (see below); perfect for quick, inline helpers (you’ll see them a lot with arrays and events).

**Syntax notes on arrow functions**

Arrow functions have their own little grammar rules. Here’s what to watch for:

* **Parameters:** These go in parentheses. With **one** parameter you can omit the parentheses: `n => n * n`. With **zero or many**, you need them: `() => 4 - 2`, `(a, b) => a + b`. This makes them flexible, but remember the parentheses help you see clearly what inputs your function expects.  
* **Curly braces & return:** If you’re only doing a quick, one‑liner, you don’t even need curly braces\! In that case, the arrow function will **automatically return** whatever the expression evaluates to. But if you do include curly braces (to write multiple steps inside), make sure you also include the `return` keyword to hand back a value—otherwise the function will return `undefined`.  
* **Implicit return (shortcut):** Like we just said, if you leave off the braces, the arrow function automatically returns the result of that single expression. This is called an **implicit return**, and it’s great for short, simple functions where all you need is one quick calculation or string.

**Single‑expression shortcuts (implicit return)**

```javascript
const square = n => n * n;  //one param → no ()
const greet  = name => "Hi, " + name + "!"; //one param → no ()
const roll   = () => Math.floor(Math.random() * 6) + 1; // zero params → ()
```

**Common gotchas with arrows**

```javascript
// 1) Braces without return → returns undefined
const badSquare = n => { n * n };  // ❌ undefined
const goodSquare = n => { return n * n }; // ✅

// 2) Returning an object literal needs parentheses
const makeUser = (id, name) => ({ id: id, name: name }); // ✅
// without the parentheses, `{}` looks like a function body
```

### Named vs anonymous functions (quick primer)

Most functions have a name, but sometimes you might want to use a function only once or pass it quickly into another function. At these times, developers use what’s called an **anonymous function**.

* **Named functions** have an identifier you can refer to later and see in stack traces:

```javascript
function formatPrice(x) { return "$" + x.toFixed(2); }
const double = n => n * 2; // named via the variable
```

* **Anonymous functions** don’t have their own name—common for quick, inline use:

```javascript
setTimeout(() => { console.log("Hi!"); }, 500);
//       ^ anonymous arrow used as a one‑off callback
```

* We’ll use anonymous functions a lot with arrays and events, and we’ll go deeper on patterns in the **next chapter**. For now, just recognize that **named \= good for reuse/clarity**, **anonymous \= handy for one‑offs**.

#### Technical Vocabulary — Function Forms

| Term | Beginner-friendly definition | Quick example |
| :---- | :---- | :---- |
| **Function declaration** | Named recipe defined with the `function` keyword. | `function add(a,b){ return a+b }` |
| **Arrow function** | Shorter function syntax using `=>`. | `const x = n => n*n` |
| **Anonymous function** | A function without a name (often inline). | `setTimeout(() => {...}, 500)` |

## 4\) Prefer passing data in & returning data out (clean functions)

It’s tempting to reach out and grab variables from the outside world, but your recipes are easier to test and reuse if they **take inputs** (parameters) and **return outputs**. When you rely on values that live outside a function, your function becomes tied to its environment. That makes it harder to reuse in a different situation and harder to understand just by looking at it.

**Relying on outer variables (harder to reuse):**

```javascript
let taxRate = 0.1;

function totalWithTax(subtotal) {
  return subtotal + subtotal * taxRate; // reaches outside
}

// Works here, but only because taxRate happens to exist outside.
```

**Passing data in (clearer, more reusable):**

```javascript
function totalWithTax(subtotal, taxRate) {
  return subtotal + subtotal * taxRate; // uses only its inputs
}

totalWithTax(50, 0.08); // 54
```

This version makes the function **self‑contained**: it doesn’t assume anything about the outside world. Anyone can use it by providing the two values it needs. This makes your code more predictable and easier to test—you can give it inputs and check the output without setting up extra variables elsewhere.

Rule of thumb: If your function needs a value, **make it a parameter**. If your function produces a value, **return** it.

---

## 5\) Simple function examples

Here are a few small, practical functions you might see (or write) as a web developer:

```javascript
// Show a welcome message
function showWelcome(name) {
  alert("Welcome, " + name + "!");
}

// Convert Celsius to Fahrenheit
function toFahrenheit(celsius) {
  return (celsius * 9/5) + 32;
}

// Toggle a CSS class on an element
function toggleHighlight(element) {
  element.classList.toggle("highlight");
}

// Format today’s date as MM/DD/YYYY
function formatToday() {
  const d = new Date();
  return (d.getMonth()+1) + "/" + d.getDate() + "/" + d.getFullYear();
}
```

These are simple, reusable patterns: show a message, calculate a value, manipulate the DOM, or work with dates. Functions let you put a useful action in a box so you can reuse it wherever you need it.

---

## 6\) Practice Problems

Try these hands-on exercises to check your understanding of functions:

### Declaration or Invocation?

Identify whether each snippet is a **declaration** or an **invocation**.

```javascript
function makeSandwich() {
  console.log("Sandwich made!");
}

makeSandwich();

function increaseScore() {
  score = score + 5;
}

increaseScore();
increaseScore();
```

---

### Write Your Own

Write a function called `cheer` that adds 1 to a variable called `teamPoints` (assume `let teamPoints = 0;` is already declared above).

Then, invoke your `cheer` function two times. What is the value of `teamPoints` now?

---

### Use and Reuse

Here’s code that decreases the number of lives by 1 each time:

```javascript
numLives = numLives - 1;
numLives = numLives - 1;
numLives = numLives - 1;
```

Rewrite it by declaring a function called `loseLife` that does the subtraction, then call it three times.

---

## 

